// packages/db/prisma/schema.prisma
// Prisma schema for Dars Player v1 (packages/db).
// IDs use cuid(); timestamps use timestamptz.
// Comments explain purpose of fields / constraints.

generator client {
  provider = "prisma-client-js"
  // Prisma client will be generated under packages/db/node_modules/.prisma/client
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//////////////////////////
// Enums
//////////////////////////

// content lifecycle status
enum Status {
  draft
  review
  published
  archived
}

// global roles like admin/listener
enum GlobalRole {
  admin
  listener
}

// scholar-scoped roles
enum ScholarRole {
  scholar
  scholar_editor
}

//////////////////////////
// Users & Roles
//////////////////////////

model User {
  // primary id (cuid)
  id                String    @id @default(cuid())
  // optional email (nullable); we normalize it to emailNormalized for unique checks
  email             String?
  emailNormalized   String?   // should be set by app code (lowercase + trim)
  emailVerifiedAt   DateTime?
  name              String?
  preferredLanguage String?
  // auth
  passwordHash      String?   // nullable to support social-only accounts
  passwordUpdatedAt DateTime?
  lastLoginAt       DateTime?
  // create / update timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime? // null = never edited
  // deletion / erasure flow
  deactivatedAt     DateTime? // user self-deactivated (soft)
  erasureRequestedAt DateTime? // user requested full erasure (explicit email flow)
  erasedAt          DateTime? // actual erasure timestamp (after admin job)
  // moderation
  isBanned          Boolean   @default(false)

  // relations
  globalRoles       UserGlobalRole[]
  scholarRoles      UserScholarRole[]
  progress          UserLectureProgress[]
  favorites         FavoriteLecture[]

  @@index([emailNormalized], map: "idx_user_emailnorm")
  @@index([deactivatedAt], map: "idx_user_deactivated")
  @@index([erasureRequestedAt], map: "idx_user_erasure_requested")
  @@index([lastLoginAt], map: "idx_user_last_login")
}

model UserGlobalRole {
  // global roles like 'admin' or 'listener'
  userId    String
  role      GlobalRole
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@id([userId, role])
  @@index([role, userId], map: "idx_globalrole_role_user")
}

model UserScholarRole {
  // scoped role: a user can be scholar or scholar_editor for a given scholar
  userId         String
  scholarId      String
  role           ScholarRole
  createdAt      DateTime @default(now())
  createdByUserId String? // who created this mapping (admin / scholar)

  user    User    @relation(fields: [userId], references: [id], onDelete: Restrict)
  scholar Scholar @relation(fields: [scholarId], references: [id], onDelete: Restrict)
  // optionally link creator (audit)
  createdByUser User? @relation("createdByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@id([userId, scholarId, role])
  @@index([scholarId, role], map: "idx_user_scholar_role_scholar_role")
  @@index([userId], map: "idx_user_scholar_role_user")
}

//////////////////////////
// Scholars
//////////////////////////

model Scholar {
  id           String   @id @default(cuid())
  slug         String   // e.g. ibn-baz
  name         String
  bio          String?
  country      String?
  mainLanguage String?
  imageUrl     String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime?

  // relations
  collections  Collection[]
  series       Series[]
  lectures     Lecture[]
  userRoles    UserScholarRole[]

  @@unique([slug], map: "uq_scholar_slug")
  @@index([isActive], map: "idx_scholar_active")
}

//////////////////////////
// Collections (big containers)
//////////////////////////

model Collection {
  id           String   @id @default(cuid())
  scholarId    String
  slug         String
  title        String
  description  String?
  coverImageUrl String?
  language     String?
  status       Status   @default(draft) // now includes 'review'
  orderIndex   Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime?

  // soft-delete fields for the 30-day grace period
  deletedAt    DateTime?
  deleteAfterAt DateTime?

  // relations
  scholar  Scholar @relation(fields: [scholarId], references: [id], onDelete: Restrict)
  series   Series[]
  topics   CollectionTopic[]

  @@unique([scholarId, slug], map: "uq_collection_scholar_slug")
  @@index([scholarId, status], map: "idx_collection_scholar_status")
  @@index([scholarId, orderIndex], map: "idx_collection_scholar_order")
  @@index([deletedAt], map: "idx_collection_deleted")
  @@index([deleteAfterAt], map: "idx_collection_deleteafter")
}

//////////////////////////
// Series
//////////////////////////

model Series {
  id           String   @id @default(cuid())
  scholarId    String
  collectionId String?  // nullable: series can be standalone or in a collection
  slug         String
  title        String
  description  String?
  coverImageUrl String?
  language     String?
  status       Status  @default(draft)
  orderIndex   Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime?

  deletedAt    DateTime?
  deleteAfterAt DateTime?

  // relations
  scholar  Scholar @relation(fields: [scholarId], references: [id], onDelete: Restrict)
  collection Collection? @relation(fields: [collectionId], references: [id], onDelete: Restrict)
  lectures Lecture[]
  topics   SeriesTopic[]

  @@unique([scholarId, slug], map: "uq_series_scholar_slug")
  @@index([collectionId, orderIndex], map: "idx_series_collection_order")
  @@index([scholarId, status], map: "idx_series_scholar_status")
  @@index([deletedAt], map: "idx_series_deleted")
  @@index([deleteAfterAt], map: "idx_series_deleteafter")
}

//////////////////////////
// Lectures (playable units)
//////////////////////////

model Lecture {
  id             String   @id @default(cuid())
  scholarId      String
  seriesId       String?
  slug           String
  title          String
  description    String?
  language       String?
  status         Status  @default(draft)
  publishedAt    DateTime?
  orderIndex     Int?
  durationSeconds Int?
  createdAt      DateTime @default(now())
  updatedAt      DateTime?

  deletedAt      DateTime?
  deleteAfterAt  DateTime?

  // relations
  scholar  Scholar @relation(fields: [scholarId], references: [id], onDelete: Restrict)
  series   Series? @relation(fields: [seriesId], references: [id], onDelete: Restrict)
  audioAssets AudioAsset[]
  topics     LectureTopic[]
  progress   UserLectureProgress[]
  favorites  FavoriteLecture[]

  @@unique([scholarId, slug], map: "uq_lecture_scholar_slug")
  @@index([seriesId, orderIndex], map: "idx_lecture_series_order")
  @@index([scholarId, status], map: "idx_lecture_scholar_status")
  @@index([publishedAt], map: "idx_lecture_publishedat")
  @@index([deletedAt], map: "idx_lecture_deleted")
  @@index([deleteAfterAt], map: "idx_lecture_deleteafter")
}

//////////////////////////
// AudioAssets (one or many per lecture)
// (per your rule: no soft-delete for audio assets; if lecture is removed, cascade will delete assets)
//////////////////////////

model AudioAsset {
  id             String   @id @default(cuid())
  lectureId      String
  url            String
  format         String?
  bitrateKbps    Int?
  sizeBytes      BigInt?
  durationSeconds Int?
  source         String?
  isPrimary      Boolean  @default(false)
  createdAt      DateTime @default(now())

  lecture Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  @@index([lectureId], map: "idx_audioasset_lecture")
  // partial unique index for primary must be created via raw SQL after migration:
  //   CREATE UNIQUE INDEX uq_audioasset_lecture_primary ON "AudioAsset"("lectureId") WHERE (isPrimary);
}

//////////////////////////
// Topics & join tables (lecture, series, collection)
//////////////////////////

model Topic {
  id        String   @id @default(cuid())
  slug      String
  name      String
  parentId  String?
  createdAt DateTime @default(now())

  parent    Topic?   @relation("TopicToParent", fields: [parentId], references: [id], onDelete: SetNull)
  children  Topic[]  @relation("TopicToParent")
  lectureTopics  LectureTopic[]
  seriesTopics   SeriesTopic[]
  collectionTopics CollectionTopic[]

  @@unique([slug], map: "uq_topic_slug")
  @@index([parentId], map: "idx_topic_parent")
}

model LectureTopic {
  lectureId String
  topicId   String
  createdAt DateTime @default(now())

  lecture Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  topic   Topic   @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@id([lectureId, topicId])
  @@index([topicId, lectureId], map: "idx_lecturetopic_topic_lecture")
}

model SeriesTopic {
  seriesId  String
  topicId   String
  createdAt DateTime @default(now())

  series Series @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  topic  Topic  @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@id([seriesId, topicId])
  @@index([topicId, seriesId], map: "idx_seriestopic_topic_series")
}

model CollectionTopic {
  collectionId String
  topicId      String
  createdAt    DateTime @default(now())

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  topic      Topic      @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@id([collectionId, topicId])
  @@index([topicId, collectionId], map: "idx_collectiontopic_topic_collection")
}

//////////////////////////
// Progress & Favorites
//////////////////////////

model UserLectureProgress {
  userId         String
  lectureId      String
  positionSeconds Int    @default(0)
  isCompleted    Boolean @default(false)
  updatedAt      DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Restrict)
  lecture Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  @@id([userId, lectureId])
  @@index([userId, updatedAt], map: "idx_progress_user_updatedat")
  @@index([lectureId], map: "idx_progress_lecture")
}

model FavoriteLecture {
  userId    String
  lectureId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Restrict)
  lecture Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  @@id([userId, lectureId])
  @@index([userId, createdAt], map: "idx_fav_user_createdat")
  @@index([lectureId], map: "idx_fav_lecture")
}
