/**
 * Client
 **/

import * as runtime from "./runtime/client.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model IngestionBatch
 *
 */
export type IngestionBatch = $Result.DefaultSelection<Prisma.$IngestionBatchPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model UserGlobalRole
 *
 */
export type UserGlobalRole = $Result.DefaultSelection<Prisma.$UserGlobalRolePayload>;
/**
 * Model UserScholarRole
 *
 */
export type UserScholarRole = $Result.DefaultSelection<Prisma.$UserScholarRolePayload>;
/**
 * Model Scholar
 *
 */
export type Scholar = $Result.DefaultSelection<Prisma.$ScholarPayload>;
/**
 * Model Collection
 *
 */
export type Collection = $Result.DefaultSelection<Prisma.$CollectionPayload>;
/**
 * Model Series
 *
 */
export type Series = $Result.DefaultSelection<Prisma.$SeriesPayload>;
/**
 * Model Lecture
 *
 */
export type Lecture = $Result.DefaultSelection<Prisma.$LecturePayload>;
/**
 * Model AudioAsset
 *
 */
export type AudioAsset = $Result.DefaultSelection<Prisma.$AudioAssetPayload>;
/**
 * Model Topic
 *
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>;
/**
 * Model LectureTopic
 *
 */
export type LectureTopic = $Result.DefaultSelection<Prisma.$LectureTopicPayload>;
/**
 * Model SeriesTopic
 *
 */
export type SeriesTopic = $Result.DefaultSelection<Prisma.$SeriesTopicPayload>;
/**
 * Model CollectionTopic
 *
 */
export type CollectionTopic = $Result.DefaultSelection<Prisma.$CollectionTopicPayload>;
/**
 * Model UserLectureProgress
 *
 */
export type UserLectureProgress = $Result.DefaultSelection<Prisma.$UserLectureProgressPayload>;
/**
 * Model FavoriteLecture
 *
 */
export type FavoriteLecture = $Result.DefaultSelection<Prisma.$FavoriteLecturePayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
    draft: "draft";
    review: "review";
    published: "published";
    archived: "archived";
  };

  export type Status = (typeof Status)[keyof typeof Status];

  export const GlobalRole: {
    admin: "admin";
    listener: "listener";
  };

  export type GlobalRole = (typeof GlobalRole)[keyof typeof GlobalRole];

  export const ScholarRole: {
    scholar: "scholar";
    scholar_editor: "scholar_editor";
  };

  export type ScholarRole = (typeof ScholarRole)[keyof typeof ScholarRole];
}

export type Status = $Enums.Status;

export const Status: typeof $Enums.Status;

export type GlobalRole = $Enums.GlobalRole;

export const GlobalRole: typeof $Enums.GlobalRole;

export type ScholarRole = $Enums.ScholarRole;

export const ScholarRole: typeof $Enums.ScholarRole;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more IngestionBatches
 * const ingestionBatches = await prisma.ingestionBatch.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more IngestionBatches
   * const ingestionBatches = await prisma.ingestionBatch.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.ingestionBatch`: Exposes CRUD operations for the **IngestionBatch** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IngestionBatches
   * const ingestionBatches = await prisma.ingestionBatch.findMany()
   * ```
   */
  get ingestionBatch(): Prisma.IngestionBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGlobalRole`: Exposes CRUD operations for the **UserGlobalRole** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserGlobalRoles
   * const userGlobalRoles = await prisma.userGlobalRole.findMany()
   * ```
   */
  get userGlobalRole(): Prisma.UserGlobalRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userScholarRole`: Exposes CRUD operations for the **UserScholarRole** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserScholarRoles
   * const userScholarRoles = await prisma.userScholarRole.findMany()
   * ```
   */
  get userScholarRole(): Prisma.UserScholarRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scholar`: Exposes CRUD operations for the **Scholar** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Scholars
   * const scholars = await prisma.scholar.findMany()
   * ```
   */
  get scholar(): Prisma.ScholarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **Collection** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Collections
   * const collections = await prisma.collection.findMany()
   * ```
   */
  get collection(): Prisma.CollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **Series** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Series
   * const series = await prisma.series.findMany()
   * ```
   */
  get series(): Prisma.SeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lecture`: Exposes CRUD operations for the **Lecture** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Lectures
   * const lectures = await prisma.lecture.findMany()
   * ```
   */
  get lecture(): Prisma.LectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioAsset`: Exposes CRUD operations for the **AudioAsset** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AudioAssets
   * const audioAssets = await prisma.audioAsset.findMany()
   * ```
   */
  get audioAsset(): Prisma.AudioAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Topics
   * const topics = await prisma.topic.findMany()
   * ```
   */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lectureTopic`: Exposes CRUD operations for the **LectureTopic** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LectureTopics
   * const lectureTopics = await prisma.lectureTopic.findMany()
   * ```
   */
  get lectureTopic(): Prisma.LectureTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seriesTopic`: Exposes CRUD operations for the **SeriesTopic** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SeriesTopics
   * const seriesTopics = await prisma.seriesTopic.findMany()
   * ```
   */
  get seriesTopic(): Prisma.SeriesTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionTopic`: Exposes CRUD operations for the **CollectionTopic** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CollectionTopics
   * const collectionTopics = await prisma.collectionTopic.findMany()
   * ```
   */
  get collectionTopic(): Prisma.CollectionTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLectureProgress`: Exposes CRUD operations for the **UserLectureProgress** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserLectureProgresses
   * const userLectureProgresses = await prisma.userLectureProgress.findMany()
   * ```
   */
  get userLectureProgress(): Prisma.UserLectureProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favoriteLecture`: Exposes CRUD operations for the **FavoriteLecture** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FavoriteLectures
   * const favoriteLectures = await prisma.favoriteLecture.findMany()
   * ```
   */
  get favoriteLecture(): Prisma.FavoriteLectureDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string;
    engine: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I,
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<"OR", K>, Extends<"AND", K>>, Extends<"NOT", K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    IngestionBatch: "IngestionBatch";
    User: "User";
    UserGlobalRole: "UserGlobalRole";
    UserScholarRole: "UserScholarRole";
    Scholar: "Scholar";
    Collection: "Collection";
    Series: "Series";
    Lecture: "Lecture";
    AudioAsset: "AudioAsset";
    Topic: "Topic";
    LectureTopic: "LectureTopic";
    SeriesTopic: "SeriesTopic";
    CollectionTopic: "CollectionTopic";
    UserLectureProgress: "UserLectureProgress";
    FavoriteLecture: "FavoriteLecture";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "ingestionBatch"
        | "user"
        | "userGlobalRole"
        | "userScholarRole"
        | "scholar"
        | "collection"
        | "series"
        | "lecture"
        | "audioAsset"
        | "topic"
        | "lectureTopic"
        | "seriesTopic"
        | "collectionTopic"
        | "userLectureProgress"
        | "favoriteLecture";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      IngestionBatch: {
        payload: Prisma.$IngestionBatchPayload<ExtArgs>;
        fields: Prisma.IngestionBatchFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IngestionBatchFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IngestionBatchFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>;
          };
          findFirst: {
            args: Prisma.IngestionBatchFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IngestionBatchFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>;
          };
          findMany: {
            args: Prisma.IngestionBatchFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>[];
          };
          create: {
            args: Prisma.IngestionBatchCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>;
          };
          createMany: {
            args: Prisma.IngestionBatchCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IngestionBatchCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>[];
          };
          delete: {
            args: Prisma.IngestionBatchDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>;
          };
          update: {
            args: Prisma.IngestionBatchUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>;
          };
          deleteMany: {
            args: Prisma.IngestionBatchDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IngestionBatchUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IngestionBatchUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>[];
          };
          upsert: {
            args: Prisma.IngestionBatchUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IngestionBatchPayload>;
          };
          aggregate: {
            args: Prisma.IngestionBatchAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIngestionBatch>;
          };
          groupBy: {
            args: Prisma.IngestionBatchGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IngestionBatchGroupByOutputType>[];
          };
          count: {
            args: Prisma.IngestionBatchCountArgs<ExtArgs>;
            result: $Utils.Optional<IngestionBatchCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      UserGlobalRole: {
        payload: Prisma.$UserGlobalRolePayload<ExtArgs>;
        fields: Prisma.UserGlobalRoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserGlobalRoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserGlobalRoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>;
          };
          findFirst: {
            args: Prisma.UserGlobalRoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserGlobalRoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>;
          };
          findMany: {
            args: Prisma.UserGlobalRoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>[];
          };
          create: {
            args: Prisma.UserGlobalRoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>;
          };
          createMany: {
            args: Prisma.UserGlobalRoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserGlobalRoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>[];
          };
          delete: {
            args: Prisma.UserGlobalRoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>;
          };
          update: {
            args: Prisma.UserGlobalRoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>;
          };
          deleteMany: {
            args: Prisma.UserGlobalRoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserGlobalRoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserGlobalRoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>[];
          };
          upsert: {
            args: Prisma.UserGlobalRoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserGlobalRolePayload>;
          };
          aggregate: {
            args: Prisma.UserGlobalRoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserGlobalRole>;
          };
          groupBy: {
            args: Prisma.UserGlobalRoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGlobalRoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserGlobalRoleCountArgs<ExtArgs>;
            result: $Utils.Optional<UserGlobalRoleCountAggregateOutputType> | number;
          };
        };
      };
      UserScholarRole: {
        payload: Prisma.$UserScholarRolePayload<ExtArgs>;
        fields: Prisma.UserScholarRoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserScholarRoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserScholarRoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>;
          };
          findFirst: {
            args: Prisma.UserScholarRoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserScholarRoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>;
          };
          findMany: {
            args: Prisma.UserScholarRoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>[];
          };
          create: {
            args: Prisma.UserScholarRoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>;
          };
          createMany: {
            args: Prisma.UserScholarRoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserScholarRoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>[];
          };
          delete: {
            args: Prisma.UserScholarRoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>;
          };
          update: {
            args: Prisma.UserScholarRoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>;
          };
          deleteMany: {
            args: Prisma.UserScholarRoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserScholarRoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserScholarRoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>[];
          };
          upsert: {
            args: Prisma.UserScholarRoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserScholarRolePayload>;
          };
          aggregate: {
            args: Prisma.UserScholarRoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserScholarRole>;
          };
          groupBy: {
            args: Prisma.UserScholarRoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserScholarRoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserScholarRoleCountArgs<ExtArgs>;
            result: $Utils.Optional<UserScholarRoleCountAggregateOutputType> | number;
          };
        };
      };
      Scholar: {
        payload: Prisma.$ScholarPayload<ExtArgs>;
        fields: Prisma.ScholarFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ScholarFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ScholarFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>;
          };
          findFirst: {
            args: Prisma.ScholarFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ScholarFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>;
          };
          findMany: {
            args: Prisma.ScholarFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>[];
          };
          create: {
            args: Prisma.ScholarCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>;
          };
          createMany: {
            args: Prisma.ScholarCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ScholarCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>[];
          };
          delete: {
            args: Prisma.ScholarDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>;
          };
          update: {
            args: Prisma.ScholarUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>;
          };
          deleteMany: {
            args: Prisma.ScholarDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ScholarUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ScholarUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>[];
          };
          upsert: {
            args: Prisma.ScholarUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScholarPayload>;
          };
          aggregate: {
            args: Prisma.ScholarAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateScholar>;
          };
          groupBy: {
            args: Prisma.ScholarGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ScholarGroupByOutputType>[];
          };
          count: {
            args: Prisma.ScholarCountArgs<ExtArgs>;
            result: $Utils.Optional<ScholarCountAggregateOutputType> | number;
          };
        };
      };
      Collection: {
        payload: Prisma.$CollectionPayload<ExtArgs>;
        fields: Prisma.CollectionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CollectionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CollectionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>;
          };
          findFirst: {
            args: Prisma.CollectionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CollectionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>;
          };
          findMany: {
            args: Prisma.CollectionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[];
          };
          create: {
            args: Prisma.CollectionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>;
          };
          createMany: {
            args: Prisma.CollectionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CollectionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[];
          };
          delete: {
            args: Prisma.CollectionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>;
          };
          update: {
            args: Prisma.CollectionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>;
          };
          deleteMany: {
            args: Prisma.CollectionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CollectionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CollectionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[];
          };
          upsert: {
            args: Prisma.CollectionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>;
          };
          aggregate: {
            args: Prisma.CollectionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCollection>;
          };
          groupBy: {
            args: Prisma.CollectionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CollectionGroupByOutputType>[];
          };
          count: {
            args: Prisma.CollectionCountArgs<ExtArgs>;
            result: $Utils.Optional<CollectionCountAggregateOutputType> | number;
          };
        };
      };
      Series: {
        payload: Prisma.$SeriesPayload<ExtArgs>;
        fields: Prisma.SeriesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SeriesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SeriesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>;
          };
          findFirst: {
            args: Prisma.SeriesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SeriesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>;
          };
          findMany: {
            args: Prisma.SeriesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[];
          };
          create: {
            args: Prisma.SeriesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>;
          };
          createMany: {
            args: Prisma.SeriesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SeriesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[];
          };
          delete: {
            args: Prisma.SeriesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>;
          };
          update: {
            args: Prisma.SeriesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>;
          };
          deleteMany: {
            args: Prisma.SeriesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SeriesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SeriesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[];
          };
          upsert: {
            args: Prisma.SeriesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>;
          };
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSeries>;
          };
          groupBy: {
            args: Prisma.SeriesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SeriesGroupByOutputType>[];
          };
          count: {
            args: Prisma.SeriesCountArgs<ExtArgs>;
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number;
          };
        };
      };
      Lecture: {
        payload: Prisma.$LecturePayload<ExtArgs>;
        fields: Prisma.LectureFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LectureFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LectureFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          findFirst: {
            args: Prisma.LectureFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LectureFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          findMany: {
            args: Prisma.LectureFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[];
          };
          create: {
            args: Prisma.LectureCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          createMany: {
            args: Prisma.LectureCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LectureCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[];
          };
          delete: {
            args: Prisma.LectureDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          update: {
            args: Prisma.LectureUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          deleteMany: {
            args: Prisma.LectureDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LectureUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LectureUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[];
          };
          upsert: {
            args: Prisma.LectureUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>;
          };
          aggregate: {
            args: Prisma.LectureAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLecture>;
          };
          groupBy: {
            args: Prisma.LectureGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LectureGroupByOutputType>[];
          };
          count: {
            args: Prisma.LectureCountArgs<ExtArgs>;
            result: $Utils.Optional<LectureCountAggregateOutputType> | number;
          };
        };
      };
      AudioAsset: {
        payload: Prisma.$AudioAssetPayload<ExtArgs>;
        fields: Prisma.AudioAssetFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AudioAssetFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AudioAssetFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>;
          };
          findFirst: {
            args: Prisma.AudioAssetFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AudioAssetFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>;
          };
          findMany: {
            args: Prisma.AudioAssetFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>[];
          };
          create: {
            args: Prisma.AudioAssetCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>;
          };
          createMany: {
            args: Prisma.AudioAssetCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AudioAssetCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>[];
          };
          delete: {
            args: Prisma.AudioAssetDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>;
          };
          update: {
            args: Prisma.AudioAssetUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>;
          };
          deleteMany: {
            args: Prisma.AudioAssetDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AudioAssetUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AudioAssetUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>[];
          };
          upsert: {
            args: Prisma.AudioAssetUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AudioAssetPayload>;
          };
          aggregate: {
            args: Prisma.AudioAssetAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAudioAsset>;
          };
          groupBy: {
            args: Prisma.AudioAssetGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AudioAssetGroupByOutputType>[];
          };
          count: {
            args: Prisma.AudioAssetCountArgs<ExtArgs>;
            result: $Utils.Optional<AudioAssetCountAggregateOutputType> | number;
          };
        };
      };
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>;
        fields: Prisma.TopicFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[];
          };
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[];
          };
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[];
          };
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTopic>;
          };
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TopicGroupByOutputType>[];
          };
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>;
            result: $Utils.Optional<TopicCountAggregateOutputType> | number;
          };
        };
      };
      LectureTopic: {
        payload: Prisma.$LectureTopicPayload<ExtArgs>;
        fields: Prisma.LectureTopicFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LectureTopicFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LectureTopicFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>;
          };
          findFirst: {
            args: Prisma.LectureTopicFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LectureTopicFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>;
          };
          findMany: {
            args: Prisma.LectureTopicFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>[];
          };
          create: {
            args: Prisma.LectureTopicCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>;
          };
          createMany: {
            args: Prisma.LectureTopicCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LectureTopicCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>[];
          };
          delete: {
            args: Prisma.LectureTopicDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>;
          };
          update: {
            args: Prisma.LectureTopicUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>;
          };
          deleteMany: {
            args: Prisma.LectureTopicDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LectureTopicUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LectureTopicUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>[];
          };
          upsert: {
            args: Prisma.LectureTopicUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LectureTopicPayload>;
          };
          aggregate: {
            args: Prisma.LectureTopicAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLectureTopic>;
          };
          groupBy: {
            args: Prisma.LectureTopicGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LectureTopicGroupByOutputType>[];
          };
          count: {
            args: Prisma.LectureTopicCountArgs<ExtArgs>;
            result: $Utils.Optional<LectureTopicCountAggregateOutputType> | number;
          };
        };
      };
      SeriesTopic: {
        payload: Prisma.$SeriesTopicPayload<ExtArgs>;
        fields: Prisma.SeriesTopicFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SeriesTopicFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SeriesTopicFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>;
          };
          findFirst: {
            args: Prisma.SeriesTopicFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SeriesTopicFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>;
          };
          findMany: {
            args: Prisma.SeriesTopicFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>[];
          };
          create: {
            args: Prisma.SeriesTopicCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>;
          };
          createMany: {
            args: Prisma.SeriesTopicCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SeriesTopicCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>[];
          };
          delete: {
            args: Prisma.SeriesTopicDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>;
          };
          update: {
            args: Prisma.SeriesTopicUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>;
          };
          deleteMany: {
            args: Prisma.SeriesTopicDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SeriesTopicUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SeriesTopicUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>[];
          };
          upsert: {
            args: Prisma.SeriesTopicUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SeriesTopicPayload>;
          };
          aggregate: {
            args: Prisma.SeriesTopicAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSeriesTopic>;
          };
          groupBy: {
            args: Prisma.SeriesTopicGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SeriesTopicGroupByOutputType>[];
          };
          count: {
            args: Prisma.SeriesTopicCountArgs<ExtArgs>;
            result: $Utils.Optional<SeriesTopicCountAggregateOutputType> | number;
          };
        };
      };
      CollectionTopic: {
        payload: Prisma.$CollectionTopicPayload<ExtArgs>;
        fields: Prisma.CollectionTopicFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CollectionTopicFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CollectionTopicFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>;
          };
          findFirst: {
            args: Prisma.CollectionTopicFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CollectionTopicFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>;
          };
          findMany: {
            args: Prisma.CollectionTopicFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>[];
          };
          create: {
            args: Prisma.CollectionTopicCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>;
          };
          createMany: {
            args: Prisma.CollectionTopicCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CollectionTopicCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>[];
          };
          delete: {
            args: Prisma.CollectionTopicDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>;
          };
          update: {
            args: Prisma.CollectionTopicUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>;
          };
          deleteMany: {
            args: Prisma.CollectionTopicDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CollectionTopicUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CollectionTopicUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>[];
          };
          upsert: {
            args: Prisma.CollectionTopicUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CollectionTopicPayload>;
          };
          aggregate: {
            args: Prisma.CollectionTopicAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCollectionTopic>;
          };
          groupBy: {
            args: Prisma.CollectionTopicGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CollectionTopicGroupByOutputType>[];
          };
          count: {
            args: Prisma.CollectionTopicCountArgs<ExtArgs>;
            result: $Utils.Optional<CollectionTopicCountAggregateOutputType> | number;
          };
        };
      };
      UserLectureProgress: {
        payload: Prisma.$UserLectureProgressPayload<ExtArgs>;
        fields: Prisma.UserLectureProgressFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserLectureProgressFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserLectureProgressFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>;
          };
          findFirst: {
            args: Prisma.UserLectureProgressFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserLectureProgressFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>;
          };
          findMany: {
            args: Prisma.UserLectureProgressFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>[];
          };
          create: {
            args: Prisma.UserLectureProgressCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>;
          };
          createMany: {
            args: Prisma.UserLectureProgressCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserLectureProgressCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>[];
          };
          delete: {
            args: Prisma.UserLectureProgressDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>;
          };
          update: {
            args: Prisma.UserLectureProgressUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>;
          };
          deleteMany: {
            args: Prisma.UserLectureProgressDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserLectureProgressUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserLectureProgressUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>[];
          };
          upsert: {
            args: Prisma.UserLectureProgressUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLectureProgressPayload>;
          };
          aggregate: {
            args: Prisma.UserLectureProgressAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserLectureProgress>;
          };
          groupBy: {
            args: Prisma.UserLectureProgressGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserLectureProgressGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserLectureProgressCountArgs<ExtArgs>;
            result: $Utils.Optional<UserLectureProgressCountAggregateOutputType> | number;
          };
        };
      };
      FavoriteLecture: {
        payload: Prisma.$FavoriteLecturePayload<ExtArgs>;
        fields: Prisma.FavoriteLectureFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FavoriteLectureFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FavoriteLectureFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>;
          };
          findFirst: {
            args: Prisma.FavoriteLectureFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FavoriteLectureFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>;
          };
          findMany: {
            args: Prisma.FavoriteLectureFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>[];
          };
          create: {
            args: Prisma.FavoriteLectureCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>;
          };
          createMany: {
            args: Prisma.FavoriteLectureCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FavoriteLectureCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>[];
          };
          delete: {
            args: Prisma.FavoriteLectureDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>;
          };
          update: {
            args: Prisma.FavoriteLectureUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>;
          };
          deleteMany: {
            args: Prisma.FavoriteLectureDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FavoriteLectureUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FavoriteLectureUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>[];
          };
          upsert: {
            args: Prisma.FavoriteLectureUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FavoriteLecturePayload>;
          };
          aggregate: {
            args: Prisma.FavoriteLectureAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFavoriteLecture>;
          };
          groupBy: {
            args: Prisma.FavoriteLectureGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FavoriteLectureGroupByOutputType>[];
          };
          count: {
            args: Prisma.FavoriteLectureCountArgs<ExtArgs>;
            result: $Utils.Optional<FavoriteLectureCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory;
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[];
  }
  export type GlobalOmitConfig = {
    ingestionBatch?: IngestionBatchOmit;
    user?: UserOmit;
    userGlobalRole?: UserGlobalRoleOmit;
    userScholarRole?: UserScholarRoleOmit;
    scholar?: ScholarOmit;
    collection?: CollectionOmit;
    series?: SeriesOmit;
    lecture?: LectureOmit;
    audioAsset?: AudioAssetOmit;
    topic?: TopicOmit;
    lectureTopic?: LectureTopicOmit;
    seriesTopic?: SeriesTopicOmit;
    collectionTopic?: CollectionTopicOmit;
    userLectureProgress?: UserLectureProgressOmit;
    favoriteLecture?: FavoriteLectureOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T["level"] : T>;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type IngestionBatchCountOutputType
   */

  export type IngestionBatchCountOutputType = {
    scholars: number;
    collections: number;
    series: number;
    lectures: number;
    audioAssets: number;
  };

  export type IngestionBatchCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    scholars?: boolean | IngestionBatchCountOutputTypeCountScholarsArgs;
    collections?: boolean | IngestionBatchCountOutputTypeCountCollectionsArgs;
    series?: boolean | IngestionBatchCountOutputTypeCountSeriesArgs;
    lectures?: boolean | IngestionBatchCountOutputTypeCountLecturesArgs;
    audioAssets?: boolean | IngestionBatchCountOutputTypeCountAudioAssetsArgs;
  };

  // Custom InputTypes
  /**
   * IngestionBatchCountOutputType without action
   */
  export type IngestionBatchCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatchCountOutputType
     */
    select?: IngestionBatchCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * IngestionBatchCountOutputType without action
   */
  export type IngestionBatchCountOutputTypeCountScholarsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScholarWhereInput;
  };

  /**
   * IngestionBatchCountOutputType without action
   */
  export type IngestionBatchCountOutputTypeCountCollectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CollectionWhereInput;
  };

  /**
   * IngestionBatchCountOutputType without action
   */
  export type IngestionBatchCountOutputTypeCountSeriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesWhereInput;
  };

  /**
   * IngestionBatchCountOutputType without action
   */
  export type IngestionBatchCountOutputTypeCountLecturesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureWhereInput;
  };

  /**
   * IngestionBatchCountOutputType without action
   */
  export type IngestionBatchCountOutputTypeCountAudioAssetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AudioAssetWhereInput;
  };

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    globalRoles: number;
    scholarRoles: number;
    createdScholarRoles: number;
    progress: number;
    favorites: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    globalRoles?: boolean | UserCountOutputTypeCountGlobalRolesArgs;
    scholarRoles?: boolean | UserCountOutputTypeCountScholarRolesArgs;
    createdScholarRoles?: boolean | UserCountOutputTypeCountCreatedScholarRolesArgs;
    progress?: boolean | UserCountOutputTypeCountProgressArgs;
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGlobalRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserGlobalRoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScholarRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserScholarRoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedScholarRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserScholarRoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserLectureProgressWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FavoriteLectureWhereInput;
  };

  /**
   * Count Type ScholarCountOutputType
   */

  export type ScholarCountOutputType = {
    collections: number;
    series: number;
    lectures: number;
    userRoles: number;
  };

  export type ScholarCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    collections?: boolean | ScholarCountOutputTypeCountCollectionsArgs;
    series?: boolean | ScholarCountOutputTypeCountSeriesArgs;
    lectures?: boolean | ScholarCountOutputTypeCountLecturesArgs;
    userRoles?: boolean | ScholarCountOutputTypeCountUserRolesArgs;
  };

  // Custom InputTypes
  /**
   * ScholarCountOutputType without action
   */
  export type ScholarCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ScholarCountOutputType
     */
    select?: ScholarCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ScholarCountOutputType without action
   */
  export type ScholarCountOutputTypeCountCollectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CollectionWhereInput;
  };

  /**
   * ScholarCountOutputType without action
   */
  export type ScholarCountOutputTypeCountSeriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesWhereInput;
  };

  /**
   * ScholarCountOutputType without action
   */
  export type ScholarCountOutputTypeCountLecturesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureWhereInput;
  };

  /**
   * ScholarCountOutputType without action
   */
  export type ScholarCountOutputTypeCountUserRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserScholarRoleWhereInput;
  };

  /**
   * Count Type CollectionCountOutputType
   */

  export type CollectionCountOutputType = {
    series: number;
    topics: number;
  };

  export type CollectionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    series?: boolean | CollectionCountOutputTypeCountSeriesArgs;
    topics?: boolean | CollectionCountOutputTypeCountTopicsArgs;
  };

  // Custom InputTypes
  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountSeriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesWhereInput;
  };

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CollectionTopicWhereInput;
  };

  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    lectures: number;
    topics: number;
  };

  export type SeriesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    lectures?: boolean | SeriesCountOutputTypeCountLecturesArgs;
    topics?: boolean | SeriesCountOutputTypeCountTopicsArgs;
  };

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountLecturesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureWhereInput;
  };

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesTopicWhereInput;
  };

  /**
   * Count Type LectureCountOutputType
   */

  export type LectureCountOutputType = {
    audioAssets: number;
    topics: number;
    progress: number;
    favorites: number;
  };

  export type LectureCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audioAssets?: boolean | LectureCountOutputTypeCountAudioAssetsArgs;
    topics?: boolean | LectureCountOutputTypeCountTopicsArgs;
    progress?: boolean | LectureCountOutputTypeCountProgressArgs;
    favorites?: boolean | LectureCountOutputTypeCountFavoritesArgs;
  };

  // Custom InputTypes
  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureCountOutputType
     */
    select?: LectureCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountAudioAssetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AudioAssetWhereInput;
  };

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureTopicWhereInput;
  };

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountProgressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserLectureProgressWhereInput;
  };

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountFavoritesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FavoriteLectureWhereInput;
  };

  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    children: number;
    lectureTopics: number;
    seriesTopics: number;
    collectionTopics: number;
  };

  export type TopicCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    children?: boolean | TopicCountOutputTypeCountChildrenArgs;
    lectureTopics?: boolean | TopicCountOutputTypeCountLectureTopicsArgs;
    seriesTopics?: boolean | TopicCountOutputTypeCountSeriesTopicsArgs;
    collectionTopics?: boolean | TopicCountOutputTypeCountCollectionTopicsArgs;
  };

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountChildrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TopicWhereInput;
  };

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountLectureTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureTopicWhereInput;
  };

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountSeriesTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesTopicWhereInput;
  };

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountCollectionTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CollectionTopicWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model IngestionBatch
   */

  export type AggregateIngestionBatch = {
    _count: IngestionBatchCountAggregateOutputType | null;
    _min: IngestionBatchMinAggregateOutputType | null;
    _max: IngestionBatchMaxAggregateOutputType | null;
  };

  export type IngestionBatchMinAggregateOutputType = {
    id: string | null;
    tag: string | null;
    environment: string | null;
    createdAt: Date | null;
  };

  export type IngestionBatchMaxAggregateOutputType = {
    id: string | null;
    tag: string | null;
    environment: string | null;
    createdAt: Date | null;
  };

  export type IngestionBatchCountAggregateOutputType = {
    id: number;
    tag: number;
    environment: number;
    createdAt: number;
    _all: number;
  };

  export type IngestionBatchMinAggregateInputType = {
    id?: true;
    tag?: true;
    environment?: true;
    createdAt?: true;
  };

  export type IngestionBatchMaxAggregateInputType = {
    id?: true;
    tag?: true;
    environment?: true;
    createdAt?: true;
  };

  export type IngestionBatchCountAggregateInputType = {
    id?: true;
    tag?: true;
    environment?: true;
    createdAt?: true;
    _all?: true;
  };

  export type IngestionBatchAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IngestionBatch to aggregate.
     */
    where?: IngestionBatchWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestionBatches to fetch.
     */
    orderBy?: IngestionBatchOrderByWithRelationInput | IngestionBatchOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IngestionBatchWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestionBatches from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestionBatches.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IngestionBatches
     **/
    _count?: true | IngestionBatchCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IngestionBatchMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IngestionBatchMaxAggregateInputType;
  };

  export type GetIngestionBatchAggregateType<T extends IngestionBatchAggregateArgs> = {
    [P in keyof T & keyof AggregateIngestionBatch]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestionBatch[P]>
      : GetScalarType<T[P], AggregateIngestionBatch[P]>;
  };

  export type IngestionBatchGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IngestionBatchWhereInput;
    orderBy?:
      | IngestionBatchOrderByWithAggregationInput
      | IngestionBatchOrderByWithAggregationInput[];
    by: IngestionBatchScalarFieldEnum[] | IngestionBatchScalarFieldEnum;
    having?: IngestionBatchScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IngestionBatchCountAggregateInputType | true;
    _min?: IngestionBatchMinAggregateInputType;
    _max?: IngestionBatchMaxAggregateInputType;
  };

  export type IngestionBatchGroupByOutputType = {
    id: string;
    tag: string;
    environment: string;
    createdAt: Date;
    _count: IngestionBatchCountAggregateOutputType | null;
    _min: IngestionBatchMinAggregateOutputType | null;
    _max: IngestionBatchMaxAggregateOutputType | null;
  };

  type GetIngestionBatchGroupByPayload<T extends IngestionBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngestionBatchGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof IngestionBatchGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], IngestionBatchGroupByOutputType[P]>
          : GetScalarType<T[P], IngestionBatchGroupByOutputType[P]>;
      }
    >
  >;

  export type IngestionBatchSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tag?: boolean;
      environment?: boolean;
      createdAt?: boolean;
      scholars?: boolean | IngestionBatch$scholarsArgs<ExtArgs>;
      collections?: boolean | IngestionBatch$collectionsArgs<ExtArgs>;
      series?: boolean | IngestionBatch$seriesArgs<ExtArgs>;
      lectures?: boolean | IngestionBatch$lecturesArgs<ExtArgs>;
      audioAssets?: boolean | IngestionBatch$audioAssetsArgs<ExtArgs>;
      _count?: boolean | IngestionBatchCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["ingestionBatch"]
  >;

  export type IngestionBatchSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tag?: boolean;
      environment?: boolean;
      createdAt?: boolean;
    },
    ExtArgs["result"]["ingestionBatch"]
  >;

  export type IngestionBatchSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tag?: boolean;
      environment?: boolean;
      createdAt?: boolean;
    },
    ExtArgs["result"]["ingestionBatch"]
  >;

  export type IngestionBatchSelectScalar = {
    id?: boolean;
    tag?: boolean;
    environment?: boolean;
    createdAt?: boolean;
  };

  export type IngestionBatchOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "tag" | "environment" | "createdAt",
    ExtArgs["result"]["ingestionBatch"]
  >;
  export type IngestionBatchInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    scholars?: boolean | IngestionBatch$scholarsArgs<ExtArgs>;
    collections?: boolean | IngestionBatch$collectionsArgs<ExtArgs>;
    series?: boolean | IngestionBatch$seriesArgs<ExtArgs>;
    lectures?: boolean | IngestionBatch$lecturesArgs<ExtArgs>;
    audioAssets?: boolean | IngestionBatch$audioAssetsArgs<ExtArgs>;
    _count?: boolean | IngestionBatchCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type IngestionBatchIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type IngestionBatchIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $IngestionBatchPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IngestionBatch";
    objects: {
      scholars: Prisma.$ScholarPayload<ExtArgs>[];
      collections: Prisma.$CollectionPayload<ExtArgs>[];
      series: Prisma.$SeriesPayload<ExtArgs>[];
      lectures: Prisma.$LecturePayload<ExtArgs>[];
      audioAssets: Prisma.$AudioAssetPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        tag: string;
        environment: string;
        createdAt: Date;
      },
      ExtArgs["result"]["ingestionBatch"]
    >;
    composites: {};
  };

  type IngestionBatchGetPayload<S extends boolean | null | undefined | IngestionBatchDefaultArgs> =
    $Result.GetResult<Prisma.$IngestionBatchPayload, S>;

  type IngestionBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IngestionBatchFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: IngestionBatchCountAggregateInputType | true;
    };

  export interface IngestionBatchDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IngestionBatch"];
      meta: { name: "IngestionBatch" };
    };
    /**
     * Find zero or one IngestionBatch that matches the filter.
     * @param {IngestionBatchFindUniqueArgs} args - Arguments to find a IngestionBatch
     * @example
     * // Get one IngestionBatch
     * const ingestionBatch = await prisma.ingestionBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestionBatchFindUniqueArgs>(
      args: SelectSubset<T, IngestionBatchFindUniqueArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IngestionBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngestionBatchFindUniqueOrThrowArgs} args - Arguments to find a IngestionBatch
     * @example
     * // Get one IngestionBatch
     * const ingestionBatch = await prisma.ingestionBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestionBatchFindUniqueOrThrowArgs>(
      args: SelectSubset<T, IngestionBatchFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IngestionBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchFindFirstArgs} args - Arguments to find a IngestionBatch
     * @example
     * // Get one IngestionBatch
     * const ingestionBatch = await prisma.ingestionBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestionBatchFindFirstArgs>(
      args?: SelectSubset<T, IngestionBatchFindFirstArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IngestionBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchFindFirstOrThrowArgs} args - Arguments to find a IngestionBatch
     * @example
     * // Get one IngestionBatch
     * const ingestionBatch = await prisma.ingestionBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestionBatchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IngestionBatchFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IngestionBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestionBatches
     * const ingestionBatches = await prisma.ingestionBatch.findMany()
     *
     * // Get first 10 IngestionBatches
     * const ingestionBatches = await prisma.ingestionBatch.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const ingestionBatchWithIdOnly = await prisma.ingestionBatch.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IngestionBatchFindManyArgs>(
      args?: SelectSubset<T, IngestionBatchFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$IngestionBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a IngestionBatch.
     * @param {IngestionBatchCreateArgs} args - Arguments to create a IngestionBatch.
     * @example
     * // Create one IngestionBatch
     * const IngestionBatch = await prisma.ingestionBatch.create({
     *   data: {
     *     // ... data to create a IngestionBatch
     *   }
     * })
     *
     */
    create<T extends IngestionBatchCreateArgs>(
      args: SelectSubset<T, IngestionBatchCreateArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<Prisma.$IngestionBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IngestionBatches.
     * @param {IngestionBatchCreateManyArgs} args - Arguments to create many IngestionBatches.
     * @example
     * // Create many IngestionBatches
     * const ingestionBatch = await prisma.ingestionBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IngestionBatchCreateManyArgs>(
      args?: SelectSubset<T, IngestionBatchCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IngestionBatches and returns the data saved in the database.
     * @param {IngestionBatchCreateManyAndReturnArgs} args - Arguments to create many IngestionBatches.
     * @example
     * // Create many IngestionBatches
     * const ingestionBatch = await prisma.ingestionBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IngestionBatches and only return the `id`
     * const ingestionBatchWithIdOnly = await prisma.ingestionBatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends IngestionBatchCreateManyAndReturnArgs>(
      args?: SelectSubset<T, IngestionBatchCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IngestionBatch.
     * @param {IngestionBatchDeleteArgs} args - Arguments to delete one IngestionBatch.
     * @example
     * // Delete one IngestionBatch
     * const IngestionBatch = await prisma.ingestionBatch.delete({
     *   where: {
     *     // ... filter to delete one IngestionBatch
     *   }
     * })
     *
     */
    delete<T extends IngestionBatchDeleteArgs>(
      args: SelectSubset<T, IngestionBatchDeleteArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<Prisma.$IngestionBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IngestionBatch.
     * @param {IngestionBatchUpdateArgs} args - Arguments to update one IngestionBatch.
     * @example
     * // Update one IngestionBatch
     * const ingestionBatch = await prisma.ingestionBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IngestionBatchUpdateArgs>(
      args: SelectSubset<T, IngestionBatchUpdateArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<Prisma.$IngestionBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IngestionBatches.
     * @param {IngestionBatchDeleteManyArgs} args - Arguments to filter IngestionBatches to delete.
     * @example
     * // Delete a few IngestionBatches
     * const { count } = await prisma.ingestionBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IngestionBatchDeleteManyArgs>(
      args?: SelectSubset<T, IngestionBatchDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IngestionBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestionBatches
     * const ingestionBatch = await prisma.ingestionBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IngestionBatchUpdateManyArgs>(
      args: SelectSubset<T, IngestionBatchUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IngestionBatches and returns the data updated in the database.
     * @param {IngestionBatchUpdateManyAndReturnArgs} args - Arguments to update many IngestionBatches.
     * @example
     * // Update many IngestionBatches
     * const ingestionBatch = await prisma.ingestionBatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IngestionBatches and only return the `id`
     * const ingestionBatchWithIdOnly = await prisma.ingestionBatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends IngestionBatchUpdateManyAndReturnArgs>(
      args: SelectSubset<T, IngestionBatchUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IngestionBatch.
     * @param {IngestionBatchUpsertArgs} args - Arguments to update or create a IngestionBatch.
     * @example
     * // Update or create a IngestionBatch
     * const ingestionBatch = await prisma.ingestionBatch.upsert({
     *   create: {
     *     // ... data to create a IngestionBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestionBatch we want to update
     *   }
     * })
     */
    upsert<T extends IngestionBatchUpsertArgs>(
      args: SelectSubset<T, IngestionBatchUpsertArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<Prisma.$IngestionBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IngestionBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchCountArgs} args - Arguments to filter IngestionBatches to count.
     * @example
     * // Count the number of IngestionBatches
     * const count = await prisma.ingestionBatch.count({
     *   where: {
     *     // ... the filter for the IngestionBatches we want to count
     *   }
     * })
     **/
    count<T extends IngestionBatchCountArgs>(
      args?: Subset<T, IngestionBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], IngestionBatchCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IngestionBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IngestionBatchAggregateArgs>(
      args: Subset<T, IngestionBatchAggregateArgs>,
    ): Prisma.PrismaPromise<GetIngestionBatchAggregateType<T>>;

    /**
     * Group by IngestionBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IngestionBatchGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestionBatchGroupByArgs["orderBy"] }
        : { orderBy?: IngestionBatchGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, IngestionBatchGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetIngestionBatchGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IngestionBatch model
     */
    readonly fields: IngestionBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestionBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestionBatchClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    scholars<T extends IngestionBatch$scholarsArgs<ExtArgs> = {}>(
      args?: Subset<T, IngestionBatch$scholarsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    collections<T extends IngestionBatch$collectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, IngestionBatch$collectionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    series<T extends IngestionBatch$seriesArgs<ExtArgs> = {}>(
      args?: Subset<T, IngestionBatch$seriesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    lectures<T extends IngestionBatch$lecturesArgs<ExtArgs> = {}>(
      args?: Subset<T, IngestionBatch$lecturesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    audioAssets<T extends IngestionBatch$audioAssetsArgs<ExtArgs> = {}>(
      args?: Subset<T, IngestionBatch$audioAssetsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IngestionBatch model
   */
  interface IngestionBatchFieldRefs {
    readonly id: FieldRef<"IngestionBatch", "String">;
    readonly tag: FieldRef<"IngestionBatch", "String">;
    readonly environment: FieldRef<"IngestionBatch", "String">;
    readonly createdAt: FieldRef<"IngestionBatch", "DateTime">;
  }

  // Custom InputTypes
  /**
   * IngestionBatch findUnique
   */
  export type IngestionBatchFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * Filter, which IngestionBatch to fetch.
     */
    where: IngestionBatchWhereUniqueInput;
  };

  /**
   * IngestionBatch findUniqueOrThrow
   */
  export type IngestionBatchFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * Filter, which IngestionBatch to fetch.
     */
    where: IngestionBatchWhereUniqueInput;
  };

  /**
   * IngestionBatch findFirst
   */
  export type IngestionBatchFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * Filter, which IngestionBatch to fetch.
     */
    where?: IngestionBatchWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestionBatches to fetch.
     */
    orderBy?: IngestionBatchOrderByWithRelationInput | IngestionBatchOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IngestionBatches.
     */
    cursor?: IngestionBatchWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestionBatches from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestionBatches.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IngestionBatches.
     */
    distinct?: IngestionBatchScalarFieldEnum | IngestionBatchScalarFieldEnum[];
  };

  /**
   * IngestionBatch findFirstOrThrow
   */
  export type IngestionBatchFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * Filter, which IngestionBatch to fetch.
     */
    where?: IngestionBatchWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestionBatches to fetch.
     */
    orderBy?: IngestionBatchOrderByWithRelationInput | IngestionBatchOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IngestionBatches.
     */
    cursor?: IngestionBatchWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestionBatches from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestionBatches.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IngestionBatches.
     */
    distinct?: IngestionBatchScalarFieldEnum | IngestionBatchScalarFieldEnum[];
  };

  /**
   * IngestionBatch findMany
   */
  export type IngestionBatchFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * Filter, which IngestionBatches to fetch.
     */
    where?: IngestionBatchWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestionBatches to fetch.
     */
    orderBy?: IngestionBatchOrderByWithRelationInput | IngestionBatchOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IngestionBatches.
     */
    cursor?: IngestionBatchWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestionBatches from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestionBatches.
     */
    skip?: number;
    distinct?: IngestionBatchScalarFieldEnum | IngestionBatchScalarFieldEnum[];
  };

  /**
   * IngestionBatch create
   */
  export type IngestionBatchCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * The data needed to create a IngestionBatch.
     */
    data: XOR<IngestionBatchCreateInput, IngestionBatchUncheckedCreateInput>;
  };

  /**
   * IngestionBatch createMany
   */
  export type IngestionBatchCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IngestionBatches.
     */
    data: IngestionBatchCreateManyInput | IngestionBatchCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IngestionBatch createManyAndReturn
   */
  export type IngestionBatchCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * The data used to create many IngestionBatches.
     */
    data: IngestionBatchCreateManyInput | IngestionBatchCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IngestionBatch update
   */
  export type IngestionBatchUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * The data needed to update a IngestionBatch.
     */
    data: XOR<IngestionBatchUpdateInput, IngestionBatchUncheckedUpdateInput>;
    /**
     * Choose, which IngestionBatch to update.
     */
    where: IngestionBatchWhereUniqueInput;
  };

  /**
   * IngestionBatch updateMany
   */
  export type IngestionBatchUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IngestionBatches.
     */
    data: XOR<IngestionBatchUpdateManyMutationInput, IngestionBatchUncheckedUpdateManyInput>;
    /**
     * Filter which IngestionBatches to update
     */
    where?: IngestionBatchWhereInput;
    /**
     * Limit how many IngestionBatches to update.
     */
    limit?: number;
  };

  /**
   * IngestionBatch updateManyAndReturn
   */
  export type IngestionBatchUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * The data used to update IngestionBatches.
     */
    data: XOR<IngestionBatchUpdateManyMutationInput, IngestionBatchUncheckedUpdateManyInput>;
    /**
     * Filter which IngestionBatches to update
     */
    where?: IngestionBatchWhereInput;
    /**
     * Limit how many IngestionBatches to update.
     */
    limit?: number;
  };

  /**
   * IngestionBatch upsert
   */
  export type IngestionBatchUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * The filter to search for the IngestionBatch to update in case it exists.
     */
    where: IngestionBatchWhereUniqueInput;
    /**
     * In case the IngestionBatch found by the `where` argument doesn't exist, create a new IngestionBatch with this data.
     */
    create: XOR<IngestionBatchCreateInput, IngestionBatchUncheckedCreateInput>;
    /**
     * In case the IngestionBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestionBatchUpdateInput, IngestionBatchUncheckedUpdateInput>;
  };

  /**
   * IngestionBatch delete
   */
  export type IngestionBatchDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    /**
     * Filter which IngestionBatch to delete.
     */
    where: IngestionBatchWhereUniqueInput;
  };

  /**
   * IngestionBatch deleteMany
   */
  export type IngestionBatchDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IngestionBatches to delete
     */
    where?: IngestionBatchWhereInput;
    /**
     * Limit how many IngestionBatches to delete.
     */
    limit?: number;
  };

  /**
   * IngestionBatch.scholars
   */
  export type IngestionBatch$scholarsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    where?: ScholarWhereInput;
    orderBy?: ScholarOrderByWithRelationInput | ScholarOrderByWithRelationInput[];
    cursor?: ScholarWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScholarScalarFieldEnum | ScholarScalarFieldEnum[];
  };

  /**
   * IngestionBatch.collections
   */
  export type IngestionBatch$collectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[];
    cursor?: CollectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[];
  };

  /**
   * IngestionBatch.series
   */
  export type IngestionBatch$seriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    cursor?: SeriesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[];
  };

  /**
   * IngestionBatch.lectures
   */
  export type IngestionBatch$lecturesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    where?: LectureWhereInput;
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    cursor?: LectureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * IngestionBatch.audioAssets
   */
  export type IngestionBatch$audioAssetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    where?: AudioAssetWhereInput;
    orderBy?: AudioAssetOrderByWithRelationInput | AudioAssetOrderByWithRelationInput[];
    cursor?: AudioAssetWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AudioAssetScalarFieldEnum | AudioAssetScalarFieldEnum[];
  };

  /**
   * IngestionBatch without action
   */
  export type IngestionBatchDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    emailNormalized: string | null;
    emailVerifiedAt: Date | null;
    name: string | null;
    preferredLanguage: string | null;
    passwordHash: string | null;
    passwordUpdatedAt: Date | null;
    lastLoginAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deactivatedAt: Date | null;
    erasureRequestedAt: Date | null;
    erasedAt: Date | null;
    isBanned: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    emailNormalized: string | null;
    emailVerifiedAt: Date | null;
    name: string | null;
    preferredLanguage: string | null;
    passwordHash: string | null;
    passwordUpdatedAt: Date | null;
    lastLoginAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deactivatedAt: Date | null;
    erasureRequestedAt: Date | null;
    erasedAt: Date | null;
    isBanned: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    emailNormalized: number;
    emailVerifiedAt: number;
    name: number;
    preferredLanguage: number;
    passwordHash: number;
    passwordUpdatedAt: number;
    lastLoginAt: number;
    createdAt: number;
    updatedAt: number;
    deactivatedAt: number;
    erasureRequestedAt: number;
    erasedAt: number;
    isBanned: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    emailNormalized?: true;
    emailVerifiedAt?: true;
    name?: true;
    preferredLanguage?: true;
    passwordHash?: true;
    passwordUpdatedAt?: true;
    lastLoginAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deactivatedAt?: true;
    erasureRequestedAt?: true;
    erasedAt?: true;
    isBanned?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    emailNormalized?: true;
    emailVerifiedAt?: true;
    name?: true;
    preferredLanguage?: true;
    passwordHash?: true;
    passwordUpdatedAt?: true;
    lastLoginAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deactivatedAt?: true;
    erasureRequestedAt?: true;
    erasedAt?: true;
    isBanned?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    emailNormalized?: true;
    emailVerifiedAt?: true;
    name?: true;
    preferredLanguage?: true;
    passwordHash?: true;
    passwordUpdatedAt?: true;
    lastLoginAt?: true;
    createdAt?: true;
    updatedAt?: true;
    deactivatedAt?: true;
    erasureRequestedAt?: true;
    erasedAt?: true;
    isBanned?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    email: string | null;
    emailNormalized: string | null;
    emailVerifiedAt: Date | null;
    name: string | null;
    preferredLanguage: string | null;
    passwordHash: string | null;
    passwordUpdatedAt: Date | null;
    lastLoginAt: Date | null;
    createdAt: Date;
    updatedAt: Date | null;
    deactivatedAt: Date | null;
    erasureRequestedAt: Date | null;
    erasedAt: Date | null;
    isBanned: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        emailNormalized?: boolean;
        emailVerifiedAt?: boolean;
        name?: boolean;
        preferredLanguage?: boolean;
        passwordHash?: boolean;
        passwordUpdatedAt?: boolean;
        lastLoginAt?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deactivatedAt?: boolean;
        erasureRequestedAt?: boolean;
        erasedAt?: boolean;
        isBanned?: boolean;
        globalRoles?: boolean | User$globalRolesArgs<ExtArgs>;
        scholarRoles?: boolean | User$scholarRolesArgs<ExtArgs>;
        createdScholarRoles?: boolean | User$createdScholarRolesArgs<ExtArgs>;
        progress?: boolean | User$progressArgs<ExtArgs>;
        favorites?: boolean | User$favoritesArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["user"]
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      emailNormalized?: boolean;
      emailVerifiedAt?: boolean;
      name?: boolean;
      preferredLanguage?: boolean;
      passwordHash?: boolean;
      passwordUpdatedAt?: boolean;
      lastLoginAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deactivatedAt?: boolean;
      erasureRequestedAt?: boolean;
      erasedAt?: boolean;
      isBanned?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      emailNormalized?: boolean;
      emailVerifiedAt?: boolean;
      name?: boolean;
      preferredLanguage?: boolean;
      passwordHash?: boolean;
      passwordUpdatedAt?: boolean;
      lastLoginAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deactivatedAt?: boolean;
      erasureRequestedAt?: boolean;
      erasedAt?: boolean;
      isBanned?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    emailNormalized?: boolean;
    emailVerifiedAt?: boolean;
    name?: boolean;
    preferredLanguage?: boolean;
    passwordHash?: boolean;
    passwordUpdatedAt?: boolean;
    lastLoginAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deactivatedAt?: boolean;
    erasureRequestedAt?: boolean;
    erasedAt?: boolean;
    isBanned?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "email"
      | "emailNormalized"
      | "emailVerifiedAt"
      | "name"
      | "preferredLanguage"
      | "passwordHash"
      | "passwordUpdatedAt"
      | "lastLoginAt"
      | "createdAt"
      | "updatedAt"
      | "deactivatedAt"
      | "erasureRequestedAt"
      | "erasedAt"
      | "isBanned",
      ExtArgs["result"]["user"]
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    globalRoles?: boolean | User$globalRolesArgs<ExtArgs>;
    scholarRoles?: boolean | User$scholarRolesArgs<ExtArgs>;
    createdScholarRoles?: boolean | User$createdScholarRolesArgs<ExtArgs>;
    progress?: boolean | User$progressArgs<ExtArgs>;
    favorites?: boolean | User$favoritesArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User";
    objects: {
      globalRoles: Prisma.$UserGlobalRolePayload<ExtArgs>[];
      scholarRoles: Prisma.$UserScholarRolePayload<ExtArgs>[];
      createdScholarRoles: Prisma.$UserScholarRolePayload<ExtArgs>[];
      progress: Prisma.$UserLectureProgressPayload<ExtArgs>[];
      favorites: Prisma.$FavoriteLecturePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string | null;
        emailNormalized: string | null;
        emailVerifiedAt: Date | null;
        name: string | null;
        preferredLanguage: string | null;
        passwordHash: string | null;
        passwordUpdatedAt: Date | null;
        lastLoginAt: Date | null;
        createdAt: Date;
        updatedAt: Date | null;
        deactivatedAt: Date | null;
        erasureRequestedAt: Date | null;
        erasedAt: Date | null;
        isBanned: boolean;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["User"]; meta: { name: "User" } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    globalRoles<T extends User$globalRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$globalRolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UserGlobalRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    scholarRoles<T extends User$scholarRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$scholarRolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    createdScholarRoles<T extends User$createdScholarRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdScholarRolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    progress<T extends User$progressArgs<ExtArgs> = {}>(
      args?: Subset<T, User$progressArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserLectureProgressPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$favoritesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly emailNormalized: FieldRef<"User", "String">;
    readonly emailVerifiedAt: FieldRef<"User", "DateTime">;
    readonly name: FieldRef<"User", "String">;
    readonly preferredLanguage: FieldRef<"User", "String">;
    readonly passwordHash: FieldRef<"User", "String">;
    readonly passwordUpdatedAt: FieldRef<"User", "DateTime">;
    readonly lastLoginAt: FieldRef<"User", "DateTime">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
    readonly deactivatedAt: FieldRef<"User", "DateTime">;
    readonly erasureRequestedAt: FieldRef<"User", "DateTime">;
    readonly erasedAt: FieldRef<"User", "DateTime">;
    readonly isBanned: FieldRef<"User", "Boolean">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.globalRoles
   */
  export type User$globalRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    where?: UserGlobalRoleWhereInput;
    orderBy?: UserGlobalRoleOrderByWithRelationInput | UserGlobalRoleOrderByWithRelationInput[];
    cursor?: UserGlobalRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserGlobalRoleScalarFieldEnum | UserGlobalRoleScalarFieldEnum[];
  };

  /**
   * User.scholarRoles
   */
  export type User$scholarRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    where?: UserScholarRoleWhereInput;
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    cursor?: UserScholarRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScholarRoleScalarFieldEnum | UserScholarRoleScalarFieldEnum[];
  };

  /**
   * User.createdScholarRoles
   */
  export type User$createdScholarRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    where?: UserScholarRoleWhereInput;
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    cursor?: UserScholarRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScholarRoleScalarFieldEnum | UserScholarRoleScalarFieldEnum[];
  };

  /**
   * User.progress
   */
  export type User$progressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    where?: UserLectureProgressWhereInput;
    orderBy?:
      | UserLectureProgressOrderByWithRelationInput
      | UserLectureProgressOrderByWithRelationInput[];
    cursor?: UserLectureProgressWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserLectureProgressScalarFieldEnum | UserLectureProgressScalarFieldEnum[];
  };

  /**
   * User.favorites
   */
  export type User$favoritesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    where?: FavoriteLectureWhereInput;
    orderBy?: FavoriteLectureOrderByWithRelationInput | FavoriteLectureOrderByWithRelationInput[];
    cursor?: FavoriteLectureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FavoriteLectureScalarFieldEnum | FavoriteLectureScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model UserGlobalRole
   */

  export type AggregateUserGlobalRole = {
    _count: UserGlobalRoleCountAggregateOutputType | null;
    _min: UserGlobalRoleMinAggregateOutputType | null;
    _max: UserGlobalRoleMaxAggregateOutputType | null;
  };

  export type UserGlobalRoleMinAggregateOutputType = {
    userId: string | null;
    role: $Enums.GlobalRole | null;
    createdAt: Date | null;
  };

  export type UserGlobalRoleMaxAggregateOutputType = {
    userId: string | null;
    role: $Enums.GlobalRole | null;
    createdAt: Date | null;
  };

  export type UserGlobalRoleCountAggregateOutputType = {
    userId: number;
    role: number;
    createdAt: number;
    _all: number;
  };

  export type UserGlobalRoleMinAggregateInputType = {
    userId?: true;
    role?: true;
    createdAt?: true;
  };

  export type UserGlobalRoleMaxAggregateInputType = {
    userId?: true;
    role?: true;
    createdAt?: true;
  };

  export type UserGlobalRoleCountAggregateInputType = {
    userId?: true;
    role?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserGlobalRoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserGlobalRole to aggregate.
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserGlobalRoles to fetch.
     */
    orderBy?: UserGlobalRoleOrderByWithRelationInput | UserGlobalRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserGlobalRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserGlobalRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserGlobalRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserGlobalRoles
     **/
    _count?: true | UserGlobalRoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserGlobalRoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserGlobalRoleMaxAggregateInputType;
  };

  export type GetUserGlobalRoleAggregateType<T extends UserGlobalRoleAggregateArgs> = {
    [P in keyof T & keyof AggregateUserGlobalRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGlobalRole[P]>
      : GetScalarType<T[P], AggregateUserGlobalRole[P]>;
  };

  export type UserGlobalRoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserGlobalRoleWhereInput;
    orderBy?:
      | UserGlobalRoleOrderByWithAggregationInput
      | UserGlobalRoleOrderByWithAggregationInput[];
    by: UserGlobalRoleScalarFieldEnum[] | UserGlobalRoleScalarFieldEnum;
    having?: UserGlobalRoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserGlobalRoleCountAggregateInputType | true;
    _min?: UserGlobalRoleMinAggregateInputType;
    _max?: UserGlobalRoleMaxAggregateInputType;
  };

  export type UserGlobalRoleGroupByOutputType = {
    userId: string;
    role: $Enums.GlobalRole;
    createdAt: Date;
    _count: UserGlobalRoleCountAggregateOutputType | null;
    _min: UserGlobalRoleMinAggregateOutputType | null;
    _max: UserGlobalRoleMaxAggregateOutputType | null;
  };

  type GetUserGlobalRoleGroupByPayload<T extends UserGlobalRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGlobalRoleGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGlobalRoleGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGlobalRoleGroupByOutputType[P]>
          : GetScalarType<T[P], UserGlobalRoleGroupByOutputType[P]>;
      }
    >
  >;

  export type UserGlobalRoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userGlobalRole"]
  >;

  export type UserGlobalRoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userGlobalRole"]
  >;

  export type UserGlobalRoleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userGlobalRole"]
  >;

  export type UserGlobalRoleSelectScalar = {
    userId?: boolean;
    role?: boolean;
    createdAt?: boolean;
  };

  export type UserGlobalRoleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"userId" | "role" | "createdAt", ExtArgs["result"]["userGlobalRole"]>;
  export type UserGlobalRoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type UserGlobalRoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type UserGlobalRoleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $UserGlobalRolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "UserGlobalRole";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        role: $Enums.GlobalRole;
        createdAt: Date;
      },
      ExtArgs["result"]["userGlobalRole"]
    >;
    composites: {};
  };

  type UserGlobalRoleGetPayload<S extends boolean | null | undefined | UserGlobalRoleDefaultArgs> =
    $Result.GetResult<Prisma.$UserGlobalRolePayload, S>;

  type UserGlobalRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGlobalRoleFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: UserGlobalRoleCountAggregateInputType | true;
    };

  export interface UserGlobalRoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["UserGlobalRole"];
      meta: { name: "UserGlobalRole" };
    };
    /**
     * Find zero or one UserGlobalRole that matches the filter.
     * @param {UserGlobalRoleFindUniqueArgs} args - Arguments to find a UserGlobalRole
     * @example
     * // Get one UserGlobalRole
     * const userGlobalRole = await prisma.userGlobalRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGlobalRoleFindUniqueArgs>(
      args: SelectSubset<T, UserGlobalRoleFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<
        Prisma.$UserGlobalRolePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserGlobalRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGlobalRoleFindUniqueOrThrowArgs} args - Arguments to find a UserGlobalRole
     * @example
     * // Get one UserGlobalRole
     * const userGlobalRole = await prisma.userGlobalRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGlobalRoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserGlobalRoleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<
        Prisma.$UserGlobalRolePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserGlobalRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleFindFirstArgs} args - Arguments to find a UserGlobalRole
     * @example
     * // Get one UserGlobalRole
     * const userGlobalRole = await prisma.userGlobalRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGlobalRoleFindFirstArgs>(
      args?: SelectSubset<T, UserGlobalRoleFindFirstArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<
        Prisma.$UserGlobalRolePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserGlobalRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleFindFirstOrThrowArgs} args - Arguments to find a UserGlobalRole
     * @example
     * // Get one UserGlobalRole
     * const userGlobalRole = await prisma.userGlobalRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGlobalRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserGlobalRoleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<
        Prisma.$UserGlobalRolePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserGlobalRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGlobalRoles
     * const userGlobalRoles = await prisma.userGlobalRole.findMany()
     *
     * // Get first 10 UserGlobalRoles
     * const userGlobalRoles = await prisma.userGlobalRole.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const userGlobalRoleWithUserIdOnly = await prisma.userGlobalRole.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends UserGlobalRoleFindManyArgs>(
      args?: SelectSubset<T, UserGlobalRoleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserGlobalRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a UserGlobalRole.
     * @param {UserGlobalRoleCreateArgs} args - Arguments to create a UserGlobalRole.
     * @example
     * // Create one UserGlobalRole
     * const UserGlobalRole = await prisma.userGlobalRole.create({
     *   data: {
     *     // ... data to create a UserGlobalRole
     *   }
     * })
     *
     */
    create<T extends UserGlobalRoleCreateArgs>(
      args: SelectSubset<T, UserGlobalRoleCreateArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<Prisma.$UserGlobalRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserGlobalRoles.
     * @param {UserGlobalRoleCreateManyArgs} args - Arguments to create many UserGlobalRoles.
     * @example
     * // Create many UserGlobalRoles
     * const userGlobalRole = await prisma.userGlobalRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserGlobalRoleCreateManyArgs>(
      args?: SelectSubset<T, UserGlobalRoleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserGlobalRoles and returns the data saved in the database.
     * @param {UserGlobalRoleCreateManyAndReturnArgs} args - Arguments to create many UserGlobalRoles.
     * @example
     * // Create many UserGlobalRoles
     * const userGlobalRole = await prisma.userGlobalRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserGlobalRoles and only return the `userId`
     * const userGlobalRoleWithUserIdOnly = await prisma.userGlobalRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserGlobalRoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserGlobalRoleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserGlobalRolePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserGlobalRole.
     * @param {UserGlobalRoleDeleteArgs} args - Arguments to delete one UserGlobalRole.
     * @example
     * // Delete one UserGlobalRole
     * const UserGlobalRole = await prisma.userGlobalRole.delete({
     *   where: {
     *     // ... filter to delete one UserGlobalRole
     *   }
     * })
     *
     */
    delete<T extends UserGlobalRoleDeleteArgs>(
      args: SelectSubset<T, UserGlobalRoleDeleteArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<Prisma.$UserGlobalRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserGlobalRole.
     * @param {UserGlobalRoleUpdateArgs} args - Arguments to update one UserGlobalRole.
     * @example
     * // Update one UserGlobalRole
     * const userGlobalRole = await prisma.userGlobalRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserGlobalRoleUpdateArgs>(
      args: SelectSubset<T, UserGlobalRoleUpdateArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<Prisma.$UserGlobalRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserGlobalRoles.
     * @param {UserGlobalRoleDeleteManyArgs} args - Arguments to filter UserGlobalRoles to delete.
     * @example
     * // Delete a few UserGlobalRoles
     * const { count } = await prisma.userGlobalRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserGlobalRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserGlobalRoleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserGlobalRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGlobalRoles
     * const userGlobalRole = await prisma.userGlobalRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserGlobalRoleUpdateManyArgs>(
      args: SelectSubset<T, UserGlobalRoleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserGlobalRoles and returns the data updated in the database.
     * @param {UserGlobalRoleUpdateManyAndReturnArgs} args - Arguments to update many UserGlobalRoles.
     * @example
     * // Update many UserGlobalRoles
     * const userGlobalRole = await prisma.userGlobalRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserGlobalRoles and only return the `userId`
     * const userGlobalRoleWithUserIdOnly = await prisma.userGlobalRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserGlobalRoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserGlobalRoleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserGlobalRolePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserGlobalRole.
     * @param {UserGlobalRoleUpsertArgs} args - Arguments to update or create a UserGlobalRole.
     * @example
     * // Update or create a UserGlobalRole
     * const userGlobalRole = await prisma.userGlobalRole.upsert({
     *   create: {
     *     // ... data to create a UserGlobalRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGlobalRole we want to update
     *   }
     * })
     */
    upsert<T extends UserGlobalRoleUpsertArgs>(
      args: SelectSubset<T, UserGlobalRoleUpsertArgs<ExtArgs>>,
    ): Prisma__UserGlobalRoleClient<
      $Result.GetResult<Prisma.$UserGlobalRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserGlobalRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleCountArgs} args - Arguments to filter UserGlobalRoles to count.
     * @example
     * // Count the number of UserGlobalRoles
     * const count = await prisma.userGlobalRole.count({
     *   where: {
     *     // ... the filter for the UserGlobalRoles we want to count
     *   }
     * })
     **/
    count<T extends UserGlobalRoleCountArgs>(
      args?: Subset<T, UserGlobalRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserGlobalRoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserGlobalRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserGlobalRoleAggregateArgs>(
      args: Subset<T, UserGlobalRoleAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserGlobalRoleAggregateType<T>>;

    /**
     * Group by UserGlobalRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGlobalRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGlobalRoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGlobalRoleGroupByArgs["orderBy"] }
        : { orderBy?: UserGlobalRoleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGlobalRoleGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGlobalRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserGlobalRole model
     */
    readonly fields: UserGlobalRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGlobalRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGlobalRoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserGlobalRole model
   */
  interface UserGlobalRoleFieldRefs {
    readonly userId: FieldRef<"UserGlobalRole", "String">;
    readonly role: FieldRef<"UserGlobalRole", "GlobalRole">;
    readonly createdAt: FieldRef<"UserGlobalRole", "DateTime">;
  }

  // Custom InputTypes
  /**
   * UserGlobalRole findUnique
   */
  export type UserGlobalRoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserGlobalRole to fetch.
     */
    where: UserGlobalRoleWhereUniqueInput;
  };

  /**
   * UserGlobalRole findUniqueOrThrow
   */
  export type UserGlobalRoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserGlobalRole to fetch.
     */
    where: UserGlobalRoleWhereUniqueInput;
  };

  /**
   * UserGlobalRole findFirst
   */
  export type UserGlobalRoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserGlobalRole to fetch.
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserGlobalRoles to fetch.
     */
    orderBy?: UserGlobalRoleOrderByWithRelationInput | UserGlobalRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserGlobalRoles.
     */
    cursor?: UserGlobalRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserGlobalRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserGlobalRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserGlobalRoles.
     */
    distinct?: UserGlobalRoleScalarFieldEnum | UserGlobalRoleScalarFieldEnum[];
  };

  /**
   * UserGlobalRole findFirstOrThrow
   */
  export type UserGlobalRoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserGlobalRole to fetch.
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserGlobalRoles to fetch.
     */
    orderBy?: UserGlobalRoleOrderByWithRelationInput | UserGlobalRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserGlobalRoles.
     */
    cursor?: UserGlobalRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserGlobalRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserGlobalRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserGlobalRoles.
     */
    distinct?: UserGlobalRoleScalarFieldEnum | UserGlobalRoleScalarFieldEnum[];
  };

  /**
   * UserGlobalRole findMany
   */
  export type UserGlobalRoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserGlobalRoles to fetch.
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserGlobalRoles to fetch.
     */
    orderBy?: UserGlobalRoleOrderByWithRelationInput | UserGlobalRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserGlobalRoles.
     */
    cursor?: UserGlobalRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserGlobalRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserGlobalRoles.
     */
    skip?: number;
    distinct?: UserGlobalRoleScalarFieldEnum | UserGlobalRoleScalarFieldEnum[];
  };

  /**
   * UserGlobalRole create
   */
  export type UserGlobalRoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserGlobalRole.
     */
    data: XOR<UserGlobalRoleCreateInput, UserGlobalRoleUncheckedCreateInput>;
  };

  /**
   * UserGlobalRole createMany
   */
  export type UserGlobalRoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserGlobalRoles.
     */
    data: UserGlobalRoleCreateManyInput | UserGlobalRoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserGlobalRole createManyAndReturn
   */
  export type UserGlobalRoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * The data used to create many UserGlobalRoles.
     */
    data: UserGlobalRoleCreateManyInput | UserGlobalRoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserGlobalRole update
   */
  export type UserGlobalRoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserGlobalRole.
     */
    data: XOR<UserGlobalRoleUpdateInput, UserGlobalRoleUncheckedUpdateInput>;
    /**
     * Choose, which UserGlobalRole to update.
     */
    where: UserGlobalRoleWhereUniqueInput;
  };

  /**
   * UserGlobalRole updateMany
   */
  export type UserGlobalRoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserGlobalRoles.
     */
    data: XOR<UserGlobalRoleUpdateManyMutationInput, UserGlobalRoleUncheckedUpdateManyInput>;
    /**
     * Filter which UserGlobalRoles to update
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * Limit how many UserGlobalRoles to update.
     */
    limit?: number;
  };

  /**
   * UserGlobalRole updateManyAndReturn
   */
  export type UserGlobalRoleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * The data used to update UserGlobalRoles.
     */
    data: XOR<UserGlobalRoleUpdateManyMutationInput, UserGlobalRoleUncheckedUpdateManyInput>;
    /**
     * Filter which UserGlobalRoles to update
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * Limit how many UserGlobalRoles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserGlobalRole upsert
   */
  export type UserGlobalRoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserGlobalRole to update in case it exists.
     */
    where: UserGlobalRoleWhereUniqueInput;
    /**
     * In case the UserGlobalRole found by the `where` argument doesn't exist, create a new UserGlobalRole with this data.
     */
    create: XOR<UserGlobalRoleCreateInput, UserGlobalRoleUncheckedCreateInput>;
    /**
     * In case the UserGlobalRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGlobalRoleUpdateInput, UserGlobalRoleUncheckedUpdateInput>;
  };

  /**
   * UserGlobalRole delete
   */
  export type UserGlobalRoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
    /**
     * Filter which UserGlobalRole to delete.
     */
    where: UserGlobalRoleWhereUniqueInput;
  };

  /**
   * UserGlobalRole deleteMany
   */
  export type UserGlobalRoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserGlobalRoles to delete
     */
    where?: UserGlobalRoleWhereInput;
    /**
     * Limit how many UserGlobalRoles to delete.
     */
    limit?: number;
  };

  /**
   * UserGlobalRole without action
   */
  export type UserGlobalRoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserGlobalRole
     */
    select?: UserGlobalRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserGlobalRole
     */
    omit?: UserGlobalRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGlobalRoleInclude<ExtArgs> | null;
  };

  /**
   * Model UserScholarRole
   */

  export type AggregateUserScholarRole = {
    _count: UserScholarRoleCountAggregateOutputType | null;
    _min: UserScholarRoleMinAggregateOutputType | null;
    _max: UserScholarRoleMaxAggregateOutputType | null;
  };

  export type UserScholarRoleMinAggregateOutputType = {
    userId: string | null;
    scholarId: string | null;
    role: $Enums.ScholarRole | null;
    createdAt: Date | null;
    createdByUserId: string | null;
  };

  export type UserScholarRoleMaxAggregateOutputType = {
    userId: string | null;
    scholarId: string | null;
    role: $Enums.ScholarRole | null;
    createdAt: Date | null;
    createdByUserId: string | null;
  };

  export type UserScholarRoleCountAggregateOutputType = {
    userId: number;
    scholarId: number;
    role: number;
    createdAt: number;
    createdByUserId: number;
    _all: number;
  };

  export type UserScholarRoleMinAggregateInputType = {
    userId?: true;
    scholarId?: true;
    role?: true;
    createdAt?: true;
    createdByUserId?: true;
  };

  export type UserScholarRoleMaxAggregateInputType = {
    userId?: true;
    scholarId?: true;
    role?: true;
    createdAt?: true;
    createdByUserId?: true;
  };

  export type UserScholarRoleCountAggregateInputType = {
    userId?: true;
    scholarId?: true;
    role?: true;
    createdAt?: true;
    createdByUserId?: true;
    _all?: true;
  };

  export type UserScholarRoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserScholarRole to aggregate.
     */
    where?: UserScholarRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserScholarRoles to fetch.
     */
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserScholarRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserScholarRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserScholarRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserScholarRoles
     **/
    _count?: true | UserScholarRoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserScholarRoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserScholarRoleMaxAggregateInputType;
  };

  export type GetUserScholarRoleAggregateType<T extends UserScholarRoleAggregateArgs> = {
    [P in keyof T & keyof AggregateUserScholarRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserScholarRole[P]>
      : GetScalarType<T[P], AggregateUserScholarRole[P]>;
  };

  export type UserScholarRoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserScholarRoleWhereInput;
    orderBy?:
      | UserScholarRoleOrderByWithAggregationInput
      | UserScholarRoleOrderByWithAggregationInput[];
    by: UserScholarRoleScalarFieldEnum[] | UserScholarRoleScalarFieldEnum;
    having?: UserScholarRoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserScholarRoleCountAggregateInputType | true;
    _min?: UserScholarRoleMinAggregateInputType;
    _max?: UserScholarRoleMaxAggregateInputType;
  };

  export type UserScholarRoleGroupByOutputType = {
    userId: string;
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt: Date;
    createdByUserId: string | null;
    _count: UserScholarRoleCountAggregateOutputType | null;
    _min: UserScholarRoleMinAggregateOutputType | null;
    _max: UserScholarRoleMaxAggregateOutputType | null;
  };

  type GetUserScholarRoleGroupByPayload<T extends UserScholarRoleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserScholarRoleGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof UserScholarRoleGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserScholarRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserScholarRoleGroupByOutputType[P]>;
        }
      >
    >;

  export type UserScholarRoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      scholarId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      createdByUserId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      createdByUser?: boolean | UserScholarRole$createdByUserArgs<ExtArgs>;
    },
    ExtArgs["result"]["userScholarRole"]
  >;

  export type UserScholarRoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      scholarId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      createdByUserId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      createdByUser?: boolean | UserScholarRole$createdByUserArgs<ExtArgs>;
    },
    ExtArgs["result"]["userScholarRole"]
  >;

  export type UserScholarRoleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      scholarId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      createdByUserId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      createdByUser?: boolean | UserScholarRole$createdByUserArgs<ExtArgs>;
    },
    ExtArgs["result"]["userScholarRole"]
  >;

  export type UserScholarRoleSelectScalar = {
    userId?: boolean;
    scholarId?: boolean;
    role?: boolean;
    createdAt?: boolean;
    createdByUserId?: boolean;
  };

  export type UserScholarRoleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "userId" | "scholarId" | "role" | "createdAt" | "createdByUserId",
    ExtArgs["result"]["userScholarRole"]
  >;
  export type UserScholarRoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    createdByUser?: boolean | UserScholarRole$createdByUserArgs<ExtArgs>;
  };
  export type UserScholarRoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    createdByUser?: boolean | UserScholarRole$createdByUserArgs<ExtArgs>;
  };
  export type UserScholarRoleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    createdByUser?: boolean | UserScholarRole$createdByUserArgs<ExtArgs>;
  };

  export type $UserScholarRolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "UserScholarRole";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      scholar: Prisma.$ScholarPayload<ExtArgs>;
      createdByUser: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        scholarId: string;
        role: $Enums.ScholarRole;
        createdAt: Date;
        createdByUserId: string | null;
      },
      ExtArgs["result"]["userScholarRole"]
    >;
    composites: {};
  };

  type UserScholarRoleGetPayload<
    S extends boolean | null | undefined | UserScholarRoleDefaultArgs,
  > = $Result.GetResult<Prisma.$UserScholarRolePayload, S>;

  type UserScholarRoleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserScholarRoleFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserScholarRoleCountAggregateInputType | true;
  };

  export interface UserScholarRoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["UserScholarRole"];
      meta: { name: "UserScholarRole" };
    };
    /**
     * Find zero or one UserScholarRole that matches the filter.
     * @param {UserScholarRoleFindUniqueArgs} args - Arguments to find a UserScholarRole
     * @example
     * // Get one UserScholarRole
     * const userScholarRole = await prisma.userScholarRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserScholarRoleFindUniqueArgs>(
      args: SelectSubset<T, UserScholarRoleFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<
        Prisma.$UserScholarRolePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserScholarRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserScholarRoleFindUniqueOrThrowArgs} args - Arguments to find a UserScholarRole
     * @example
     * // Get one UserScholarRole
     * const userScholarRole = await prisma.userScholarRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserScholarRoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserScholarRoleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<
        Prisma.$UserScholarRolePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserScholarRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleFindFirstArgs} args - Arguments to find a UserScholarRole
     * @example
     * // Get one UserScholarRole
     * const userScholarRole = await prisma.userScholarRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserScholarRoleFindFirstArgs>(
      args?: SelectSubset<T, UserScholarRoleFindFirstArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<
        Prisma.$UserScholarRolePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserScholarRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleFindFirstOrThrowArgs} args - Arguments to find a UserScholarRole
     * @example
     * // Get one UserScholarRole
     * const userScholarRole = await prisma.userScholarRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserScholarRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserScholarRoleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<
        Prisma.$UserScholarRolePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserScholarRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserScholarRoles
     * const userScholarRoles = await prisma.userScholarRole.findMany()
     *
     * // Get first 10 UserScholarRoles
     * const userScholarRoles = await prisma.userScholarRole.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const userScholarRoleWithUserIdOnly = await prisma.userScholarRole.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends UserScholarRoleFindManyArgs>(
      args?: SelectSubset<T, UserScholarRoleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a UserScholarRole.
     * @param {UserScholarRoleCreateArgs} args - Arguments to create a UserScholarRole.
     * @example
     * // Create one UserScholarRole
     * const UserScholarRole = await prisma.userScholarRole.create({
     *   data: {
     *     // ... data to create a UserScholarRole
     *   }
     * })
     *
     */
    create<T extends UserScholarRoleCreateArgs>(
      args: SelectSubset<T, UserScholarRoleCreateArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserScholarRoles.
     * @param {UserScholarRoleCreateManyArgs} args - Arguments to create many UserScholarRoles.
     * @example
     * // Create many UserScholarRoles
     * const userScholarRole = await prisma.userScholarRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserScholarRoleCreateManyArgs>(
      args?: SelectSubset<T, UserScholarRoleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserScholarRoles and returns the data saved in the database.
     * @param {UserScholarRoleCreateManyAndReturnArgs} args - Arguments to create many UserScholarRoles.
     * @example
     * // Create many UserScholarRoles
     * const userScholarRole = await prisma.userScholarRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserScholarRoles and only return the `userId`
     * const userScholarRoleWithUserIdOnly = await prisma.userScholarRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserScholarRoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserScholarRoleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserScholarRolePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserScholarRole.
     * @param {UserScholarRoleDeleteArgs} args - Arguments to delete one UserScholarRole.
     * @example
     * // Delete one UserScholarRole
     * const UserScholarRole = await prisma.userScholarRole.delete({
     *   where: {
     *     // ... filter to delete one UserScholarRole
     *   }
     * })
     *
     */
    delete<T extends UserScholarRoleDeleteArgs>(
      args: SelectSubset<T, UserScholarRoleDeleteArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserScholarRole.
     * @param {UserScholarRoleUpdateArgs} args - Arguments to update one UserScholarRole.
     * @example
     * // Update one UserScholarRole
     * const userScholarRole = await prisma.userScholarRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserScholarRoleUpdateArgs>(
      args: SelectSubset<T, UserScholarRoleUpdateArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserScholarRoles.
     * @param {UserScholarRoleDeleteManyArgs} args - Arguments to filter UserScholarRoles to delete.
     * @example
     * // Delete a few UserScholarRoles
     * const { count } = await prisma.userScholarRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserScholarRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserScholarRoleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserScholarRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserScholarRoles
     * const userScholarRole = await prisma.userScholarRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserScholarRoleUpdateManyArgs>(
      args: SelectSubset<T, UserScholarRoleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserScholarRoles and returns the data updated in the database.
     * @param {UserScholarRoleUpdateManyAndReturnArgs} args - Arguments to update many UserScholarRoles.
     * @example
     * // Update many UserScholarRoles
     * const userScholarRole = await prisma.userScholarRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserScholarRoles and only return the `userId`
     * const userScholarRoleWithUserIdOnly = await prisma.userScholarRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserScholarRoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserScholarRoleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserScholarRolePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserScholarRole.
     * @param {UserScholarRoleUpsertArgs} args - Arguments to update or create a UserScholarRole.
     * @example
     * // Update or create a UserScholarRole
     * const userScholarRole = await prisma.userScholarRole.upsert({
     *   create: {
     *     // ... data to create a UserScholarRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserScholarRole we want to update
     *   }
     * })
     */
    upsert<T extends UserScholarRoleUpsertArgs>(
      args: SelectSubset<T, UserScholarRoleUpsertArgs<ExtArgs>>,
    ): Prisma__UserScholarRoleClient<
      $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserScholarRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleCountArgs} args - Arguments to filter UserScholarRoles to count.
     * @example
     * // Count the number of UserScholarRoles
     * const count = await prisma.userScholarRole.count({
     *   where: {
     *     // ... the filter for the UserScholarRoles we want to count
     *   }
     * })
     **/
    count<T extends UserScholarRoleCountArgs>(
      args?: Subset<T, UserScholarRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserScholarRoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserScholarRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserScholarRoleAggregateArgs>(
      args: Subset<T, UserScholarRoleAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserScholarRoleAggregateType<T>>;

    /**
     * Group by UserScholarRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScholarRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserScholarRoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserScholarRoleGroupByArgs["orderBy"] }
        : { orderBy?: UserScholarRoleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserScholarRoleGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserScholarRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserScholarRole model
     */
    readonly fields: UserScholarRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserScholarRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserScholarRoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    scholar<T extends ScholarDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ScholarDefaultArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      | $Result.GetResult<
          Prisma.$ScholarPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    createdByUser<T extends UserScholarRole$createdByUserArgs<ExtArgs> = {}>(
      args?: Subset<T, UserScholarRole$createdByUserArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserScholarRole model
   */
  interface UserScholarRoleFieldRefs {
    readonly userId: FieldRef<"UserScholarRole", "String">;
    readonly scholarId: FieldRef<"UserScholarRole", "String">;
    readonly role: FieldRef<"UserScholarRole", "ScholarRole">;
    readonly createdAt: FieldRef<"UserScholarRole", "DateTime">;
    readonly createdByUserId: FieldRef<"UserScholarRole", "String">;
  }

  // Custom InputTypes
  /**
   * UserScholarRole findUnique
   */
  export type UserScholarRoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserScholarRole to fetch.
     */
    where: UserScholarRoleWhereUniqueInput;
  };

  /**
   * UserScholarRole findUniqueOrThrow
   */
  export type UserScholarRoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserScholarRole to fetch.
     */
    where: UserScholarRoleWhereUniqueInput;
  };

  /**
   * UserScholarRole findFirst
   */
  export type UserScholarRoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserScholarRole to fetch.
     */
    where?: UserScholarRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserScholarRoles to fetch.
     */
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserScholarRoles.
     */
    cursor?: UserScholarRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserScholarRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserScholarRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserScholarRoles.
     */
    distinct?: UserScholarRoleScalarFieldEnum | UserScholarRoleScalarFieldEnum[];
  };

  /**
   * UserScholarRole findFirstOrThrow
   */
  export type UserScholarRoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserScholarRole to fetch.
     */
    where?: UserScholarRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserScholarRoles to fetch.
     */
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserScholarRoles.
     */
    cursor?: UserScholarRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserScholarRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserScholarRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserScholarRoles.
     */
    distinct?: UserScholarRoleScalarFieldEnum | UserScholarRoleScalarFieldEnum[];
  };

  /**
   * UserScholarRole findMany
   */
  export type UserScholarRoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserScholarRoles to fetch.
     */
    where?: UserScholarRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserScholarRoles to fetch.
     */
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserScholarRoles.
     */
    cursor?: UserScholarRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserScholarRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserScholarRoles.
     */
    skip?: number;
    distinct?: UserScholarRoleScalarFieldEnum | UserScholarRoleScalarFieldEnum[];
  };

  /**
   * UserScholarRole create
   */
  export type UserScholarRoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserScholarRole.
     */
    data: XOR<UserScholarRoleCreateInput, UserScholarRoleUncheckedCreateInput>;
  };

  /**
   * UserScholarRole createMany
   */
  export type UserScholarRoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserScholarRoles.
     */
    data: UserScholarRoleCreateManyInput | UserScholarRoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserScholarRole createManyAndReturn
   */
  export type UserScholarRoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * The data used to create many UserScholarRoles.
     */
    data: UserScholarRoleCreateManyInput | UserScholarRoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserScholarRole update
   */
  export type UserScholarRoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserScholarRole.
     */
    data: XOR<UserScholarRoleUpdateInput, UserScholarRoleUncheckedUpdateInput>;
    /**
     * Choose, which UserScholarRole to update.
     */
    where: UserScholarRoleWhereUniqueInput;
  };

  /**
   * UserScholarRole updateMany
   */
  export type UserScholarRoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserScholarRoles.
     */
    data: XOR<UserScholarRoleUpdateManyMutationInput, UserScholarRoleUncheckedUpdateManyInput>;
    /**
     * Filter which UserScholarRoles to update
     */
    where?: UserScholarRoleWhereInput;
    /**
     * Limit how many UserScholarRoles to update.
     */
    limit?: number;
  };

  /**
   * UserScholarRole updateManyAndReturn
   */
  export type UserScholarRoleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * The data used to update UserScholarRoles.
     */
    data: XOR<UserScholarRoleUpdateManyMutationInput, UserScholarRoleUncheckedUpdateManyInput>;
    /**
     * Filter which UserScholarRoles to update
     */
    where?: UserScholarRoleWhereInput;
    /**
     * Limit how many UserScholarRoles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserScholarRole upsert
   */
  export type UserScholarRoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserScholarRole to update in case it exists.
     */
    where: UserScholarRoleWhereUniqueInput;
    /**
     * In case the UserScholarRole found by the `where` argument doesn't exist, create a new UserScholarRole with this data.
     */
    create: XOR<UserScholarRoleCreateInput, UserScholarRoleUncheckedCreateInput>;
    /**
     * In case the UserScholarRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserScholarRoleUpdateInput, UserScholarRoleUncheckedUpdateInput>;
  };

  /**
   * UserScholarRole delete
   */
  export type UserScholarRoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    /**
     * Filter which UserScholarRole to delete.
     */
    where: UserScholarRoleWhereUniqueInput;
  };

  /**
   * UserScholarRole deleteMany
   */
  export type UserScholarRoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserScholarRoles to delete
     */
    where?: UserScholarRoleWhereInput;
    /**
     * Limit how many UserScholarRoles to delete.
     */
    limit?: number;
  };

  /**
   * UserScholarRole.createdByUser
   */
  export type UserScholarRole$createdByUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * UserScholarRole without action
   */
  export type UserScholarRoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
  };

  /**
   * Model Scholar
   */

  export type AggregateScholar = {
    _count: ScholarCountAggregateOutputType | null;
    _min: ScholarMinAggregateOutputType | null;
    _max: ScholarMaxAggregateOutputType | null;
  };

  export type ScholarMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    name: string | null;
    bio: string | null;
    country: string | null;
    mainLanguage: string | null;
    imageUrl: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type ScholarMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    name: string | null;
    bio: string | null;
    country: string | null;
    mainLanguage: string | null;
    imageUrl: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type ScholarCountAggregateOutputType = {
    id: number;
    slug: number;
    name: number;
    bio: number;
    country: number;
    mainLanguage: number;
    imageUrl: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    ingestionBatchId: number;
    _all: number;
  };

  export type ScholarMinAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    bio?: true;
    country?: true;
    mainLanguage?: true;
    imageUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ingestionBatchId?: true;
  };

  export type ScholarMaxAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    bio?: true;
    country?: true;
    mainLanguage?: true;
    imageUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ingestionBatchId?: true;
  };

  export type ScholarCountAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    bio?: true;
    country?: true;
    mainLanguage?: true;
    imageUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ingestionBatchId?: true;
    _all?: true;
  };

  export type ScholarAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Scholar to aggregate.
     */
    where?: ScholarWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scholars to fetch.
     */
    orderBy?: ScholarOrderByWithRelationInput | ScholarOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ScholarWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scholars from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scholars.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Scholars
     **/
    _count?: true | ScholarCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ScholarMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ScholarMaxAggregateInputType;
  };

  export type GetScholarAggregateType<T extends ScholarAggregateArgs> = {
    [P in keyof T & keyof AggregateScholar]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScholar[P]>
      : GetScalarType<T[P], AggregateScholar[P]>;
  };

  export type ScholarGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScholarWhereInput;
    orderBy?: ScholarOrderByWithAggregationInput | ScholarOrderByWithAggregationInput[];
    by: ScholarScalarFieldEnum[] | ScholarScalarFieldEnum;
    having?: ScholarScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ScholarCountAggregateInputType | true;
    _min?: ScholarMinAggregateInputType;
    _max?: ScholarMaxAggregateInputType;
  };

  export type ScholarGroupByOutputType = {
    id: string;
    slug: string;
    name: string;
    bio: string | null;
    country: string | null;
    mainLanguage: string | null;
    imageUrl: string | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date | null;
    ingestionBatchId: string | null;
    _count: ScholarCountAggregateOutputType | null;
    _min: ScholarMinAggregateOutputType | null;
    _max: ScholarMaxAggregateOutputType | null;
  };

  type GetScholarGroupByPayload<T extends ScholarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScholarGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ScholarGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ScholarGroupByOutputType[P]>
          : GetScalarType<T[P], ScholarGroupByOutputType[P]>;
      }
    >
  >;

  export type ScholarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        slug?: boolean;
        name?: boolean;
        bio?: boolean;
        country?: boolean;
        mainLanguage?: boolean;
        imageUrl?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        ingestionBatchId?: boolean;
        ingestionBatch?: boolean | Scholar$ingestionBatchArgs<ExtArgs>;
        collections?: boolean | Scholar$collectionsArgs<ExtArgs>;
        series?: boolean | Scholar$seriesArgs<ExtArgs>;
        lectures?: boolean | Scholar$lecturesArgs<ExtArgs>;
        userRoles?: boolean | Scholar$userRolesArgs<ExtArgs>;
        _count?: boolean | ScholarCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["scholar"]
    >;

  export type ScholarSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      name?: boolean;
      bio?: boolean;
      country?: boolean;
      mainLanguage?: boolean;
      imageUrl?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Scholar$ingestionBatchArgs<ExtArgs>;
    },
    ExtArgs["result"]["scholar"]
  >;

  export type ScholarSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      name?: boolean;
      bio?: boolean;
      country?: boolean;
      mainLanguage?: boolean;
      imageUrl?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Scholar$ingestionBatchArgs<ExtArgs>;
    },
    ExtArgs["result"]["scholar"]
  >;

  export type ScholarSelectScalar = {
    id?: boolean;
    slug?: boolean;
    name?: boolean;
    bio?: boolean;
    country?: boolean;
    mainLanguage?: boolean;
    imageUrl?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ingestionBatchId?: boolean;
  };

  export type ScholarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "slug"
      | "name"
      | "bio"
      | "country"
      | "mainLanguage"
      | "imageUrl"
      | "isActive"
      | "createdAt"
      | "updatedAt"
      | "ingestionBatchId",
      ExtArgs["result"]["scholar"]
    >;
  export type ScholarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingestionBatch?: boolean | Scholar$ingestionBatchArgs<ExtArgs>;
    collections?: boolean | Scholar$collectionsArgs<ExtArgs>;
    series?: boolean | Scholar$seriesArgs<ExtArgs>;
    lectures?: boolean | Scholar$lecturesArgs<ExtArgs>;
    userRoles?: boolean | Scholar$userRolesArgs<ExtArgs>;
    _count?: boolean | ScholarCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ScholarIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Scholar$ingestionBatchArgs<ExtArgs>;
  };
  export type ScholarIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Scholar$ingestionBatchArgs<ExtArgs>;
  };

  export type $ScholarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: "Scholar";
      objects: {
        ingestionBatch: Prisma.$IngestionBatchPayload<ExtArgs> | null;
        collections: Prisma.$CollectionPayload<ExtArgs>[];
        series: Prisma.$SeriesPayload<ExtArgs>[];
        lectures: Prisma.$LecturePayload<ExtArgs>[];
        userRoles: Prisma.$UserScholarRolePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          slug: string;
          name: string;
          bio: string | null;
          country: string | null;
          mainLanguage: string | null;
          imageUrl: string | null;
          isActive: boolean;
          createdAt: Date;
          updatedAt: Date | null;
          ingestionBatchId: string | null;
        },
        ExtArgs["result"]["scholar"]
      >;
      composites: {};
    };

  type ScholarGetPayload<S extends boolean | null | undefined | ScholarDefaultArgs> =
    $Result.GetResult<Prisma.$ScholarPayload, S>;

  type ScholarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ScholarFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ScholarCountAggregateInputType | true;
  };

  export interface ScholarDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Scholar"]; meta: { name: "Scholar" } };
    /**
     * Find zero or one Scholar that matches the filter.
     * @param {ScholarFindUniqueArgs} args - Arguments to find a Scholar
     * @example
     * // Get one Scholar
     * const scholar = await prisma.scholar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScholarFindUniqueArgs>(
      args: SelectSubset<T, ScholarFindUniqueArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Scholar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScholarFindUniqueOrThrowArgs} args - Arguments to find a Scholar
     * @example
     * // Get one Scholar
     * const scholar = await prisma.scholar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScholarFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ScholarFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Scholar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarFindFirstArgs} args - Arguments to find a Scholar
     * @example
     * // Get one Scholar
     * const scholar = await prisma.scholar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScholarFindFirstArgs>(
      args?: SelectSubset<T, ScholarFindFirstArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Scholar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarFindFirstOrThrowArgs} args - Arguments to find a Scholar
     * @example
     * // Get one Scholar
     * const scholar = await prisma.scholar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScholarFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScholarFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Scholars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scholars
     * const scholars = await prisma.scholar.findMany()
     *
     * // Get first 10 Scholars
     * const scholars = await prisma.scholar.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const scholarWithIdOnly = await prisma.scholar.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ScholarFindManyArgs>(
      args?: SelectSubset<T, ScholarFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Scholar.
     * @param {ScholarCreateArgs} args - Arguments to create a Scholar.
     * @example
     * // Create one Scholar
     * const Scholar = await prisma.scholar.create({
     *   data: {
     *     // ... data to create a Scholar
     *   }
     * })
     *
     */
    create<T extends ScholarCreateArgs>(
      args: SelectSubset<T, ScholarCreateArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Scholars.
     * @param {ScholarCreateManyArgs} args - Arguments to create many Scholars.
     * @example
     * // Create many Scholars
     * const scholar = await prisma.scholar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ScholarCreateManyArgs>(
      args?: SelectSubset<T, ScholarCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Scholars and returns the data saved in the database.
     * @param {ScholarCreateManyAndReturnArgs} args - Arguments to create many Scholars.
     * @example
     * // Create many Scholars
     * const scholar = await prisma.scholar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Scholars and only return the `id`
     * const scholarWithIdOnly = await prisma.scholar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ScholarCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ScholarCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ScholarPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Scholar.
     * @param {ScholarDeleteArgs} args - Arguments to delete one Scholar.
     * @example
     * // Delete one Scholar
     * const Scholar = await prisma.scholar.delete({
     *   where: {
     *     // ... filter to delete one Scholar
     *   }
     * })
     *
     */
    delete<T extends ScholarDeleteArgs>(
      args: SelectSubset<T, ScholarDeleteArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Scholar.
     * @param {ScholarUpdateArgs} args - Arguments to update one Scholar.
     * @example
     * // Update one Scholar
     * const scholar = await prisma.scholar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ScholarUpdateArgs>(
      args: SelectSubset<T, ScholarUpdateArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Scholars.
     * @param {ScholarDeleteManyArgs} args - Arguments to filter Scholars to delete.
     * @example
     * // Delete a few Scholars
     * const { count } = await prisma.scholar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ScholarDeleteManyArgs>(
      args?: SelectSubset<T, ScholarDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Scholars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scholars
     * const scholar = await prisma.scholar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ScholarUpdateManyArgs>(
      args: SelectSubset<T, ScholarUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Scholars and returns the data updated in the database.
     * @param {ScholarUpdateManyAndReturnArgs} args - Arguments to update many Scholars.
     * @example
     * // Update many Scholars
     * const scholar = await prisma.scholar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Scholars and only return the `id`
     * const scholarWithIdOnly = await prisma.scholar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ScholarUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ScholarUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ScholarPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Scholar.
     * @param {ScholarUpsertArgs} args - Arguments to update or create a Scholar.
     * @example
     * // Update or create a Scholar
     * const scholar = await prisma.scholar.upsert({
     *   create: {
     *     // ... data to create a Scholar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scholar we want to update
     *   }
     * })
     */
    upsert<T extends ScholarUpsertArgs>(
      args: SelectSubset<T, ScholarUpsertArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      $Result.GetResult<Prisma.$ScholarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Scholars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarCountArgs} args - Arguments to filter Scholars to count.
     * @example
     * // Count the number of Scholars
     * const count = await prisma.scholar.count({
     *   where: {
     *     // ... the filter for the Scholars we want to count
     *   }
     * })
     **/
    count<T extends ScholarCountArgs>(
      args?: Subset<T, ScholarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ScholarCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Scholar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ScholarAggregateArgs>(
      args: Subset<T, ScholarAggregateArgs>,
    ): Prisma.PrismaPromise<GetScholarAggregateType<T>>;

    /**
     * Group by Scholar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ScholarGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScholarGroupByArgs["orderBy"] }
        : { orderBy?: ScholarGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ScholarGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetScholarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Scholar model
     */
    readonly fields: ScholarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scholar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScholarClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    ingestionBatch<T extends Scholar$ingestionBatchArgs<ExtArgs> = {}>(
      args?: Subset<T, Scholar$ingestionBatchArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    collections<T extends Scholar$collectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Scholar$collectionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    series<T extends Scholar$seriesArgs<ExtArgs> = {}>(
      args?: Subset<T, Scholar$seriesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    lectures<T extends Scholar$lecturesArgs<ExtArgs> = {}>(
      args?: Subset<T, Scholar$lecturesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    userRoles<T extends Scholar$userRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Scholar$userRolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UserScholarRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Scholar model
   */
  interface ScholarFieldRefs {
    readonly id: FieldRef<"Scholar", "String">;
    readonly slug: FieldRef<"Scholar", "String">;
    readonly name: FieldRef<"Scholar", "String">;
    readonly bio: FieldRef<"Scholar", "String">;
    readonly country: FieldRef<"Scholar", "String">;
    readonly mainLanguage: FieldRef<"Scholar", "String">;
    readonly imageUrl: FieldRef<"Scholar", "String">;
    readonly isActive: FieldRef<"Scholar", "Boolean">;
    readonly createdAt: FieldRef<"Scholar", "DateTime">;
    readonly updatedAt: FieldRef<"Scholar", "DateTime">;
    readonly ingestionBatchId: FieldRef<"Scholar", "String">;
  }

  // Custom InputTypes
  /**
   * Scholar findUnique
   */
  export type ScholarFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * Filter, which Scholar to fetch.
     */
    where: ScholarWhereUniqueInput;
  };

  /**
   * Scholar findUniqueOrThrow
   */
  export type ScholarFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * Filter, which Scholar to fetch.
     */
    where: ScholarWhereUniqueInput;
  };

  /**
   * Scholar findFirst
   */
  export type ScholarFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * Filter, which Scholar to fetch.
     */
    where?: ScholarWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scholars to fetch.
     */
    orderBy?: ScholarOrderByWithRelationInput | ScholarOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Scholars.
     */
    cursor?: ScholarWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scholars from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scholars.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Scholars.
     */
    distinct?: ScholarScalarFieldEnum | ScholarScalarFieldEnum[];
  };

  /**
   * Scholar findFirstOrThrow
   */
  export type ScholarFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * Filter, which Scholar to fetch.
     */
    where?: ScholarWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scholars to fetch.
     */
    orderBy?: ScholarOrderByWithRelationInput | ScholarOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Scholars.
     */
    cursor?: ScholarWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scholars from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scholars.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Scholars.
     */
    distinct?: ScholarScalarFieldEnum | ScholarScalarFieldEnum[];
  };

  /**
   * Scholar findMany
   */
  export type ScholarFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * Filter, which Scholars to fetch.
     */
    where?: ScholarWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scholars to fetch.
     */
    orderBy?: ScholarOrderByWithRelationInput | ScholarOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Scholars.
     */
    cursor?: ScholarWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scholars from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scholars.
     */
    skip?: number;
    distinct?: ScholarScalarFieldEnum | ScholarScalarFieldEnum[];
  };

  /**
   * Scholar create
   */
  export type ScholarCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * The data needed to create a Scholar.
     */
    data: XOR<ScholarCreateInput, ScholarUncheckedCreateInput>;
  };

  /**
   * Scholar createMany
   */
  export type ScholarCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Scholars.
     */
    data: ScholarCreateManyInput | ScholarCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Scholar createManyAndReturn
   */
  export type ScholarCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * The data used to create many Scholars.
     */
    data: ScholarCreateManyInput | ScholarCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Scholar update
   */
  export type ScholarUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * The data needed to update a Scholar.
     */
    data: XOR<ScholarUpdateInput, ScholarUncheckedUpdateInput>;
    /**
     * Choose, which Scholar to update.
     */
    where: ScholarWhereUniqueInput;
  };

  /**
   * Scholar updateMany
   */
  export type ScholarUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Scholars.
     */
    data: XOR<ScholarUpdateManyMutationInput, ScholarUncheckedUpdateManyInput>;
    /**
     * Filter which Scholars to update
     */
    where?: ScholarWhereInput;
    /**
     * Limit how many Scholars to update.
     */
    limit?: number;
  };

  /**
   * Scholar updateManyAndReturn
   */
  export type ScholarUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * The data used to update Scholars.
     */
    data: XOR<ScholarUpdateManyMutationInput, ScholarUncheckedUpdateManyInput>;
    /**
     * Filter which Scholars to update
     */
    where?: ScholarWhereInput;
    /**
     * Limit how many Scholars to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Scholar upsert
   */
  export type ScholarUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * The filter to search for the Scholar to update in case it exists.
     */
    where: ScholarWhereUniqueInput;
    /**
     * In case the Scholar found by the `where` argument doesn't exist, create a new Scholar with this data.
     */
    create: XOR<ScholarCreateInput, ScholarUncheckedCreateInput>;
    /**
     * In case the Scholar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScholarUpdateInput, ScholarUncheckedUpdateInput>;
  };

  /**
   * Scholar delete
   */
  export type ScholarDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
    /**
     * Filter which Scholar to delete.
     */
    where: ScholarWhereUniqueInput;
  };

  /**
   * Scholar deleteMany
   */
  export type ScholarDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Scholars to delete
     */
    where?: ScholarWhereInput;
    /**
     * Limit how many Scholars to delete.
     */
    limit?: number;
  };

  /**
   * Scholar.ingestionBatch
   */
  export type Scholar$ingestionBatchArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    where?: IngestionBatchWhereInput;
  };

  /**
   * Scholar.collections
   */
  export type Scholar$collectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[];
    cursor?: CollectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[];
  };

  /**
   * Scholar.series
   */
  export type Scholar$seriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    cursor?: SeriesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[];
  };

  /**
   * Scholar.lectures
   */
  export type Scholar$lecturesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    where?: LectureWhereInput;
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    cursor?: LectureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Scholar.userRoles
   */
  export type Scholar$userRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserScholarRole
     */
    select?: UserScholarRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserScholarRole
     */
    omit?: UserScholarRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserScholarRoleInclude<ExtArgs> | null;
    where?: UserScholarRoleWhereInput;
    orderBy?: UserScholarRoleOrderByWithRelationInput | UserScholarRoleOrderByWithRelationInput[];
    cursor?: UserScholarRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScholarRoleScalarFieldEnum | UserScholarRoleScalarFieldEnum[];
  };

  /**
   * Scholar without action
   */
  export type ScholarDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Scholar
     */
    select?: ScholarSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Scholar
     */
    omit?: ScholarOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScholarInclude<ExtArgs> | null;
  };

  /**
   * Model Collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null;
    _avg: CollectionAvgAggregateOutputType | null;
    _sum: CollectionSumAggregateOutputType | null;
    _min: CollectionMinAggregateOutputType | null;
    _max: CollectionMaxAggregateOutputType | null;
  };

  export type CollectionAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type CollectionSumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type CollectionMinAggregateOutputType = {
    id: string | null;
    scholarId: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    coverImageUrl: string | null;
    language: string | null;
    status: $Enums.Status | null;
    orderIndex: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type CollectionMaxAggregateOutputType = {
    id: string | null;
    scholarId: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    coverImageUrl: string | null;
    language: string | null;
    status: $Enums.Status | null;
    orderIndex: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type CollectionCountAggregateOutputType = {
    id: number;
    scholarId: number;
    slug: number;
    title: number;
    description: number;
    coverImageUrl: number;
    language: number;
    status: number;
    orderIndex: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    deleteAfterAt: number;
    ingestionBatchId: number;
    _all: number;
  };

  export type CollectionAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type CollectionSumAggregateInputType = {
    orderIndex?: true;
  };

  export type CollectionMinAggregateInputType = {
    id?: true;
    scholarId?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImageUrl?: true;
    language?: true;
    status?: true;
    orderIndex?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
  };

  export type CollectionMaxAggregateInputType = {
    id?: true;
    scholarId?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImageUrl?: true;
    language?: true;
    status?: true;
    orderIndex?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
  };

  export type CollectionCountAggregateInputType = {
    id?: true;
    scholarId?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImageUrl?: true;
    language?: true;
    status?: true;
    orderIndex?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
    _all?: true;
  };

  export type CollectionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Collection to aggregate.
     */
    where?: CollectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CollectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Collections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Collections
     **/
    _count?: true | CollectionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CollectionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CollectionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CollectionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CollectionMaxAggregateInputType;
  };

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
    [P in keyof T & keyof AggregateCollection]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>;
  };

  export type CollectionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByWithAggregationInput | CollectionOrderByWithAggregationInput[];
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum;
    having?: CollectionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CollectionCountAggregateInputType | true;
    _avg?: CollectionAvgAggregateInputType;
    _sum?: CollectionSumAggregateInputType;
    _min?: CollectionMinAggregateInputType;
    _max?: CollectionMaxAggregateInputType;
  };

  export type CollectionGroupByOutputType = {
    id: string;
    scholarId: string;
    slug: string;
    title: string;
    description: string | null;
    coverImageUrl: string | null;
    language: string | null;
    status: $Enums.Status;
    orderIndex: number | null;
    createdAt: Date;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
    _count: CollectionCountAggregateOutputType | null;
    _avg: CollectionAvgAggregateOutputType | null;
    _sum: CollectionSumAggregateOutputType | null;
    _min: CollectionMinAggregateOutputType | null;
    _max: CollectionMaxAggregateOutputType | null;
  };

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof CollectionGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
          : GetScalarType<T[P], CollectionGroupByOutputType[P]>;
      }
    >
  >;

  export type CollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        scholarId?: boolean;
        slug?: boolean;
        title?: boolean;
        description?: boolean;
        coverImageUrl?: boolean;
        language?: boolean;
        status?: boolean;
        orderIndex?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        deleteAfterAt?: boolean;
        ingestionBatchId?: boolean;
        ingestionBatch?: boolean | Collection$ingestionBatchArgs<ExtArgs>;
        scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
        series?: boolean | Collection$seriesArgs<ExtArgs>;
        topics?: boolean | Collection$topicsArgs<ExtArgs>;
        _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["collection"]
    >;

  export type CollectionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scholarId?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      coverImageUrl?: boolean;
      language?: boolean;
      status?: boolean;
      orderIndex?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      deleteAfterAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Collection$ingestionBatchArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["collection"]
  >;

  export type CollectionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scholarId?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      coverImageUrl?: boolean;
      language?: boolean;
      status?: boolean;
      orderIndex?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      deleteAfterAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Collection$ingestionBatchArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["collection"]
  >;

  export type CollectionSelectScalar = {
    id?: boolean;
    scholarId?: boolean;
    slug?: boolean;
    title?: boolean;
    description?: boolean;
    coverImageUrl?: boolean;
    language?: boolean;
    status?: boolean;
    orderIndex?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
    deleteAfterAt?: boolean;
    ingestionBatchId?: boolean;
  };

  export type CollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "scholarId"
      | "slug"
      | "title"
      | "description"
      | "coverImageUrl"
      | "language"
      | "status"
      | "orderIndex"
      | "createdAt"
      | "updatedAt"
      | "deletedAt"
      | "deleteAfterAt"
      | "ingestionBatchId",
      ExtArgs["result"]["collection"]
    >;
  export type CollectionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Collection$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    series?: boolean | Collection$seriesArgs<ExtArgs>;
    topics?: boolean | Collection$topicsArgs<ExtArgs>;
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CollectionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Collection$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
  };
  export type CollectionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Collection$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
  };

  export type $CollectionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Collection";
    objects: {
      ingestionBatch: Prisma.$IngestionBatchPayload<ExtArgs> | null;
      scholar: Prisma.$ScholarPayload<ExtArgs>;
      series: Prisma.$SeriesPayload<ExtArgs>[];
      topics: Prisma.$CollectionTopicPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        scholarId: string;
        slug: string;
        title: string;
        description: string | null;
        coverImageUrl: string | null;
        language: string | null;
        status: $Enums.Status;
        orderIndex: number | null;
        createdAt: Date;
        updatedAt: Date | null;
        deletedAt: Date | null;
        deleteAfterAt: Date | null;
        ingestionBatchId: string | null;
      },
      ExtArgs["result"]["collection"]
    >;
    composites: {};
  };

  type CollectionGetPayload<S extends boolean | null | undefined | CollectionDefaultArgs> =
    $Result.GetResult<Prisma.$CollectionPayload, S>;

  type CollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: CollectionCountAggregateInputType | true;
    };

  export interface CollectionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Collection"];
      meta: { name: "Collection" };
    };
    /**
     * Find zero or one Collection that matches the filter.
     * @param {CollectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionFindUniqueArgs>(
      args: SelectSubset<T, CollectionFindUniqueArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CollectionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionFindFirstArgs>(
      args?: SelectSubset<T, CollectionFindFirstArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CollectionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     *
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CollectionFindManyArgs>(
      args?: SelectSubset<T, CollectionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Collection.
     * @param {CollectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     *
     */
    create<T extends CollectionCreateArgs>(
      args: SelectSubset<T, CollectionCreateArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Collections.
     * @param {CollectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CollectionCreateManyArgs>(
      args?: SelectSubset<T, CollectionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {CollectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CollectionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CollectionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Collection.
     * @param {CollectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     *
     */
    delete<T extends CollectionDeleteArgs>(
      args: SelectSubset<T, CollectionDeleteArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Collection.
     * @param {CollectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CollectionUpdateArgs>(
      args: SelectSubset<T, CollectionUpdateArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Collections.
     * @param {CollectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CollectionDeleteManyArgs>(
      args?: SelectSubset<T, CollectionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CollectionUpdateManyArgs>(
      args: SelectSubset<T, CollectionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Collections and returns the data updated in the database.
     * @param {CollectionUpdateManyAndReturnArgs} args - Arguments to update many Collections.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CollectionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CollectionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Collection.
     * @param {CollectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends CollectionUpsertArgs>(
      args: SelectSubset<T, CollectionUpsertArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
     **/
    count<T extends CollectionCountArgs>(
      args?: Subset<T, CollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CollectionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CollectionAggregateArgs>(
      args: Subset<T, CollectionAggregateArgs>,
    ): Prisma.PrismaPromise<GetCollectionAggregateType<T>>;

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs["orderBy"] }
        : { orderBy?: CollectionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Collection model
     */
    readonly fields: CollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    ingestionBatch<T extends Collection$ingestionBatchArgs<ExtArgs> = {}>(
      args?: Subset<T, Collection$ingestionBatchArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    scholar<T extends ScholarDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ScholarDefaultArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      | $Result.GetResult<
          Prisma.$ScholarPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    series<T extends Collection$seriesArgs<ExtArgs> = {}>(
      args?: Subset<T, Collection$seriesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    topics<T extends Collection$topicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Collection$topicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Collection model
   */
  interface CollectionFieldRefs {
    readonly id: FieldRef<"Collection", "String">;
    readonly scholarId: FieldRef<"Collection", "String">;
    readonly slug: FieldRef<"Collection", "String">;
    readonly title: FieldRef<"Collection", "String">;
    readonly description: FieldRef<"Collection", "String">;
    readonly coverImageUrl: FieldRef<"Collection", "String">;
    readonly language: FieldRef<"Collection", "String">;
    readonly status: FieldRef<"Collection", "Status">;
    readonly orderIndex: FieldRef<"Collection", "Int">;
    readonly createdAt: FieldRef<"Collection", "DateTime">;
    readonly updatedAt: FieldRef<"Collection", "DateTime">;
    readonly deletedAt: FieldRef<"Collection", "DateTime">;
    readonly deleteAfterAt: FieldRef<"Collection", "DateTime">;
    readonly ingestionBatchId: FieldRef<"Collection", "String">;
  }

  // Custom InputTypes
  /**
   * Collection findUnique
   */
  export type CollectionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput;
  };

  /**
   * Collection findUniqueOrThrow
   */
  export type CollectionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput;
  };

  /**
   * Collection findFirst
   */
  export type CollectionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Collections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[];
  };

  /**
   * Collection findFirstOrThrow
   */
  export type CollectionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Collections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[];
  };

  /**
   * Collection findMany
   */
  export type CollectionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * Filter, which Collections to fetch.
     */
    where?: CollectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Collections.
     */
    cursor?: CollectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Collections.
     */
    skip?: number;
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[];
  };

  /**
   * Collection create
   */
  export type CollectionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Collection.
     */
    data: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>;
  };

  /**
   * Collection createMany
   */
  export type CollectionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Collection createManyAndReturn
   */
  export type CollectionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Collection update
   */
  export type CollectionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Collection.
     */
    data: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>;
    /**
     * Choose, which Collection to update.
     */
    where: CollectionWhereUniqueInput;
  };

  /**
   * Collection updateMany
   */
  export type CollectionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>;
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput;
    /**
     * Limit how many Collections to update.
     */
    limit?: number;
  };

  /**
   * Collection updateManyAndReturn
   */
  export type CollectionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>;
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput;
    /**
     * Limit how many Collections to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Collection upsert
   */
  export type CollectionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Collection to update in case it exists.
     */
    where: CollectionWhereUniqueInput;
    /**
     * In case the Collection found by the `where` argument doesn't exist, create a new Collection with this data.
     */
    create: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>;
    /**
     * In case the Collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>;
  };

  /**
   * Collection delete
   */
  export type CollectionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    /**
     * Filter which Collection to delete.
     */
    where: CollectionWhereUniqueInput;
  };

  /**
   * Collection deleteMany
   */
  export type CollectionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Collections to delete
     */
    where?: CollectionWhereInput;
    /**
     * Limit how many Collections to delete.
     */
    limit?: number;
  };

  /**
   * Collection.ingestionBatch
   */
  export type Collection$ingestionBatchArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    where?: IngestionBatchWhereInput;
  };

  /**
   * Collection.series
   */
  export type Collection$seriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    cursor?: SeriesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[];
  };

  /**
   * Collection.topics
   */
  export type Collection$topicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    where?: CollectionTopicWhereInput;
    orderBy?: CollectionTopicOrderByWithRelationInput | CollectionTopicOrderByWithRelationInput[];
    cursor?: CollectionTopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CollectionTopicScalarFieldEnum | CollectionTopicScalarFieldEnum[];
  };

  /**
   * Collection without action
   */
  export type CollectionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
  };

  /**
   * Model Series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null;
    _avg: SeriesAvgAggregateOutputType | null;
    _sum: SeriesSumAggregateOutputType | null;
    _min: SeriesMinAggregateOutputType | null;
    _max: SeriesMaxAggregateOutputType | null;
  };

  export type SeriesAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type SeriesSumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type SeriesMinAggregateOutputType = {
    id: string | null;
    scholarId: string | null;
    collectionId: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    coverImageUrl: string | null;
    language: string | null;
    status: $Enums.Status | null;
    orderIndex: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type SeriesMaxAggregateOutputType = {
    id: string | null;
    scholarId: string | null;
    collectionId: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    coverImageUrl: string | null;
    language: string | null;
    status: $Enums.Status | null;
    orderIndex: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type SeriesCountAggregateOutputType = {
    id: number;
    scholarId: number;
    collectionId: number;
    slug: number;
    title: number;
    description: number;
    coverImageUrl: number;
    language: number;
    status: number;
    orderIndex: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    deleteAfterAt: number;
    ingestionBatchId: number;
    _all: number;
  };

  export type SeriesAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type SeriesSumAggregateInputType = {
    orderIndex?: true;
  };

  export type SeriesMinAggregateInputType = {
    id?: true;
    scholarId?: true;
    collectionId?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImageUrl?: true;
    language?: true;
    status?: true;
    orderIndex?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
  };

  export type SeriesMaxAggregateInputType = {
    id?: true;
    scholarId?: true;
    collectionId?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImageUrl?: true;
    language?: true;
    status?: true;
    orderIndex?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
  };

  export type SeriesCountAggregateInputType = {
    id?: true;
    scholarId?: true;
    collectionId?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImageUrl?: true;
    language?: true;
    status?: true;
    orderIndex?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
    _all?: true;
  };

  export type SeriesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Series to aggregate.
     */
    where?: SeriesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SeriesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Series from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Series.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Series
     **/
    _count?: true | SeriesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SeriesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SeriesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SeriesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SeriesMaxAggregateInputType;
  };

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
    [P in keyof T & keyof AggregateSeries]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>;
  };

  export type SeriesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByWithAggregationInput | SeriesOrderByWithAggregationInput[];
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum;
    having?: SeriesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SeriesCountAggregateInputType | true;
    _avg?: SeriesAvgAggregateInputType;
    _sum?: SeriesSumAggregateInputType;
    _min?: SeriesMinAggregateInputType;
    _max?: SeriesMaxAggregateInputType;
  };

  export type SeriesGroupByOutputType = {
    id: string;
    scholarId: string;
    collectionId: string | null;
    slug: string;
    title: string;
    description: string | null;
    coverImageUrl: string | null;
    language: string | null;
    status: $Enums.Status;
    orderIndex: number | null;
    createdAt: Date;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
    _count: SeriesCountAggregateOutputType | null;
    _avg: SeriesAvgAggregateOutputType | null;
    _sum: SeriesSumAggregateOutputType | null;
    _min: SeriesMinAggregateOutputType | null;
    _max: SeriesMaxAggregateOutputType | null;
  };

  type GetSeriesGroupByPayload<T extends SeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof SeriesGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
          : GetScalarType<T[P], SeriesGroupByOutputType[P]>;
      }
    >
  >;

  export type SeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        scholarId?: boolean;
        collectionId?: boolean;
        slug?: boolean;
        title?: boolean;
        description?: boolean;
        coverImageUrl?: boolean;
        language?: boolean;
        status?: boolean;
        orderIndex?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        deleteAfterAt?: boolean;
        ingestionBatchId?: boolean;
        ingestionBatch?: boolean | Series$ingestionBatchArgs<ExtArgs>;
        scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
        collection?: boolean | Series$collectionArgs<ExtArgs>;
        lectures?: boolean | Series$lecturesArgs<ExtArgs>;
        topics?: boolean | Series$topicsArgs<ExtArgs>;
        _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["series"]
    >;

  export type SeriesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scholarId?: boolean;
      collectionId?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      coverImageUrl?: boolean;
      language?: boolean;
      status?: boolean;
      orderIndex?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      deleteAfterAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Series$ingestionBatchArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      collection?: boolean | Series$collectionArgs<ExtArgs>;
    },
    ExtArgs["result"]["series"]
  >;

  export type SeriesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scholarId?: boolean;
      collectionId?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      coverImageUrl?: boolean;
      language?: boolean;
      status?: boolean;
      orderIndex?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      deleteAfterAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Series$ingestionBatchArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      collection?: boolean | Series$collectionArgs<ExtArgs>;
    },
    ExtArgs["result"]["series"]
  >;

  export type SeriesSelectScalar = {
    id?: boolean;
    scholarId?: boolean;
    collectionId?: boolean;
    slug?: boolean;
    title?: boolean;
    description?: boolean;
    coverImageUrl?: boolean;
    language?: boolean;
    status?: boolean;
    orderIndex?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
    deleteAfterAt?: boolean;
    ingestionBatchId?: boolean;
  };

  export type SeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "scholarId"
      | "collectionId"
      | "slug"
      | "title"
      | "description"
      | "coverImageUrl"
      | "language"
      | "status"
      | "orderIndex"
      | "createdAt"
      | "updatedAt"
      | "deletedAt"
      | "deleteAfterAt"
      | "ingestionBatchId",
      ExtArgs["result"]["series"]
    >;
  export type SeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingestionBatch?: boolean | Series$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    collection?: boolean | Series$collectionArgs<ExtArgs>;
    lectures?: boolean | Series$lecturesArgs<ExtArgs>;
    topics?: boolean | Series$topicsArgs<ExtArgs>;
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SeriesIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Series$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    collection?: boolean | Series$collectionArgs<ExtArgs>;
  };
  export type SeriesIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Series$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    collection?: boolean | Series$collectionArgs<ExtArgs>;
  };

  export type $SeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Series";
    objects: {
      ingestionBatch: Prisma.$IngestionBatchPayload<ExtArgs> | null;
      scholar: Prisma.$ScholarPayload<ExtArgs>;
      collection: Prisma.$CollectionPayload<ExtArgs> | null;
      lectures: Prisma.$LecturePayload<ExtArgs>[];
      topics: Prisma.$SeriesTopicPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        scholarId: string;
        collectionId: string | null;
        slug: string;
        title: string;
        description: string | null;
        coverImageUrl: string | null;
        language: string | null;
        status: $Enums.Status;
        orderIndex: number | null;
        createdAt: Date;
        updatedAt: Date | null;
        deletedAt: Date | null;
        deleteAfterAt: Date | null;
        ingestionBatchId: string | null;
      },
      ExtArgs["result"]["series"]
    >;
    composites: {};
  };

  type SeriesGetPayload<S extends boolean | null | undefined | SeriesDefaultArgs> =
    $Result.GetResult<Prisma.$SeriesPayload, S>;

  type SeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SeriesFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SeriesCountAggregateInputType | true;
  };

  export interface SeriesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Series"]; meta: { name: "Series" } };
    /**
     * Find zero or one Series that matches the filter.
     * @param {SeriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesFindUniqueArgs>(
      args: SelectSubset<T, SeriesFindUniqueArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SeriesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesFindFirstArgs>(
      args?: SelectSubset<T, SeriesFindFirstArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SeriesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     *
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SeriesFindManyArgs>(
      args?: SelectSubset<T, SeriesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Series.
     * @param {SeriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     *
     */
    create<T extends SeriesCreateArgs>(
      args: SelectSubset<T, SeriesCreateArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Series.
     * @param {SeriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SeriesCreateManyArgs>(
      args?: SelectSubset<T, SeriesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Series and returns the data saved in the database.
     * @param {SeriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SeriesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SeriesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Series.
     * @param {SeriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     *
     */
    delete<T extends SeriesDeleteArgs>(
      args: SelectSubset<T, SeriesDeleteArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Series.
     * @param {SeriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SeriesUpdateArgs>(
      args: SelectSubset<T, SeriesUpdateArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Series.
     * @param {SeriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SeriesDeleteManyArgs>(
      args?: SelectSubset<T, SeriesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SeriesUpdateManyArgs>(
      args: SelectSubset<T, SeriesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {SeriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SeriesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SeriesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Series.
     * @param {SeriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends SeriesUpsertArgs>(
      args: SelectSubset<T, SeriesUpsertArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
     **/
    count<T extends SeriesCountArgs>(
      args?: Subset<T, SeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SeriesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SeriesAggregateArgs>(
      args: Subset<T, SeriesAggregateArgs>,
    ): Prisma.PrismaPromise<GetSeriesAggregateType<T>>;

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SeriesGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesGroupByArgs["orderBy"] }
        : { orderBy?: SeriesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SeriesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Series model
     */
    readonly fields: SeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    ingestionBatch<T extends Series$ingestionBatchArgs<ExtArgs> = {}>(
      args?: Subset<T, Series$ingestionBatchArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    scholar<T extends ScholarDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ScholarDefaultArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      | $Result.GetResult<
          Prisma.$ScholarPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    collection<T extends Series$collectionArgs<ExtArgs> = {}>(
      args?: Subset<T, Series$collectionArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      $Result.GetResult<
        Prisma.$CollectionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    lectures<T extends Series$lecturesArgs<ExtArgs> = {}>(
      args?: Subset<T, Series$lecturesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    topics<T extends Series$topicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Series$topicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Series model
   */
  interface SeriesFieldRefs {
    readonly id: FieldRef<"Series", "String">;
    readonly scholarId: FieldRef<"Series", "String">;
    readonly collectionId: FieldRef<"Series", "String">;
    readonly slug: FieldRef<"Series", "String">;
    readonly title: FieldRef<"Series", "String">;
    readonly description: FieldRef<"Series", "String">;
    readonly coverImageUrl: FieldRef<"Series", "String">;
    readonly language: FieldRef<"Series", "String">;
    readonly status: FieldRef<"Series", "Status">;
    readonly orderIndex: FieldRef<"Series", "Int">;
    readonly createdAt: FieldRef<"Series", "DateTime">;
    readonly updatedAt: FieldRef<"Series", "DateTime">;
    readonly deletedAt: FieldRef<"Series", "DateTime">;
    readonly deleteAfterAt: FieldRef<"Series", "DateTime">;
    readonly ingestionBatchId: FieldRef<"Series", "String">;
  }

  // Custom InputTypes
  /**
   * Series findUnique
   */
  export type SeriesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput;
  };

  /**
   * Series findUniqueOrThrow
   */
  export type SeriesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput;
  };

  /**
   * Series findFirst
   */
  export type SeriesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Series from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Series.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[];
  };

  /**
   * Series findFirstOrThrow
   */
  export type SeriesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Series from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Series.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[];
  };

  /**
   * Series findMany
   */
  export type SeriesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Series.
     */
    cursor?: SeriesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Series from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Series.
     */
    skip?: number;
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[];
  };

  /**
   * Series create
   */
  export type SeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Series
       */
      select?: SeriesSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Series
       */
      omit?: SeriesOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SeriesInclude<ExtArgs> | null;
      /**
       * The data needed to create a Series.
       */
      data: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>;
    };

  /**
   * Series createMany
   */
  export type SeriesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Series createManyAndReturn
   */
  export type SeriesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Series update
   */
  export type SeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Series
       */
      select?: SeriesSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Series
       */
      omit?: SeriesOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SeriesInclude<ExtArgs> | null;
      /**
       * The data needed to update a Series.
       */
      data: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>;
      /**
       * Choose, which Series to update.
       */
      where: SeriesWhereUniqueInput;
    };

  /**
   * Series updateMany
   */
  export type SeriesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>;
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput;
    /**
     * Limit how many Series to update.
     */
    limit?: number;
  };

  /**
   * Series updateManyAndReturn
   */
  export type SeriesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>;
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput;
    /**
     * Limit how many Series to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Series upsert
   */
  export type SeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Series
       */
      select?: SeriesSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Series
       */
      omit?: SeriesOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SeriesInclude<ExtArgs> | null;
      /**
       * The filter to search for the Series to update in case it exists.
       */
      where: SeriesWhereUniqueInput;
      /**
       * In case the Series found by the `where` argument doesn't exist, create a new Series with this data.
       */
      create: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>;
      /**
       * In case the Series was found with the provided `where` argument, update it with this data.
       */
      update: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>;
    };

  /**
   * Series delete
   */
  export type SeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Series
       */
      select?: SeriesSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Series
       */
      omit?: SeriesOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SeriesInclude<ExtArgs> | null;
      /**
       * Filter which Series to delete.
       */
      where: SeriesWhereUniqueInput;
    };

  /**
   * Series deleteMany
   */
  export type SeriesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Series to delete
     */
    where?: SeriesWhereInput;
    /**
     * Limit how many Series to delete.
     */
    limit?: number;
  };

  /**
   * Series.ingestionBatch
   */
  export type Series$ingestionBatchArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    where?: IngestionBatchWhereInput;
  };

  /**
   * Series.collection
   */
  export type Series$collectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null;
    where?: CollectionWhereInput;
  };

  /**
   * Series.lectures
   */
  export type Series$lecturesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    where?: LectureWhereInput;
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    cursor?: LectureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Series.topics
   */
  export type Series$topicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    where?: SeriesTopicWhereInput;
    orderBy?: SeriesTopicOrderByWithRelationInput | SeriesTopicOrderByWithRelationInput[];
    cursor?: SeriesTopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SeriesTopicScalarFieldEnum | SeriesTopicScalarFieldEnum[];
  };

  /**
   * Series without action
   */
  export type SeriesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
  };

  /**
   * Model Lecture
   */

  export type AggregateLecture = {
    _count: LectureCountAggregateOutputType | null;
    _avg: LectureAvgAggregateOutputType | null;
    _sum: LectureSumAggregateOutputType | null;
    _min: LectureMinAggregateOutputType | null;
    _max: LectureMaxAggregateOutputType | null;
  };

  export type LectureAvgAggregateOutputType = {
    orderIndex: number | null;
    durationSeconds: number | null;
  };

  export type LectureSumAggregateOutputType = {
    orderIndex: number | null;
    durationSeconds: number | null;
  };

  export type LectureMinAggregateOutputType = {
    id: string | null;
    scholarId: string | null;
    seriesId: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    language: string | null;
    status: $Enums.Status | null;
    publishedAt: Date | null;
    orderIndex: number | null;
    durationSeconds: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type LectureMaxAggregateOutputType = {
    id: string | null;
    scholarId: string | null;
    seriesId: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    language: string | null;
    status: $Enums.Status | null;
    publishedAt: Date | null;
    orderIndex: number | null;
    durationSeconds: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type LectureCountAggregateOutputType = {
    id: number;
    scholarId: number;
    seriesId: number;
    slug: number;
    title: number;
    description: number;
    language: number;
    status: number;
    publishedAt: number;
    orderIndex: number;
    durationSeconds: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    deleteAfterAt: number;
    ingestionBatchId: number;
    _all: number;
  };

  export type LectureAvgAggregateInputType = {
    orderIndex?: true;
    durationSeconds?: true;
  };

  export type LectureSumAggregateInputType = {
    orderIndex?: true;
    durationSeconds?: true;
  };

  export type LectureMinAggregateInputType = {
    id?: true;
    scholarId?: true;
    seriesId?: true;
    slug?: true;
    title?: true;
    description?: true;
    language?: true;
    status?: true;
    publishedAt?: true;
    orderIndex?: true;
    durationSeconds?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
  };

  export type LectureMaxAggregateInputType = {
    id?: true;
    scholarId?: true;
    seriesId?: true;
    slug?: true;
    title?: true;
    description?: true;
    language?: true;
    status?: true;
    publishedAt?: true;
    orderIndex?: true;
    durationSeconds?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
  };

  export type LectureCountAggregateInputType = {
    id?: true;
    scholarId?: true;
    seriesId?: true;
    slug?: true;
    title?: true;
    description?: true;
    language?: true;
    status?: true;
    publishedAt?: true;
    orderIndex?: true;
    durationSeconds?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    deleteAfterAt?: true;
    ingestionBatchId?: true;
    _all?: true;
  };

  export type LectureAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Lecture to aggregate.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Lectures
     **/
    _count?: true | LectureCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LectureAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LectureSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LectureMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LectureMaxAggregateInputType;
  };

  export type GetLectureAggregateType<T extends LectureAggregateArgs> = {
    [P in keyof T & keyof AggregateLecture]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture[P]>
      : GetScalarType<T[P], AggregateLecture[P]>;
  };

  export type LectureGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureWhereInput;
    orderBy?: LectureOrderByWithAggregationInput | LectureOrderByWithAggregationInput[];
    by: LectureScalarFieldEnum[] | LectureScalarFieldEnum;
    having?: LectureScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LectureCountAggregateInputType | true;
    _avg?: LectureAvgAggregateInputType;
    _sum?: LectureSumAggregateInputType;
    _min?: LectureMinAggregateInputType;
    _max?: LectureMaxAggregateInputType;
  };

  export type LectureGroupByOutputType = {
    id: string;
    scholarId: string;
    seriesId: string | null;
    slug: string;
    title: string;
    description: string | null;
    language: string | null;
    status: $Enums.Status;
    publishedAt: Date | null;
    orderIndex: number | null;
    durationSeconds: number | null;
    createdAt: Date;
    updatedAt: Date | null;
    deletedAt: Date | null;
    deleteAfterAt: Date | null;
    ingestionBatchId: string | null;
    _count: LectureCountAggregateOutputType | null;
    _avg: LectureAvgAggregateOutputType | null;
    _sum: LectureSumAggregateOutputType | null;
    _min: LectureMinAggregateOutputType | null;
    _max: LectureMaxAggregateOutputType | null;
  };

  type GetLectureGroupByPayload<T extends LectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LectureGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof LectureGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], LectureGroupByOutputType[P]>
          : GetScalarType<T[P], LectureGroupByOutputType[P]>;
      }
    >
  >;

  export type LectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        scholarId?: boolean;
        seriesId?: boolean;
        slug?: boolean;
        title?: boolean;
        description?: boolean;
        language?: boolean;
        status?: boolean;
        publishedAt?: boolean;
        orderIndex?: boolean;
        durationSeconds?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        deleteAfterAt?: boolean;
        ingestionBatchId?: boolean;
        ingestionBatch?: boolean | Lecture$ingestionBatchArgs<ExtArgs>;
        scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
        series?: boolean | Lecture$seriesArgs<ExtArgs>;
        audioAssets?: boolean | Lecture$audioAssetsArgs<ExtArgs>;
        topics?: boolean | Lecture$topicsArgs<ExtArgs>;
        progress?: boolean | Lecture$progressArgs<ExtArgs>;
        favorites?: boolean | Lecture$favoritesArgs<ExtArgs>;
        _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["lecture"]
    >;

  export type LectureSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scholarId?: boolean;
      seriesId?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      language?: boolean;
      status?: boolean;
      publishedAt?: boolean;
      orderIndex?: boolean;
      durationSeconds?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      deleteAfterAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Lecture$ingestionBatchArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      series?: boolean | Lecture$seriesArgs<ExtArgs>;
    },
    ExtArgs["result"]["lecture"]
  >;

  export type LectureSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scholarId?: boolean;
      seriesId?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      language?: boolean;
      status?: boolean;
      publishedAt?: boolean;
      orderIndex?: boolean;
      durationSeconds?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      deleteAfterAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | Lecture$ingestionBatchArgs<ExtArgs>;
      scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
      series?: boolean | Lecture$seriesArgs<ExtArgs>;
    },
    ExtArgs["result"]["lecture"]
  >;

  export type LectureSelectScalar = {
    id?: boolean;
    scholarId?: boolean;
    seriesId?: boolean;
    slug?: boolean;
    title?: boolean;
    description?: boolean;
    language?: boolean;
    status?: boolean;
    publishedAt?: boolean;
    orderIndex?: boolean;
    durationSeconds?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
    deleteAfterAt?: boolean;
    ingestionBatchId?: boolean;
  };

  export type LectureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "scholarId"
      | "seriesId"
      | "slug"
      | "title"
      | "description"
      | "language"
      | "status"
      | "publishedAt"
      | "orderIndex"
      | "durationSeconds"
      | "createdAt"
      | "updatedAt"
      | "deletedAt"
      | "deleteAfterAt"
      | "ingestionBatchId",
      ExtArgs["result"]["lecture"]
    >;
  export type LectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingestionBatch?: boolean | Lecture$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    series?: boolean | Lecture$seriesArgs<ExtArgs>;
    audioAssets?: boolean | Lecture$audioAssetsArgs<ExtArgs>;
    topics?: boolean | Lecture$topicsArgs<ExtArgs>;
    progress?: boolean | Lecture$progressArgs<ExtArgs>;
    favorites?: boolean | Lecture$favoritesArgs<ExtArgs>;
    _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type LectureIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Lecture$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    series?: boolean | Lecture$seriesArgs<ExtArgs>;
  };
  export type LectureIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | Lecture$ingestionBatchArgs<ExtArgs>;
    scholar?: boolean | ScholarDefaultArgs<ExtArgs>;
    series?: boolean | Lecture$seriesArgs<ExtArgs>;
  };

  export type $LecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: "Lecture";
      objects: {
        ingestionBatch: Prisma.$IngestionBatchPayload<ExtArgs> | null;
        scholar: Prisma.$ScholarPayload<ExtArgs>;
        series: Prisma.$SeriesPayload<ExtArgs> | null;
        audioAssets: Prisma.$AudioAssetPayload<ExtArgs>[];
        topics: Prisma.$LectureTopicPayload<ExtArgs>[];
        progress: Prisma.$UserLectureProgressPayload<ExtArgs>[];
        favorites: Prisma.$FavoriteLecturePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          scholarId: string;
          seriesId: string | null;
          slug: string;
          title: string;
          description: string | null;
          language: string | null;
          status: $Enums.Status;
          publishedAt: Date | null;
          orderIndex: number | null;
          durationSeconds: number | null;
          createdAt: Date;
          updatedAt: Date | null;
          deletedAt: Date | null;
          deleteAfterAt: Date | null;
          ingestionBatchId: string | null;
        },
        ExtArgs["result"]["lecture"]
      >;
      composites: {};
    };

  type LectureGetPayload<S extends boolean | null | undefined | LectureDefaultArgs> =
    $Result.GetResult<Prisma.$LecturePayload, S>;

  type LectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    LectureFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: LectureCountAggregateInputType | true;
  };

  export interface LectureDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Lecture"]; meta: { name: "Lecture" } };
    /**
     * Find zero or one Lecture that matches the filter.
     * @param {LectureFindUniqueArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureFindUniqueArgs>(
      args: SelectSubset<T, LectureFindUniqueArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Lecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LectureFindUniqueOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LectureFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Lecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureFindFirstArgs>(
      args?: SelectSubset<T, LectureFindFirstArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Lecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LectureFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lecture.findMany()
     *
     * // Get first 10 Lectures
     * const lectures = await prisma.lecture.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const lectureWithIdOnly = await prisma.lecture.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LectureFindManyArgs>(
      args?: SelectSubset<T, LectureFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Lecture.
     * @param {LectureCreateArgs} args - Arguments to create a Lecture.
     * @example
     * // Create one Lecture
     * const Lecture = await prisma.lecture.create({
     *   data: {
     *     // ... data to create a Lecture
     *   }
     * })
     *
     */
    create<T extends LectureCreateArgs>(
      args: SelectSubset<T, LectureCreateArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Lectures.
     * @param {LectureCreateManyArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LectureCreateManyArgs>(
      args?: SelectSubset<T, LectureCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Lectures and returns the data saved in the database.
     * @param {LectureCreateManyAndReturnArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Lectures and only return the `id`
     * const lectureWithIdOnly = await prisma.lecture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LectureCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LectureCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Lecture.
     * @param {LectureDeleteArgs} args - Arguments to delete one Lecture.
     * @example
     * // Delete one Lecture
     * const Lecture = await prisma.lecture.delete({
     *   where: {
     *     // ... filter to delete one Lecture
     *   }
     * })
     *
     */
    delete<T extends LectureDeleteArgs>(
      args: SelectSubset<T, LectureDeleteArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Lecture.
     * @param {LectureUpdateArgs} args - Arguments to update one Lecture.
     * @example
     * // Update one Lecture
     * const lecture = await prisma.lecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LectureUpdateArgs>(
      args: SelectSubset<T, LectureUpdateArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Lectures.
     * @param {LectureDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LectureDeleteManyArgs>(
      args?: SelectSubset<T, LectureDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LectureUpdateManyArgs>(
      args: SelectSubset<T, LectureUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Lectures and returns the data updated in the database.
     * @param {LectureUpdateManyAndReturnArgs} args - Arguments to update many Lectures.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Lectures and only return the `id`
     * const lectureWithIdOnly = await prisma.lecture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LectureUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LectureUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LecturePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Lecture.
     * @param {LectureUpsertArgs} args - Arguments to update or create a Lecture.
     * @example
     * // Update or create a Lecture
     * const lecture = await prisma.lecture.upsert({
     *   create: {
     *     // ... data to create a Lecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture we want to update
     *   }
     * })
     */
    upsert<T extends LectureUpsertArgs>(
      args: SelectSubset<T, LectureUpsertArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      $Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lecture.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
     **/
    count<T extends LectureCountArgs>(
      args?: Subset<T, LectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LectureCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LectureAggregateArgs>(
      args: Subset<T, LectureAggregateArgs>,
    ): Prisma.PrismaPromise<GetLectureAggregateType<T>>;

    /**
     * Group by Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LectureGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureGroupByArgs["orderBy"] }
        : { orderBy?: LectureGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LectureGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetLectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Lecture model
     */
    readonly fields: LectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    ingestionBatch<T extends Lecture$ingestionBatchArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$ingestionBatchArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    scholar<T extends ScholarDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ScholarDefaultArgs<ExtArgs>>,
    ): Prisma__ScholarClient<
      | $Result.GetResult<
          Prisma.$ScholarPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    series<T extends Lecture$seriesArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$seriesArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      $Result.GetResult<
        Prisma.$SeriesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    audioAssets<T extends Lecture$audioAssetsArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$audioAssetsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    topics<T extends Lecture$topicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$topicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    progress<T extends Lecture$progressArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$progressArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserLectureProgressPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    favorites<T extends Lecture$favoritesArgs<ExtArgs> = {}>(
      args?: Subset<T, Lecture$favoritesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Lecture model
   */
  interface LectureFieldRefs {
    readonly id: FieldRef<"Lecture", "String">;
    readonly scholarId: FieldRef<"Lecture", "String">;
    readonly seriesId: FieldRef<"Lecture", "String">;
    readonly slug: FieldRef<"Lecture", "String">;
    readonly title: FieldRef<"Lecture", "String">;
    readonly description: FieldRef<"Lecture", "String">;
    readonly language: FieldRef<"Lecture", "String">;
    readonly status: FieldRef<"Lecture", "Status">;
    readonly publishedAt: FieldRef<"Lecture", "DateTime">;
    readonly orderIndex: FieldRef<"Lecture", "Int">;
    readonly durationSeconds: FieldRef<"Lecture", "Int">;
    readonly createdAt: FieldRef<"Lecture", "DateTime">;
    readonly updatedAt: FieldRef<"Lecture", "DateTime">;
    readonly deletedAt: FieldRef<"Lecture", "DateTime">;
    readonly deleteAfterAt: FieldRef<"Lecture", "DateTime">;
    readonly ingestionBatchId: FieldRef<"Lecture", "String">;
  }

  // Custom InputTypes
  /**
   * Lecture findUnique
   */
  export type LectureFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture findUniqueOrThrow
   */
  export type LectureFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture findFirst
   */
  export type LectureFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Lecture findFirstOrThrow
   */
  export type LectureFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Lecture findMany
   */
  export type LectureFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter, which Lectures to fetch.
     */
    where?: LectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Lectures.
     */
    cursor?: LectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Lectures.
     */
    skip?: number;
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[];
  };

  /**
   * Lecture create
   */
  export type LectureCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * The data needed to create a Lecture.
     */
    data: XOR<LectureCreateInput, LectureUncheckedCreateInput>;
  };

  /**
   * Lecture createMany
   */
  export type LectureCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Lecture createManyAndReturn
   */
  export type LectureCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Lecture update
   */
  export type LectureUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * The data needed to update a Lecture.
     */
    data: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>;
    /**
     * Choose, which Lecture to update.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture updateMany
   */
  export type LectureUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Lectures.
     */
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>;
    /**
     * Filter which Lectures to update
     */
    where?: LectureWhereInput;
    /**
     * Limit how many Lectures to update.
     */
    limit?: number;
  };

  /**
   * Lecture updateManyAndReturn
   */
  export type LectureUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * The data used to update Lectures.
     */
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>;
    /**
     * Filter which Lectures to update
     */
    where?: LectureWhereInput;
    /**
     * Limit how many Lectures to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Lecture upsert
   */
  export type LectureUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * The filter to search for the Lecture to update in case it exists.
     */
    where: LectureWhereUniqueInput;
    /**
     * In case the Lecture found by the `where` argument doesn't exist, create a new Lecture with this data.
     */
    create: XOR<LectureCreateInput, LectureUncheckedCreateInput>;
    /**
     * In case the Lecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>;
  };

  /**
   * Lecture delete
   */
  export type LectureDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
    /**
     * Filter which Lecture to delete.
     */
    where: LectureWhereUniqueInput;
  };

  /**
   * Lecture deleteMany
   */
  export type LectureDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Lectures to delete
     */
    where?: LectureWhereInput;
    /**
     * Limit how many Lectures to delete.
     */
    limit?: number;
  };

  /**
   * Lecture.ingestionBatch
   */
  export type Lecture$ingestionBatchArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    where?: IngestionBatchWhereInput;
  };

  /**
   * Lecture.series
   */
  export type Lecture$seriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null;
    where?: SeriesWhereInput;
  };

  /**
   * Lecture.audioAssets
   */
  export type Lecture$audioAssetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    where?: AudioAssetWhereInput;
    orderBy?: AudioAssetOrderByWithRelationInput | AudioAssetOrderByWithRelationInput[];
    cursor?: AudioAssetWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AudioAssetScalarFieldEnum | AudioAssetScalarFieldEnum[];
  };

  /**
   * Lecture.topics
   */
  export type Lecture$topicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    where?: LectureTopicWhereInput;
    orderBy?: LectureTopicOrderByWithRelationInput | LectureTopicOrderByWithRelationInput[];
    cursor?: LectureTopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LectureTopicScalarFieldEnum | LectureTopicScalarFieldEnum[];
  };

  /**
   * Lecture.progress
   */
  export type Lecture$progressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    where?: UserLectureProgressWhereInput;
    orderBy?:
      | UserLectureProgressOrderByWithRelationInput
      | UserLectureProgressOrderByWithRelationInput[];
    cursor?: UserLectureProgressWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserLectureProgressScalarFieldEnum | UserLectureProgressScalarFieldEnum[];
  };

  /**
   * Lecture.favorites
   */
  export type Lecture$favoritesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    where?: FavoriteLectureWhereInput;
    orderBy?: FavoriteLectureOrderByWithRelationInput | FavoriteLectureOrderByWithRelationInput[];
    cursor?: FavoriteLectureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FavoriteLectureScalarFieldEnum | FavoriteLectureScalarFieldEnum[];
  };

  /**
   * Lecture without action
   */
  export type LectureDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null;
  };

  /**
   * Model AudioAsset
   */

  export type AggregateAudioAsset = {
    _count: AudioAssetCountAggregateOutputType | null;
    _avg: AudioAssetAvgAggregateOutputType | null;
    _sum: AudioAssetSumAggregateOutputType | null;
    _min: AudioAssetMinAggregateOutputType | null;
    _max: AudioAssetMaxAggregateOutputType | null;
  };

  export type AudioAssetAvgAggregateOutputType = {
    bitrateKbps: number | null;
    sizeBytes: number | null;
    durationSeconds: number | null;
  };

  export type AudioAssetSumAggregateOutputType = {
    bitrateKbps: number | null;
    sizeBytes: bigint | null;
    durationSeconds: number | null;
  };

  export type AudioAssetMinAggregateOutputType = {
    id: string | null;
    lectureId: string | null;
    url: string | null;
    format: string | null;
    bitrateKbps: number | null;
    sizeBytes: bigint | null;
    durationSeconds: number | null;
    source: string | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type AudioAssetMaxAggregateOutputType = {
    id: string | null;
    lectureId: string | null;
    url: string | null;
    format: string | null;
    bitrateKbps: number | null;
    sizeBytes: bigint | null;
    durationSeconds: number | null;
    source: string | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    ingestionBatchId: string | null;
  };

  export type AudioAssetCountAggregateOutputType = {
    id: number;
    lectureId: number;
    url: number;
    format: number;
    bitrateKbps: number;
    sizeBytes: number;
    durationSeconds: number;
    source: number;
    isPrimary: number;
    createdAt: number;
    ingestionBatchId: number;
    _all: number;
  };

  export type AudioAssetAvgAggregateInputType = {
    bitrateKbps?: true;
    sizeBytes?: true;
    durationSeconds?: true;
  };

  export type AudioAssetSumAggregateInputType = {
    bitrateKbps?: true;
    sizeBytes?: true;
    durationSeconds?: true;
  };

  export type AudioAssetMinAggregateInputType = {
    id?: true;
    lectureId?: true;
    url?: true;
    format?: true;
    bitrateKbps?: true;
    sizeBytes?: true;
    durationSeconds?: true;
    source?: true;
    isPrimary?: true;
    createdAt?: true;
    ingestionBatchId?: true;
  };

  export type AudioAssetMaxAggregateInputType = {
    id?: true;
    lectureId?: true;
    url?: true;
    format?: true;
    bitrateKbps?: true;
    sizeBytes?: true;
    durationSeconds?: true;
    source?: true;
    isPrimary?: true;
    createdAt?: true;
    ingestionBatchId?: true;
  };

  export type AudioAssetCountAggregateInputType = {
    id?: true;
    lectureId?: true;
    url?: true;
    format?: true;
    bitrateKbps?: true;
    sizeBytes?: true;
    durationSeconds?: true;
    source?: true;
    isPrimary?: true;
    createdAt?: true;
    ingestionBatchId?: true;
    _all?: true;
  };

  export type AudioAssetAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AudioAsset to aggregate.
     */
    where?: AudioAssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AudioAssets to fetch.
     */
    orderBy?: AudioAssetOrderByWithRelationInput | AudioAssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AudioAssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AudioAssets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AudioAssets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AudioAssets
     **/
    _count?: true | AudioAssetCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AudioAssetAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AudioAssetSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AudioAssetMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AudioAssetMaxAggregateInputType;
  };

  export type GetAudioAssetAggregateType<T extends AudioAssetAggregateArgs> = {
    [P in keyof T & keyof AggregateAudioAsset]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioAsset[P]>
      : GetScalarType<T[P], AggregateAudioAsset[P]>;
  };

  export type AudioAssetGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AudioAssetWhereInput;
    orderBy?: AudioAssetOrderByWithAggregationInput | AudioAssetOrderByWithAggregationInput[];
    by: AudioAssetScalarFieldEnum[] | AudioAssetScalarFieldEnum;
    having?: AudioAssetScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AudioAssetCountAggregateInputType | true;
    _avg?: AudioAssetAvgAggregateInputType;
    _sum?: AudioAssetSumAggregateInputType;
    _min?: AudioAssetMinAggregateInputType;
    _max?: AudioAssetMaxAggregateInputType;
  };

  export type AudioAssetGroupByOutputType = {
    id: string;
    lectureId: string;
    url: string;
    format: string | null;
    bitrateKbps: number | null;
    sizeBytes: bigint | null;
    durationSeconds: number | null;
    source: string | null;
    isPrimary: boolean;
    createdAt: Date;
    ingestionBatchId: string | null;
    _count: AudioAssetCountAggregateOutputType | null;
    _avg: AudioAssetAvgAggregateOutputType | null;
    _sum: AudioAssetSumAggregateOutputType | null;
    _min: AudioAssetMinAggregateOutputType | null;
    _max: AudioAssetMaxAggregateOutputType | null;
  };

  type GetAudioAssetGroupByPayload<T extends AudioAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioAssetGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof AudioAssetGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AudioAssetGroupByOutputType[P]>
          : GetScalarType<T[P], AudioAssetGroupByOutputType[P]>;
      }
    >
  >;

  export type AudioAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        lectureId?: boolean;
        url?: boolean;
        format?: boolean;
        bitrateKbps?: boolean;
        sizeBytes?: boolean;
        durationSeconds?: boolean;
        source?: boolean;
        isPrimary?: boolean;
        createdAt?: boolean;
        ingestionBatchId?: boolean;
        ingestionBatch?: boolean | AudioAsset$ingestionBatchArgs<ExtArgs>;
        lecture?: boolean | LectureDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["audioAsset"]
    >;

  export type AudioAssetSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      lectureId?: boolean;
      url?: boolean;
      format?: boolean;
      bitrateKbps?: boolean;
      sizeBytes?: boolean;
      durationSeconds?: boolean;
      source?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | AudioAsset$ingestionBatchArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["audioAsset"]
  >;

  export type AudioAssetSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      lectureId?: boolean;
      url?: boolean;
      format?: boolean;
      bitrateKbps?: boolean;
      sizeBytes?: boolean;
      durationSeconds?: boolean;
      source?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      ingestionBatchId?: boolean;
      ingestionBatch?: boolean | AudioAsset$ingestionBatchArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["audioAsset"]
  >;

  export type AudioAssetSelectScalar = {
    id?: boolean;
    lectureId?: boolean;
    url?: boolean;
    format?: boolean;
    bitrateKbps?: boolean;
    sizeBytes?: boolean;
    durationSeconds?: boolean;
    source?: boolean;
    isPrimary?: boolean;
    createdAt?: boolean;
    ingestionBatchId?: boolean;
  };

  export type AudioAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "lectureId"
      | "url"
      | "format"
      | "bitrateKbps"
      | "sizeBytes"
      | "durationSeconds"
      | "source"
      | "isPrimary"
      | "createdAt"
      | "ingestionBatchId",
      ExtArgs["result"]["audioAsset"]
    >;
  export type AudioAssetInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | AudioAsset$ingestionBatchArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };
  export type AudioAssetIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | AudioAsset$ingestionBatchArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };
  export type AudioAssetIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ingestionBatch?: boolean | AudioAsset$ingestionBatchArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };

  export type $AudioAssetPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AudioAsset";
    objects: {
      ingestionBatch: Prisma.$IngestionBatchPayload<ExtArgs> | null;
      lecture: Prisma.$LecturePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        lectureId: string;
        url: string;
        format: string | null;
        bitrateKbps: number | null;
        sizeBytes: bigint | null;
        durationSeconds: number | null;
        source: string | null;
        isPrimary: boolean;
        createdAt: Date;
        ingestionBatchId: string | null;
      },
      ExtArgs["result"]["audioAsset"]
    >;
    composites: {};
  };

  type AudioAssetGetPayload<S extends boolean | null | undefined | AudioAssetDefaultArgs> =
    $Result.GetResult<Prisma.$AudioAssetPayload, S>;

  type AudioAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioAssetFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: AudioAssetCountAggregateInputType | true;
    };

  export interface AudioAssetDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AudioAsset"];
      meta: { name: "AudioAsset" };
    };
    /**
     * Find zero or one AudioAsset that matches the filter.
     * @param {AudioAssetFindUniqueArgs} args - Arguments to find a AudioAsset
     * @example
     * // Get one AudioAsset
     * const audioAsset = await prisma.audioAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioAssetFindUniqueArgs>(
      args: SelectSubset<T, AudioAssetFindUniqueArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<
        Prisma.$AudioAssetPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AudioAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioAssetFindUniqueOrThrowArgs} args - Arguments to find a AudioAsset
     * @example
     * // Get one AudioAsset
     * const audioAsset = await prisma.audioAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioAssetFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AudioAssetFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<
        Prisma.$AudioAssetPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AudioAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetFindFirstArgs} args - Arguments to find a AudioAsset
     * @example
     * // Get one AudioAsset
     * const audioAsset = await prisma.audioAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioAssetFindFirstArgs>(
      args?: SelectSubset<T, AudioAssetFindFirstArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<
        Prisma.$AudioAssetPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AudioAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetFindFirstOrThrowArgs} args - Arguments to find a AudioAsset
     * @example
     * // Get one AudioAsset
     * const audioAsset = await prisma.audioAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioAssetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AudioAssetFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<
        Prisma.$AudioAssetPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AudioAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioAssets
     * const audioAssets = await prisma.audioAsset.findMany()
     *
     * // Get first 10 AudioAssets
     * const audioAssets = await prisma.audioAsset.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const audioAssetWithIdOnly = await prisma.audioAsset.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AudioAssetFindManyArgs>(
      args?: SelectSubset<T, AudioAssetFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a AudioAsset.
     * @param {AudioAssetCreateArgs} args - Arguments to create a AudioAsset.
     * @example
     * // Create one AudioAsset
     * const AudioAsset = await prisma.audioAsset.create({
     *   data: {
     *     // ... data to create a AudioAsset
     *   }
     * })
     *
     */
    create<T extends AudioAssetCreateArgs>(
      args: SelectSubset<T, AudioAssetCreateArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AudioAssets.
     * @param {AudioAssetCreateManyArgs} args - Arguments to create many AudioAssets.
     * @example
     * // Create many AudioAssets
     * const audioAsset = await prisma.audioAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AudioAssetCreateManyArgs>(
      args?: SelectSubset<T, AudioAssetCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AudioAssets and returns the data saved in the database.
     * @param {AudioAssetCreateManyAndReturnArgs} args - Arguments to create many AudioAssets.
     * @example
     * // Create many AudioAssets
     * const audioAsset = await prisma.audioAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AudioAssets and only return the `id`
     * const audioAssetWithIdOnly = await prisma.audioAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AudioAssetCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AudioAssetCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AudioAssetPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AudioAsset.
     * @param {AudioAssetDeleteArgs} args - Arguments to delete one AudioAsset.
     * @example
     * // Delete one AudioAsset
     * const AudioAsset = await prisma.audioAsset.delete({
     *   where: {
     *     // ... filter to delete one AudioAsset
     *   }
     * })
     *
     */
    delete<T extends AudioAssetDeleteArgs>(
      args: SelectSubset<T, AudioAssetDeleteArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AudioAsset.
     * @param {AudioAssetUpdateArgs} args - Arguments to update one AudioAsset.
     * @example
     * // Update one AudioAsset
     * const audioAsset = await prisma.audioAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AudioAssetUpdateArgs>(
      args: SelectSubset<T, AudioAssetUpdateArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AudioAssets.
     * @param {AudioAssetDeleteManyArgs} args - Arguments to filter AudioAssets to delete.
     * @example
     * // Delete a few AudioAssets
     * const { count } = await prisma.audioAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AudioAssetDeleteManyArgs>(
      args?: SelectSubset<T, AudioAssetDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AudioAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioAssets
     * const audioAsset = await prisma.audioAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AudioAssetUpdateManyArgs>(
      args: SelectSubset<T, AudioAssetUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AudioAssets and returns the data updated in the database.
     * @param {AudioAssetUpdateManyAndReturnArgs} args - Arguments to update many AudioAssets.
     * @example
     * // Update many AudioAssets
     * const audioAsset = await prisma.audioAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AudioAssets and only return the `id`
     * const audioAssetWithIdOnly = await prisma.audioAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AudioAssetUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AudioAssetUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AudioAssetPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AudioAsset.
     * @param {AudioAssetUpsertArgs} args - Arguments to update or create a AudioAsset.
     * @example
     * // Update or create a AudioAsset
     * const audioAsset = await prisma.audioAsset.upsert({
     *   create: {
     *     // ... data to create a AudioAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioAsset we want to update
     *   }
     * })
     */
    upsert<T extends AudioAssetUpsertArgs>(
      args: SelectSubset<T, AudioAssetUpsertArgs<ExtArgs>>,
    ): Prisma__AudioAssetClient<
      $Result.GetResult<Prisma.$AudioAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AudioAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetCountArgs} args - Arguments to filter AudioAssets to count.
     * @example
     * // Count the number of AudioAssets
     * const count = await prisma.audioAsset.count({
     *   where: {
     *     // ... the filter for the AudioAssets we want to count
     *   }
     * })
     **/
    count<T extends AudioAssetCountArgs>(
      args?: Subset<T, AudioAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AudioAssetCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AudioAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AudioAssetAggregateArgs>(
      args: Subset<T, AudioAssetAggregateArgs>,
    ): Prisma.PrismaPromise<GetAudioAssetAggregateType<T>>;

    /**
     * Group by AudioAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AudioAssetGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioAssetGroupByArgs["orderBy"] }
        : { orderBy?: AudioAssetGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AudioAssetGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetAudioAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AudioAsset model
     */
    readonly fields: AudioAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioAssetClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    ingestionBatch<T extends AudioAsset$ingestionBatchArgs<ExtArgs> = {}>(
      args?: Subset<T, AudioAsset$ingestionBatchArgs<ExtArgs>>,
    ): Prisma__IngestionBatchClient<
      $Result.GetResult<
        Prisma.$IngestionBatchPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LectureDefaultArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      | $Result.GetResult<
          Prisma.$LecturePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AudioAsset model
   */
  interface AudioAssetFieldRefs {
    readonly id: FieldRef<"AudioAsset", "String">;
    readonly lectureId: FieldRef<"AudioAsset", "String">;
    readonly url: FieldRef<"AudioAsset", "String">;
    readonly format: FieldRef<"AudioAsset", "String">;
    readonly bitrateKbps: FieldRef<"AudioAsset", "Int">;
    readonly sizeBytes: FieldRef<"AudioAsset", "BigInt">;
    readonly durationSeconds: FieldRef<"AudioAsset", "Int">;
    readonly source: FieldRef<"AudioAsset", "String">;
    readonly isPrimary: FieldRef<"AudioAsset", "Boolean">;
    readonly createdAt: FieldRef<"AudioAsset", "DateTime">;
    readonly ingestionBatchId: FieldRef<"AudioAsset", "String">;
  }

  // Custom InputTypes
  /**
   * AudioAsset findUnique
   */
  export type AudioAssetFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * Filter, which AudioAsset to fetch.
     */
    where: AudioAssetWhereUniqueInput;
  };

  /**
   * AudioAsset findUniqueOrThrow
   */
  export type AudioAssetFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * Filter, which AudioAsset to fetch.
     */
    where: AudioAssetWhereUniqueInput;
  };

  /**
   * AudioAsset findFirst
   */
  export type AudioAssetFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * Filter, which AudioAsset to fetch.
     */
    where?: AudioAssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AudioAssets to fetch.
     */
    orderBy?: AudioAssetOrderByWithRelationInput | AudioAssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AudioAssets.
     */
    cursor?: AudioAssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AudioAssets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AudioAssets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AudioAssets.
     */
    distinct?: AudioAssetScalarFieldEnum | AudioAssetScalarFieldEnum[];
  };

  /**
   * AudioAsset findFirstOrThrow
   */
  export type AudioAssetFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * Filter, which AudioAsset to fetch.
     */
    where?: AudioAssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AudioAssets to fetch.
     */
    orderBy?: AudioAssetOrderByWithRelationInput | AudioAssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AudioAssets.
     */
    cursor?: AudioAssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AudioAssets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AudioAssets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AudioAssets.
     */
    distinct?: AudioAssetScalarFieldEnum | AudioAssetScalarFieldEnum[];
  };

  /**
   * AudioAsset findMany
   */
  export type AudioAssetFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * Filter, which AudioAssets to fetch.
     */
    where?: AudioAssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AudioAssets to fetch.
     */
    orderBy?: AudioAssetOrderByWithRelationInput | AudioAssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AudioAssets.
     */
    cursor?: AudioAssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AudioAssets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AudioAssets.
     */
    skip?: number;
    distinct?: AudioAssetScalarFieldEnum | AudioAssetScalarFieldEnum[];
  };

  /**
   * AudioAsset create
   */
  export type AudioAssetCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * The data needed to create a AudioAsset.
     */
    data: XOR<AudioAssetCreateInput, AudioAssetUncheckedCreateInput>;
  };

  /**
   * AudioAsset createMany
   */
  export type AudioAssetCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AudioAssets.
     */
    data: AudioAssetCreateManyInput | AudioAssetCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AudioAsset createManyAndReturn
   */
  export type AudioAssetCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * The data used to create many AudioAssets.
     */
    data: AudioAssetCreateManyInput | AudioAssetCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AudioAsset update
   */
  export type AudioAssetUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * The data needed to update a AudioAsset.
     */
    data: XOR<AudioAssetUpdateInput, AudioAssetUncheckedUpdateInput>;
    /**
     * Choose, which AudioAsset to update.
     */
    where: AudioAssetWhereUniqueInput;
  };

  /**
   * AudioAsset updateMany
   */
  export type AudioAssetUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AudioAssets.
     */
    data: XOR<AudioAssetUpdateManyMutationInput, AudioAssetUncheckedUpdateManyInput>;
    /**
     * Filter which AudioAssets to update
     */
    where?: AudioAssetWhereInput;
    /**
     * Limit how many AudioAssets to update.
     */
    limit?: number;
  };

  /**
   * AudioAsset updateManyAndReturn
   */
  export type AudioAssetUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * The data used to update AudioAssets.
     */
    data: XOR<AudioAssetUpdateManyMutationInput, AudioAssetUncheckedUpdateManyInput>;
    /**
     * Filter which AudioAssets to update
     */
    where?: AudioAssetWhereInput;
    /**
     * Limit how many AudioAssets to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AudioAsset upsert
   */
  export type AudioAssetUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * The filter to search for the AudioAsset to update in case it exists.
     */
    where: AudioAssetWhereUniqueInput;
    /**
     * In case the AudioAsset found by the `where` argument doesn't exist, create a new AudioAsset with this data.
     */
    create: XOR<AudioAssetCreateInput, AudioAssetUncheckedCreateInput>;
    /**
     * In case the AudioAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioAssetUpdateInput, AudioAssetUncheckedUpdateInput>;
  };

  /**
   * AudioAsset delete
   */
  export type AudioAssetDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
    /**
     * Filter which AudioAsset to delete.
     */
    where: AudioAssetWhereUniqueInput;
  };

  /**
   * AudioAsset deleteMany
   */
  export type AudioAssetDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AudioAssets to delete
     */
    where?: AudioAssetWhereInput;
    /**
     * Limit how many AudioAssets to delete.
     */
    limit?: number;
  };

  /**
   * AudioAsset.ingestionBatch
   */
  export type AudioAsset$ingestionBatchArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestionBatch
     */
    select?: IngestionBatchSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IngestionBatch
     */
    omit?: IngestionBatchOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionBatchInclude<ExtArgs> | null;
    where?: IngestionBatchWhereInput;
  };

  /**
   * AudioAsset without action
   */
  export type AudioAssetDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioAsset
     */
    select?: AudioAssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AudioAsset
     */
    omit?: AudioAssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAssetInclude<ExtArgs> | null;
  };

  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null;
    _min: TopicMinAggregateOutputType | null;
    _max: TopicMaxAggregateOutputType | null;
  };

  export type TopicMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    name: string | null;
    parentId: string | null;
    createdAt: Date | null;
  };

  export type TopicMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    name: string | null;
    parentId: string | null;
    createdAt: Date | null;
  };

  export type TopicCountAggregateOutputType = {
    id: number;
    slug: number;
    name: number;
    parentId: number;
    createdAt: number;
    _all: number;
  };

  export type TopicMinAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    parentId?: true;
    createdAt?: true;
  };

  export type TopicMaxAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    parentId?: true;
    createdAt?: true;
  };

  export type TopicCountAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    parentId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type TopicAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Topics
     **/
    _count?: true | TopicCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TopicMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TopicMaxAggregateInputType;
  };

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
    [P in keyof T & keyof AggregateTopic]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>;
  };

  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[];
      by: TopicScalarFieldEnum[] | TopicScalarFieldEnum;
      having?: TopicScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TopicCountAggregateInputType | true;
      _min?: TopicMinAggregateInputType;
      _max?: TopicMaxAggregateInputType;
    };

  export type TopicGroupByOutputType = {
    id: string;
    slug: string;
    name: string;
    parentId: string | null;
    createdAt: Date;
    _count: TopicCountAggregateOutputType | null;
    _min: TopicMinAggregateOutputType | null;
    _max: TopicMaxAggregateOutputType | null;
  };

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof TopicGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
          : GetScalarType<T[P], TopicGroupByOutputType[P]>;
      }
    >
  >;

  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        slug?: boolean;
        name?: boolean;
        parentId?: boolean;
        createdAt?: boolean;
        parent?: boolean | Topic$parentArgs<ExtArgs>;
        children?: boolean | Topic$childrenArgs<ExtArgs>;
        lectureTopics?: boolean | Topic$lectureTopicsArgs<ExtArgs>;
        seriesTopics?: boolean | Topic$seriesTopicsArgs<ExtArgs>;
        collectionTopics?: boolean | Topic$collectionTopicsArgs<ExtArgs>;
        _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["topic"]
    >;

  export type TopicSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      name?: boolean;
      parentId?: boolean;
      createdAt?: boolean;
      parent?: boolean | Topic$parentArgs<ExtArgs>;
    },
    ExtArgs["result"]["topic"]
  >;

  export type TopicSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      name?: boolean;
      parentId?: boolean;
      createdAt?: boolean;
      parent?: boolean | Topic$parentArgs<ExtArgs>;
    },
    ExtArgs["result"]["topic"]
  >;

  export type TopicSelectScalar = {
    id?: boolean;
    slug?: boolean;
    name?: boolean;
    parentId?: boolean;
    createdAt?: boolean;
  };

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "slug" | "name" | "parentId" | "createdAt",
      ExtArgs["result"]["topic"]
    >;
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Topic$parentArgs<ExtArgs>;
    children?: boolean | Topic$childrenArgs<ExtArgs>;
    lectureTopics?: boolean | Topic$lectureTopicsArgs<ExtArgs>;
    seriesTopics?: boolean | Topic$seriesTopicsArgs<ExtArgs>;
    collectionTopics?: boolean | Topic$collectionTopicsArgs<ExtArgs>;
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TopicIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Topic$parentArgs<ExtArgs>;
  };
  export type TopicIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Topic$parentArgs<ExtArgs>;
  };

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic";
    objects: {
      parent: Prisma.$TopicPayload<ExtArgs> | null;
      children: Prisma.$TopicPayload<ExtArgs>[];
      lectureTopics: Prisma.$LectureTopicPayload<ExtArgs>[];
      seriesTopics: Prisma.$SeriesTopicPayload<ExtArgs>[];
      collectionTopics: Prisma.$CollectionTopicPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        slug: string;
        name: string;
        parentId: string | null;
        createdAt: Date;
      },
      ExtArgs["result"]["topic"]
    >;
    composites: {};
  };

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<
    Prisma.$TopicPayload,
    S
  >;

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    TopicFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TopicCountAggregateInputType | true;
  };

  export interface TopicDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Topic"]; meta: { name: "Topic" } };
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(
      args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(
      args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     *
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TopicFindManyArgs>(
      args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     *
     */
    create<T extends TopicCreateArgs>(
      args: SelectSubset<T, TopicCreateArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TopicCreateManyArgs>(
      args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     *
     */
    delete<T extends TopicDeleteArgs>(
      args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TopicUpdateArgs>(
      args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TopicDeleteManyArgs>(
      args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TopicUpdateManyArgs>(
      args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(
      args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
     **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TopicCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TopicAggregateArgs>(
      args: Subset<T, TopicAggregateArgs>,
    ): Prisma.PrismaPromise<GetTopicAggregateType<T>>;

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs["orderBy"] }
        : { orderBy?: TopicGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Topic model
     */
    readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    parent<T extends Topic$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$parentArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    children<T extends Topic$childrenArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$childrenArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    lectureTopics<T extends Topic$lectureTopicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$lectureTopicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    seriesTopics<T extends Topic$seriesTopicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$seriesTopicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    collectionTopics<T extends Topic$collectionTopicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$collectionTopicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", "String">;
    readonly slug: FieldRef<"Topic", "String">;
    readonly name: FieldRef<"Topic", "String">;
    readonly parentId: FieldRef<"Topic", "String">;
    readonly createdAt: FieldRef<"Topic", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput;
  };

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput;
  };

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Topic
       */
      select?: TopicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Topic
       */
      omit?: TopicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TopicInclude<ExtArgs> | null;
      /**
       * The data needed to create a Topic.
       */
      data: XOR<TopicCreateInput, TopicUncheckedCreateInput>;
    };

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Topic
       */
      select?: TopicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Topic
       */
      omit?: TopicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TopicInclude<ExtArgs> | null;
      /**
       * The data needed to update a Topic.
       */
      data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>;
      /**
       * Choose, which Topic to update.
       */
      where: TopicWhereUniqueInput;
    };

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>;
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput;
    /**
     * Limit how many Topics to update.
     */
    limit?: number;
  };

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>;
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput;
    /**
     * Limit how many Topics to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Topic
       */
      select?: TopicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Topic
       */
      omit?: TopicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TopicInclude<ExtArgs> | null;
      /**
       * The filter to search for the Topic to update in case it exists.
       */
      where: TopicWhereUniqueInput;
      /**
       * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
       */
      create: XOR<TopicCreateInput, TopicUncheckedCreateInput>;
      /**
       * In case the Topic was found with the provided `where` argument, update it with this data.
       */
      update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>;
    };

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Topic
       */
      select?: TopicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Topic
       */
      omit?: TopicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TopicInclude<ExtArgs> | null;
      /**
       * Filter which Topic to delete.
       */
      where: TopicWhereUniqueInput;
    };

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput;
    /**
     * Limit how many Topics to delete.
     */
    limit?: number;
  };

  /**
   * Topic.parent
   */
  export type Topic$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Topic
       */
      select?: TopicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Topic
       */
      omit?: TopicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TopicInclude<ExtArgs> | null;
      where?: TopicWhereInput;
    };

  /**
   * Topic.children
   */
  export type Topic$childrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    where?: TopicWhereInput;
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    cursor?: TopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic.lectureTopics
   */
  export type Topic$lectureTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    where?: LectureTopicWhereInput;
    orderBy?: LectureTopicOrderByWithRelationInput | LectureTopicOrderByWithRelationInput[];
    cursor?: LectureTopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LectureTopicScalarFieldEnum | LectureTopicScalarFieldEnum[];
  };

  /**
   * Topic.seriesTopics
   */
  export type Topic$seriesTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    where?: SeriesTopicWhereInput;
    orderBy?: SeriesTopicOrderByWithRelationInput | SeriesTopicOrderByWithRelationInput[];
    cursor?: SeriesTopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SeriesTopicScalarFieldEnum | SeriesTopicScalarFieldEnum[];
  };

  /**
   * Topic.collectionTopics
   */
  export type Topic$collectionTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    where?: CollectionTopicWhereInput;
    orderBy?: CollectionTopicOrderByWithRelationInput | CollectionTopicOrderByWithRelationInput[];
    cursor?: CollectionTopicWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CollectionTopicScalarFieldEnum | CollectionTopicScalarFieldEnum[];
  };

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Topic
       */
      select?: TopicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Topic
       */
      omit?: TopicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TopicInclude<ExtArgs> | null;
    };

  /**
   * Model LectureTopic
   */

  export type AggregateLectureTopic = {
    _count: LectureTopicCountAggregateOutputType | null;
    _min: LectureTopicMinAggregateOutputType | null;
    _max: LectureTopicMaxAggregateOutputType | null;
  };

  export type LectureTopicMinAggregateOutputType = {
    lectureId: string | null;
    topicId: string | null;
    createdAt: Date | null;
  };

  export type LectureTopicMaxAggregateOutputType = {
    lectureId: string | null;
    topicId: string | null;
    createdAt: Date | null;
  };

  export type LectureTopicCountAggregateOutputType = {
    lectureId: number;
    topicId: number;
    createdAt: number;
    _all: number;
  };

  export type LectureTopicMinAggregateInputType = {
    lectureId?: true;
    topicId?: true;
    createdAt?: true;
  };

  export type LectureTopicMaxAggregateInputType = {
    lectureId?: true;
    topicId?: true;
    createdAt?: true;
  };

  export type LectureTopicCountAggregateInputType = {
    lectureId?: true;
    topicId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type LectureTopicAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LectureTopic to aggregate.
     */
    where?: LectureTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LectureTopics to fetch.
     */
    orderBy?: LectureTopicOrderByWithRelationInput | LectureTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LectureTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LectureTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LectureTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LectureTopics
     **/
    _count?: true | LectureTopicCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LectureTopicMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LectureTopicMaxAggregateInputType;
  };

  export type GetLectureTopicAggregateType<T extends LectureTopicAggregateArgs> = {
    [P in keyof T & keyof AggregateLectureTopic]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLectureTopic[P]>
      : GetScalarType<T[P], AggregateLectureTopic[P]>;
  };

  export type LectureTopicGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LectureTopicWhereInput;
    orderBy?: LectureTopicOrderByWithAggregationInput | LectureTopicOrderByWithAggregationInput[];
    by: LectureTopicScalarFieldEnum[] | LectureTopicScalarFieldEnum;
    having?: LectureTopicScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LectureTopicCountAggregateInputType | true;
    _min?: LectureTopicMinAggregateInputType;
    _max?: LectureTopicMaxAggregateInputType;
  };

  export type LectureTopicGroupByOutputType = {
    lectureId: string;
    topicId: string;
    createdAt: Date;
    _count: LectureTopicCountAggregateOutputType | null;
    _min: LectureTopicMinAggregateOutputType | null;
    _max: LectureTopicMaxAggregateOutputType | null;
  };

  type GetLectureTopicGroupByPayload<T extends LectureTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LectureTopicGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof LectureTopicGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], LectureTopicGroupByOutputType[P]>
          : GetScalarType<T[P], LectureTopicGroupByOutputType[P]>;
      }
    >
  >;

  export type LectureTopicSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      lectureId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lectureTopic"]
  >;

  export type LectureTopicSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      lectureId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lectureTopic"]
  >;

  export type LectureTopicSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      lectureId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lectureTopic"]
  >;

  export type LectureTopicSelectScalar = {
    lectureId?: boolean;
    topicId?: boolean;
    createdAt?: boolean;
  };

  export type LectureTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<"lectureId" | "topicId" | "createdAt", ExtArgs["result"]["lectureTopic"]>;
  export type LectureTopicInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };
  export type LectureTopicIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };
  export type LectureTopicIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };

  export type $LectureTopicPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "LectureTopic";
    objects: {
      lecture: Prisma.$LecturePayload<ExtArgs>;
      topic: Prisma.$TopicPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        lectureId: string;
        topicId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["lectureTopic"]
    >;
    composites: {};
  };

  type LectureTopicGetPayload<S extends boolean | null | undefined | LectureTopicDefaultArgs> =
    $Result.GetResult<Prisma.$LectureTopicPayload, S>;

  type LectureTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LectureTopicFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: LectureTopicCountAggregateInputType | true;
    };

  export interface LectureTopicDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LectureTopic"];
      meta: { name: "LectureTopic" };
    };
    /**
     * Find zero or one LectureTopic that matches the filter.
     * @param {LectureTopicFindUniqueArgs} args - Arguments to find a LectureTopic
     * @example
     * // Get one LectureTopic
     * const lectureTopic = await prisma.lectureTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureTopicFindUniqueArgs>(
      args: SelectSubset<T, LectureTopicFindUniqueArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<
        Prisma.$LectureTopicPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LectureTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LectureTopicFindUniqueOrThrowArgs} args - Arguments to find a LectureTopic
     * @example
     * // Get one LectureTopic
     * const lectureTopic = await prisma.lectureTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureTopicFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LectureTopicFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<
        Prisma.$LectureTopicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LectureTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicFindFirstArgs} args - Arguments to find a LectureTopic
     * @example
     * // Get one LectureTopic
     * const lectureTopic = await prisma.lectureTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureTopicFindFirstArgs>(
      args?: SelectSubset<T, LectureTopicFindFirstArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<
        Prisma.$LectureTopicPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LectureTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicFindFirstOrThrowArgs} args - Arguments to find a LectureTopic
     * @example
     * // Get one LectureTopic
     * const lectureTopic = await prisma.lectureTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureTopicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LectureTopicFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<
        Prisma.$LectureTopicPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LectureTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LectureTopics
     * const lectureTopics = await prisma.lectureTopic.findMany()
     *
     * // Get first 10 LectureTopics
     * const lectureTopics = await prisma.lectureTopic.findMany({ take: 10 })
     *
     * // Only select the `lectureId`
     * const lectureTopicWithLectureIdOnly = await prisma.lectureTopic.findMany({ select: { lectureId: true } })
     *
     */
    findMany<T extends LectureTopicFindManyArgs>(
      args?: SelectSubset<T, LectureTopicFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a LectureTopic.
     * @param {LectureTopicCreateArgs} args - Arguments to create a LectureTopic.
     * @example
     * // Create one LectureTopic
     * const LectureTopic = await prisma.lectureTopic.create({
     *   data: {
     *     // ... data to create a LectureTopic
     *   }
     * })
     *
     */
    create<T extends LectureTopicCreateArgs>(
      args: SelectSubset<T, LectureTopicCreateArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LectureTopics.
     * @param {LectureTopicCreateManyArgs} args - Arguments to create many LectureTopics.
     * @example
     * // Create many LectureTopics
     * const lectureTopic = await prisma.lectureTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LectureTopicCreateManyArgs>(
      args?: SelectSubset<T, LectureTopicCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LectureTopics and returns the data saved in the database.
     * @param {LectureTopicCreateManyAndReturnArgs} args - Arguments to create many LectureTopics.
     * @example
     * // Create many LectureTopics
     * const lectureTopic = await prisma.lectureTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LectureTopics and only return the `lectureId`
     * const lectureTopicWithLectureIdOnly = await prisma.lectureTopic.createManyAndReturn({
     *   select: { lectureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LectureTopicCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LectureTopicCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LectureTopicPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a LectureTopic.
     * @param {LectureTopicDeleteArgs} args - Arguments to delete one LectureTopic.
     * @example
     * // Delete one LectureTopic
     * const LectureTopic = await prisma.lectureTopic.delete({
     *   where: {
     *     // ... filter to delete one LectureTopic
     *   }
     * })
     *
     */
    delete<T extends LectureTopicDeleteArgs>(
      args: SelectSubset<T, LectureTopicDeleteArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LectureTopic.
     * @param {LectureTopicUpdateArgs} args - Arguments to update one LectureTopic.
     * @example
     * // Update one LectureTopic
     * const lectureTopic = await prisma.lectureTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LectureTopicUpdateArgs>(
      args: SelectSubset<T, LectureTopicUpdateArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LectureTopics.
     * @param {LectureTopicDeleteManyArgs} args - Arguments to filter LectureTopics to delete.
     * @example
     * // Delete a few LectureTopics
     * const { count } = await prisma.lectureTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LectureTopicDeleteManyArgs>(
      args?: SelectSubset<T, LectureTopicDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LectureTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LectureTopics
     * const lectureTopic = await prisma.lectureTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LectureTopicUpdateManyArgs>(
      args: SelectSubset<T, LectureTopicUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LectureTopics and returns the data updated in the database.
     * @param {LectureTopicUpdateManyAndReturnArgs} args - Arguments to update many LectureTopics.
     * @example
     * // Update many LectureTopics
     * const lectureTopic = await prisma.lectureTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LectureTopics and only return the `lectureId`
     * const lectureTopicWithLectureIdOnly = await prisma.lectureTopic.updateManyAndReturn({
     *   select: { lectureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LectureTopicUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LectureTopicUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LectureTopicPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one LectureTopic.
     * @param {LectureTopicUpsertArgs} args - Arguments to update or create a LectureTopic.
     * @example
     * // Update or create a LectureTopic
     * const lectureTopic = await prisma.lectureTopic.upsert({
     *   create: {
     *     // ... data to create a LectureTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LectureTopic we want to update
     *   }
     * })
     */
    upsert<T extends LectureTopicUpsertArgs>(
      args: SelectSubset<T, LectureTopicUpsertArgs<ExtArgs>>,
    ): Prisma__LectureTopicClient<
      $Result.GetResult<Prisma.$LectureTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LectureTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicCountArgs} args - Arguments to filter LectureTopics to count.
     * @example
     * // Count the number of LectureTopics
     * const count = await prisma.lectureTopic.count({
     *   where: {
     *     // ... the filter for the LectureTopics we want to count
     *   }
     * })
     **/
    count<T extends LectureTopicCountArgs>(
      args?: Subset<T, LectureTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LectureTopicCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LectureTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LectureTopicAggregateArgs>(
      args: Subset<T, LectureTopicAggregateArgs>,
    ): Prisma.PrismaPromise<GetLectureTopicAggregateType<T>>;

    /**
     * Group by LectureTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LectureTopicGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureTopicGroupByArgs["orderBy"] }
        : { orderBy?: LectureTopicGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LectureTopicGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetLectureTopicGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LectureTopic model
     */
    readonly fields: LectureTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LectureTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureTopicClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LectureDefaultArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      | $Result.GetResult<
          Prisma.$LecturePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TopicDefaultArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      | $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LectureTopic model
   */
  interface LectureTopicFieldRefs {
    readonly lectureId: FieldRef<"LectureTopic", "String">;
    readonly topicId: FieldRef<"LectureTopic", "String">;
    readonly createdAt: FieldRef<"LectureTopic", "DateTime">;
  }

  // Custom InputTypes
  /**
   * LectureTopic findUnique
   */
  export type LectureTopicFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * Filter, which LectureTopic to fetch.
     */
    where: LectureTopicWhereUniqueInput;
  };

  /**
   * LectureTopic findUniqueOrThrow
   */
  export type LectureTopicFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * Filter, which LectureTopic to fetch.
     */
    where: LectureTopicWhereUniqueInput;
  };

  /**
   * LectureTopic findFirst
   */
  export type LectureTopicFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * Filter, which LectureTopic to fetch.
     */
    where?: LectureTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LectureTopics to fetch.
     */
    orderBy?: LectureTopicOrderByWithRelationInput | LectureTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LectureTopics.
     */
    cursor?: LectureTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LectureTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LectureTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LectureTopics.
     */
    distinct?: LectureTopicScalarFieldEnum | LectureTopicScalarFieldEnum[];
  };

  /**
   * LectureTopic findFirstOrThrow
   */
  export type LectureTopicFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * Filter, which LectureTopic to fetch.
     */
    where?: LectureTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LectureTopics to fetch.
     */
    orderBy?: LectureTopicOrderByWithRelationInput | LectureTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LectureTopics.
     */
    cursor?: LectureTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LectureTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LectureTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LectureTopics.
     */
    distinct?: LectureTopicScalarFieldEnum | LectureTopicScalarFieldEnum[];
  };

  /**
   * LectureTopic findMany
   */
  export type LectureTopicFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * Filter, which LectureTopics to fetch.
     */
    where?: LectureTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LectureTopics to fetch.
     */
    orderBy?: LectureTopicOrderByWithRelationInput | LectureTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LectureTopics.
     */
    cursor?: LectureTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LectureTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LectureTopics.
     */
    skip?: number;
    distinct?: LectureTopicScalarFieldEnum | LectureTopicScalarFieldEnum[];
  };

  /**
   * LectureTopic create
   */
  export type LectureTopicCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * The data needed to create a LectureTopic.
     */
    data: XOR<LectureTopicCreateInput, LectureTopicUncheckedCreateInput>;
  };

  /**
   * LectureTopic createMany
   */
  export type LectureTopicCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LectureTopics.
     */
    data: LectureTopicCreateManyInput | LectureTopicCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LectureTopic createManyAndReturn
   */
  export type LectureTopicCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * The data used to create many LectureTopics.
     */
    data: LectureTopicCreateManyInput | LectureTopicCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LectureTopic update
   */
  export type LectureTopicUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * The data needed to update a LectureTopic.
     */
    data: XOR<LectureTopicUpdateInput, LectureTopicUncheckedUpdateInput>;
    /**
     * Choose, which LectureTopic to update.
     */
    where: LectureTopicWhereUniqueInput;
  };

  /**
   * LectureTopic updateMany
   */
  export type LectureTopicUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LectureTopics.
     */
    data: XOR<LectureTopicUpdateManyMutationInput, LectureTopicUncheckedUpdateManyInput>;
    /**
     * Filter which LectureTopics to update
     */
    where?: LectureTopicWhereInput;
    /**
     * Limit how many LectureTopics to update.
     */
    limit?: number;
  };

  /**
   * LectureTopic updateManyAndReturn
   */
  export type LectureTopicUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * The data used to update LectureTopics.
     */
    data: XOR<LectureTopicUpdateManyMutationInput, LectureTopicUncheckedUpdateManyInput>;
    /**
     * Filter which LectureTopics to update
     */
    where?: LectureTopicWhereInput;
    /**
     * Limit how many LectureTopics to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LectureTopic upsert
   */
  export type LectureTopicUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * The filter to search for the LectureTopic to update in case it exists.
     */
    where: LectureTopicWhereUniqueInput;
    /**
     * In case the LectureTopic found by the `where` argument doesn't exist, create a new LectureTopic with this data.
     */
    create: XOR<LectureTopicCreateInput, LectureTopicUncheckedCreateInput>;
    /**
     * In case the LectureTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureTopicUpdateInput, LectureTopicUncheckedUpdateInput>;
  };

  /**
   * LectureTopic delete
   */
  export type LectureTopicDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
    /**
     * Filter which LectureTopic to delete.
     */
    where: LectureTopicWhereUniqueInput;
  };

  /**
   * LectureTopic deleteMany
   */
  export type LectureTopicDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LectureTopics to delete
     */
    where?: LectureTopicWhereInput;
    /**
     * Limit how many LectureTopics to delete.
     */
    limit?: number;
  };

  /**
   * LectureTopic without action
   */
  export type LectureTopicDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LectureTopic
     */
    select?: LectureTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LectureTopic
     */
    omit?: LectureTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureTopicInclude<ExtArgs> | null;
  };

  /**
   * Model SeriesTopic
   */

  export type AggregateSeriesTopic = {
    _count: SeriesTopicCountAggregateOutputType | null;
    _min: SeriesTopicMinAggregateOutputType | null;
    _max: SeriesTopicMaxAggregateOutputType | null;
  };

  export type SeriesTopicMinAggregateOutputType = {
    seriesId: string | null;
    topicId: string | null;
    createdAt: Date | null;
  };

  export type SeriesTopicMaxAggregateOutputType = {
    seriesId: string | null;
    topicId: string | null;
    createdAt: Date | null;
  };

  export type SeriesTopicCountAggregateOutputType = {
    seriesId: number;
    topicId: number;
    createdAt: number;
    _all: number;
  };

  export type SeriesTopicMinAggregateInputType = {
    seriesId?: true;
    topicId?: true;
    createdAt?: true;
  };

  export type SeriesTopicMaxAggregateInputType = {
    seriesId?: true;
    topicId?: true;
    createdAt?: true;
  };

  export type SeriesTopicCountAggregateInputType = {
    seriesId?: true;
    topicId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type SeriesTopicAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SeriesTopic to aggregate.
     */
    where?: SeriesTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SeriesTopics to fetch.
     */
    orderBy?: SeriesTopicOrderByWithRelationInput | SeriesTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SeriesTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SeriesTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SeriesTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SeriesTopics
     **/
    _count?: true | SeriesTopicCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SeriesTopicMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SeriesTopicMaxAggregateInputType;
  };

  export type GetSeriesTopicAggregateType<T extends SeriesTopicAggregateArgs> = {
    [P in keyof T & keyof AggregateSeriesTopic]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeriesTopic[P]>
      : GetScalarType<T[P], AggregateSeriesTopic[P]>;
  };

  export type SeriesTopicGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SeriesTopicWhereInput;
    orderBy?: SeriesTopicOrderByWithAggregationInput | SeriesTopicOrderByWithAggregationInput[];
    by: SeriesTopicScalarFieldEnum[] | SeriesTopicScalarFieldEnum;
    having?: SeriesTopicScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SeriesTopicCountAggregateInputType | true;
    _min?: SeriesTopicMinAggregateInputType;
    _max?: SeriesTopicMaxAggregateInputType;
  };

  export type SeriesTopicGroupByOutputType = {
    seriesId: string;
    topicId: string;
    createdAt: Date;
    _count: SeriesTopicCountAggregateOutputType | null;
    _min: SeriesTopicMinAggregateOutputType | null;
    _max: SeriesTopicMaxAggregateOutputType | null;
  };

  type GetSeriesTopicGroupByPayload<T extends SeriesTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesTopicGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof SeriesTopicGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SeriesTopicGroupByOutputType[P]>
          : GetScalarType<T[P], SeriesTopicGroupByOutputType[P]>;
      }
    >
  >;

  export type SeriesTopicSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      seriesId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      series?: boolean | SeriesDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["seriesTopic"]
  >;

  export type SeriesTopicSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      seriesId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      series?: boolean | SeriesDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["seriesTopic"]
  >;

  export type SeriesTopicSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      seriesId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      series?: boolean | SeriesDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["seriesTopic"]
  >;

  export type SeriesTopicSelectScalar = {
    seriesId?: boolean;
    topicId?: boolean;
    createdAt?: boolean;
  };

  export type SeriesTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<"seriesId" | "topicId" | "createdAt", ExtArgs["result"]["seriesTopic"]>;
  export type SeriesTopicInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };
  export type SeriesTopicIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };
  export type SeriesTopicIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };

  export type $SeriesTopicPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "SeriesTopic";
    objects: {
      series: Prisma.$SeriesPayload<ExtArgs>;
      topic: Prisma.$TopicPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        seriesId: string;
        topicId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["seriesTopic"]
    >;
    composites: {};
  };

  type SeriesTopicGetPayload<S extends boolean | null | undefined | SeriesTopicDefaultArgs> =
    $Result.GetResult<Prisma.$SeriesTopicPayload, S>;

  type SeriesTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesTopicFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: SeriesTopicCountAggregateInputType | true;
    };

  export interface SeriesTopicDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["SeriesTopic"];
      meta: { name: "SeriesTopic" };
    };
    /**
     * Find zero or one SeriesTopic that matches the filter.
     * @param {SeriesTopicFindUniqueArgs} args - Arguments to find a SeriesTopic
     * @example
     * // Get one SeriesTopic
     * const seriesTopic = await prisma.seriesTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesTopicFindUniqueArgs>(
      args: SelectSubset<T, SeriesTopicFindUniqueArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<
        Prisma.$SeriesTopicPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SeriesTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesTopicFindUniqueOrThrowArgs} args - Arguments to find a SeriesTopic
     * @example
     * // Get one SeriesTopic
     * const seriesTopic = await prisma.seriesTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesTopicFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SeriesTopicFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<
        Prisma.$SeriesTopicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SeriesTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicFindFirstArgs} args - Arguments to find a SeriesTopic
     * @example
     * // Get one SeriesTopic
     * const seriesTopic = await prisma.seriesTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesTopicFindFirstArgs>(
      args?: SelectSubset<T, SeriesTopicFindFirstArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<
        Prisma.$SeriesTopicPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SeriesTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicFindFirstOrThrowArgs} args - Arguments to find a SeriesTopic
     * @example
     * // Get one SeriesTopic
     * const seriesTopic = await prisma.seriesTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesTopicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SeriesTopicFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<
        Prisma.$SeriesTopicPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SeriesTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeriesTopics
     * const seriesTopics = await prisma.seriesTopic.findMany()
     *
     * // Get first 10 SeriesTopics
     * const seriesTopics = await prisma.seriesTopic.findMany({ take: 10 })
     *
     * // Only select the `seriesId`
     * const seriesTopicWithSeriesIdOnly = await prisma.seriesTopic.findMany({ select: { seriesId: true } })
     *
     */
    findMany<T extends SeriesTopicFindManyArgs>(
      args?: SelectSubset<T, SeriesTopicFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a SeriesTopic.
     * @param {SeriesTopicCreateArgs} args - Arguments to create a SeriesTopic.
     * @example
     * // Create one SeriesTopic
     * const SeriesTopic = await prisma.seriesTopic.create({
     *   data: {
     *     // ... data to create a SeriesTopic
     *   }
     * })
     *
     */
    create<T extends SeriesTopicCreateArgs>(
      args: SelectSubset<T, SeriesTopicCreateArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SeriesTopics.
     * @param {SeriesTopicCreateManyArgs} args - Arguments to create many SeriesTopics.
     * @example
     * // Create many SeriesTopics
     * const seriesTopic = await prisma.seriesTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SeriesTopicCreateManyArgs>(
      args?: SelectSubset<T, SeriesTopicCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SeriesTopics and returns the data saved in the database.
     * @param {SeriesTopicCreateManyAndReturnArgs} args - Arguments to create many SeriesTopics.
     * @example
     * // Create many SeriesTopics
     * const seriesTopic = await prisma.seriesTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SeriesTopics and only return the `seriesId`
     * const seriesTopicWithSeriesIdOnly = await prisma.seriesTopic.createManyAndReturn({
     *   select: { seriesId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SeriesTopicCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SeriesTopicCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SeriesTopicPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SeriesTopic.
     * @param {SeriesTopicDeleteArgs} args - Arguments to delete one SeriesTopic.
     * @example
     * // Delete one SeriesTopic
     * const SeriesTopic = await prisma.seriesTopic.delete({
     *   where: {
     *     // ... filter to delete one SeriesTopic
     *   }
     * })
     *
     */
    delete<T extends SeriesTopicDeleteArgs>(
      args: SelectSubset<T, SeriesTopicDeleteArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SeriesTopic.
     * @param {SeriesTopicUpdateArgs} args - Arguments to update one SeriesTopic.
     * @example
     * // Update one SeriesTopic
     * const seriesTopic = await prisma.seriesTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SeriesTopicUpdateArgs>(
      args: SelectSubset<T, SeriesTopicUpdateArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SeriesTopics.
     * @param {SeriesTopicDeleteManyArgs} args - Arguments to filter SeriesTopics to delete.
     * @example
     * // Delete a few SeriesTopics
     * const { count } = await prisma.seriesTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SeriesTopicDeleteManyArgs>(
      args?: SelectSubset<T, SeriesTopicDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SeriesTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeriesTopics
     * const seriesTopic = await prisma.seriesTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SeriesTopicUpdateManyArgs>(
      args: SelectSubset<T, SeriesTopicUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SeriesTopics and returns the data updated in the database.
     * @param {SeriesTopicUpdateManyAndReturnArgs} args - Arguments to update many SeriesTopics.
     * @example
     * // Update many SeriesTopics
     * const seriesTopic = await prisma.seriesTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SeriesTopics and only return the `seriesId`
     * const seriesTopicWithSeriesIdOnly = await prisma.seriesTopic.updateManyAndReturn({
     *   select: { seriesId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SeriesTopicUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SeriesTopicUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SeriesTopicPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SeriesTopic.
     * @param {SeriesTopicUpsertArgs} args - Arguments to update or create a SeriesTopic.
     * @example
     * // Update or create a SeriesTopic
     * const seriesTopic = await prisma.seriesTopic.upsert({
     *   create: {
     *     // ... data to create a SeriesTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeriesTopic we want to update
     *   }
     * })
     */
    upsert<T extends SeriesTopicUpsertArgs>(
      args: SelectSubset<T, SeriesTopicUpsertArgs<ExtArgs>>,
    ): Prisma__SeriesTopicClient<
      $Result.GetResult<Prisma.$SeriesTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SeriesTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicCountArgs} args - Arguments to filter SeriesTopics to count.
     * @example
     * // Count the number of SeriesTopics
     * const count = await prisma.seriesTopic.count({
     *   where: {
     *     // ... the filter for the SeriesTopics we want to count
     *   }
     * })
     **/
    count<T extends SeriesTopicCountArgs>(
      args?: Subset<T, SeriesTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SeriesTopicCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SeriesTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SeriesTopicAggregateArgs>(
      args: Subset<T, SeriesTopicAggregateArgs>,
    ): Prisma.PrismaPromise<GetSeriesTopicAggregateType<T>>;

    /**
     * Group by SeriesTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SeriesTopicGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesTopicGroupByArgs["orderBy"] }
        : { orderBy?: SeriesTopicGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SeriesTopicGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetSeriesTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SeriesTopic model
     */
    readonly fields: SeriesTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeriesTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesTopicClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    series<T extends SeriesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SeriesDefaultArgs<ExtArgs>>,
    ): Prisma__SeriesClient<
      | $Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TopicDefaultArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      | $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SeriesTopic model
   */
  interface SeriesTopicFieldRefs {
    readonly seriesId: FieldRef<"SeriesTopic", "String">;
    readonly topicId: FieldRef<"SeriesTopic", "String">;
    readonly createdAt: FieldRef<"SeriesTopic", "DateTime">;
  }

  // Custom InputTypes
  /**
   * SeriesTopic findUnique
   */
  export type SeriesTopicFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * Filter, which SeriesTopic to fetch.
     */
    where: SeriesTopicWhereUniqueInput;
  };

  /**
   * SeriesTopic findUniqueOrThrow
   */
  export type SeriesTopicFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * Filter, which SeriesTopic to fetch.
     */
    where: SeriesTopicWhereUniqueInput;
  };

  /**
   * SeriesTopic findFirst
   */
  export type SeriesTopicFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * Filter, which SeriesTopic to fetch.
     */
    where?: SeriesTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SeriesTopics to fetch.
     */
    orderBy?: SeriesTopicOrderByWithRelationInput | SeriesTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SeriesTopics.
     */
    cursor?: SeriesTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SeriesTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SeriesTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SeriesTopics.
     */
    distinct?: SeriesTopicScalarFieldEnum | SeriesTopicScalarFieldEnum[];
  };

  /**
   * SeriesTopic findFirstOrThrow
   */
  export type SeriesTopicFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * Filter, which SeriesTopic to fetch.
     */
    where?: SeriesTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SeriesTopics to fetch.
     */
    orderBy?: SeriesTopicOrderByWithRelationInput | SeriesTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SeriesTopics.
     */
    cursor?: SeriesTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SeriesTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SeriesTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SeriesTopics.
     */
    distinct?: SeriesTopicScalarFieldEnum | SeriesTopicScalarFieldEnum[];
  };

  /**
   * SeriesTopic findMany
   */
  export type SeriesTopicFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * Filter, which SeriesTopics to fetch.
     */
    where?: SeriesTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SeriesTopics to fetch.
     */
    orderBy?: SeriesTopicOrderByWithRelationInput | SeriesTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SeriesTopics.
     */
    cursor?: SeriesTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SeriesTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SeriesTopics.
     */
    skip?: number;
    distinct?: SeriesTopicScalarFieldEnum | SeriesTopicScalarFieldEnum[];
  };

  /**
   * SeriesTopic create
   */
  export type SeriesTopicCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * The data needed to create a SeriesTopic.
     */
    data: XOR<SeriesTopicCreateInput, SeriesTopicUncheckedCreateInput>;
  };

  /**
   * SeriesTopic createMany
   */
  export type SeriesTopicCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SeriesTopics.
     */
    data: SeriesTopicCreateManyInput | SeriesTopicCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SeriesTopic createManyAndReturn
   */
  export type SeriesTopicCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * The data used to create many SeriesTopics.
     */
    data: SeriesTopicCreateManyInput | SeriesTopicCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * SeriesTopic update
   */
  export type SeriesTopicUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * The data needed to update a SeriesTopic.
     */
    data: XOR<SeriesTopicUpdateInput, SeriesTopicUncheckedUpdateInput>;
    /**
     * Choose, which SeriesTopic to update.
     */
    where: SeriesTopicWhereUniqueInput;
  };

  /**
   * SeriesTopic updateMany
   */
  export type SeriesTopicUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SeriesTopics.
     */
    data: XOR<SeriesTopicUpdateManyMutationInput, SeriesTopicUncheckedUpdateManyInput>;
    /**
     * Filter which SeriesTopics to update
     */
    where?: SeriesTopicWhereInput;
    /**
     * Limit how many SeriesTopics to update.
     */
    limit?: number;
  };

  /**
   * SeriesTopic updateManyAndReturn
   */
  export type SeriesTopicUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * The data used to update SeriesTopics.
     */
    data: XOR<SeriesTopicUpdateManyMutationInput, SeriesTopicUncheckedUpdateManyInput>;
    /**
     * Filter which SeriesTopics to update
     */
    where?: SeriesTopicWhereInput;
    /**
     * Limit how many SeriesTopics to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * SeriesTopic upsert
   */
  export type SeriesTopicUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * The filter to search for the SeriesTopic to update in case it exists.
     */
    where: SeriesTopicWhereUniqueInput;
    /**
     * In case the SeriesTopic found by the `where` argument doesn't exist, create a new SeriesTopic with this data.
     */
    create: XOR<SeriesTopicCreateInput, SeriesTopicUncheckedCreateInput>;
    /**
     * In case the SeriesTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesTopicUpdateInput, SeriesTopicUncheckedUpdateInput>;
  };

  /**
   * SeriesTopic delete
   */
  export type SeriesTopicDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
    /**
     * Filter which SeriesTopic to delete.
     */
    where: SeriesTopicWhereUniqueInput;
  };

  /**
   * SeriesTopic deleteMany
   */
  export type SeriesTopicDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SeriesTopics to delete
     */
    where?: SeriesTopicWhereInput;
    /**
     * Limit how many SeriesTopics to delete.
     */
    limit?: number;
  };

  /**
   * SeriesTopic without action
   */
  export type SeriesTopicDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SeriesTopic
     */
    select?: SeriesTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SeriesTopic
     */
    omit?: SeriesTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTopicInclude<ExtArgs> | null;
  };

  /**
   * Model CollectionTopic
   */

  export type AggregateCollectionTopic = {
    _count: CollectionTopicCountAggregateOutputType | null;
    _min: CollectionTopicMinAggregateOutputType | null;
    _max: CollectionTopicMaxAggregateOutputType | null;
  };

  export type CollectionTopicMinAggregateOutputType = {
    collectionId: string | null;
    topicId: string | null;
    createdAt: Date | null;
  };

  export type CollectionTopicMaxAggregateOutputType = {
    collectionId: string | null;
    topicId: string | null;
    createdAt: Date | null;
  };

  export type CollectionTopicCountAggregateOutputType = {
    collectionId: number;
    topicId: number;
    createdAt: number;
    _all: number;
  };

  export type CollectionTopicMinAggregateInputType = {
    collectionId?: true;
    topicId?: true;
    createdAt?: true;
  };

  export type CollectionTopicMaxAggregateInputType = {
    collectionId?: true;
    topicId?: true;
    createdAt?: true;
  };

  export type CollectionTopicCountAggregateInputType = {
    collectionId?: true;
    topicId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type CollectionTopicAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CollectionTopic to aggregate.
     */
    where?: CollectionTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CollectionTopics to fetch.
     */
    orderBy?: CollectionTopicOrderByWithRelationInput | CollectionTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CollectionTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CollectionTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CollectionTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CollectionTopics
     **/
    _count?: true | CollectionTopicCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CollectionTopicMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CollectionTopicMaxAggregateInputType;
  };

  export type GetCollectionTopicAggregateType<T extends CollectionTopicAggregateArgs> = {
    [P in keyof T & keyof AggregateCollectionTopic]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionTopic[P]>
      : GetScalarType<T[P], AggregateCollectionTopic[P]>;
  };

  export type CollectionTopicGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CollectionTopicWhereInput;
    orderBy?:
      | CollectionTopicOrderByWithAggregationInput
      | CollectionTopicOrderByWithAggregationInput[];
    by: CollectionTopicScalarFieldEnum[] | CollectionTopicScalarFieldEnum;
    having?: CollectionTopicScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CollectionTopicCountAggregateInputType | true;
    _min?: CollectionTopicMinAggregateInputType;
    _max?: CollectionTopicMaxAggregateInputType;
  };

  export type CollectionTopicGroupByOutputType = {
    collectionId: string;
    topicId: string;
    createdAt: Date;
    _count: CollectionTopicCountAggregateOutputType | null;
    _min: CollectionTopicMinAggregateOutputType | null;
    _max: CollectionTopicMaxAggregateOutputType | null;
  };

  type GetCollectionTopicGroupByPayload<T extends CollectionTopicGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CollectionTopicGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof CollectionTopicGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionTopicGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionTopicGroupByOutputType[P]>;
        }
      >
    >;

  export type CollectionTopicSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      collectionId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      collection?: boolean | CollectionDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["collectionTopic"]
  >;

  export type CollectionTopicSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      collectionId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      collection?: boolean | CollectionDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["collectionTopic"]
  >;

  export type CollectionTopicSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      collectionId?: boolean;
      topicId?: boolean;
      createdAt?: boolean;
      collection?: boolean | CollectionDefaultArgs<ExtArgs>;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["collectionTopic"]
  >;

  export type CollectionTopicSelectScalar = {
    collectionId?: boolean;
    topicId?: boolean;
    createdAt?: boolean;
  };

  export type CollectionTopicOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "collectionId" | "topicId" | "createdAt",
    ExtArgs["result"]["collectionTopic"]
  >;
  export type CollectionTopicInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };
  export type CollectionTopicIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };
  export type CollectionTopicIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>;
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
  };

  export type $CollectionTopicPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "CollectionTopic";
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs>;
      topic: Prisma.$TopicPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        collectionId: string;
        topicId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["collectionTopic"]
    >;
    composites: {};
  };

  type CollectionTopicGetPayload<
    S extends boolean | null | undefined | CollectionTopicDefaultArgs,
  > = $Result.GetResult<Prisma.$CollectionTopicPayload, S>;

  type CollectionTopicCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CollectionTopicFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: CollectionTopicCountAggregateInputType | true;
  };

  export interface CollectionTopicDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["CollectionTopic"];
      meta: { name: "CollectionTopic" };
    };
    /**
     * Find zero or one CollectionTopic that matches the filter.
     * @param {CollectionTopicFindUniqueArgs} args - Arguments to find a CollectionTopic
     * @example
     * // Get one CollectionTopic
     * const collectionTopic = await prisma.collectionTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionTopicFindUniqueArgs>(
      args: SelectSubset<T, CollectionTopicFindUniqueArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<
        Prisma.$CollectionTopicPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CollectionTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionTopicFindUniqueOrThrowArgs} args - Arguments to find a CollectionTopic
     * @example
     * // Get one CollectionTopic
     * const collectionTopic = await prisma.collectionTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionTopicFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CollectionTopicFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<
        Prisma.$CollectionTopicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CollectionTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicFindFirstArgs} args - Arguments to find a CollectionTopic
     * @example
     * // Get one CollectionTopic
     * const collectionTopic = await prisma.collectionTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionTopicFindFirstArgs>(
      args?: SelectSubset<T, CollectionTopicFindFirstArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<
        Prisma.$CollectionTopicPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CollectionTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicFindFirstOrThrowArgs} args - Arguments to find a CollectionTopic
     * @example
     * // Get one CollectionTopic
     * const collectionTopic = await prisma.collectionTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionTopicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CollectionTopicFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<
        Prisma.$CollectionTopicPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CollectionTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionTopics
     * const collectionTopics = await prisma.collectionTopic.findMany()
     *
     * // Get first 10 CollectionTopics
     * const collectionTopics = await prisma.collectionTopic.findMany({ take: 10 })
     *
     * // Only select the `collectionId`
     * const collectionTopicWithCollectionIdOnly = await prisma.collectionTopic.findMany({ select: { collectionId: true } })
     *
     */
    findMany<T extends CollectionTopicFindManyArgs>(
      args?: SelectSubset<T, CollectionTopicFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a CollectionTopic.
     * @param {CollectionTopicCreateArgs} args - Arguments to create a CollectionTopic.
     * @example
     * // Create one CollectionTopic
     * const CollectionTopic = await prisma.collectionTopic.create({
     *   data: {
     *     // ... data to create a CollectionTopic
     *   }
     * })
     *
     */
    create<T extends CollectionTopicCreateArgs>(
      args: SelectSubset<T, CollectionTopicCreateArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CollectionTopics.
     * @param {CollectionTopicCreateManyArgs} args - Arguments to create many CollectionTopics.
     * @example
     * // Create many CollectionTopics
     * const collectionTopic = await prisma.collectionTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CollectionTopicCreateManyArgs>(
      args?: SelectSubset<T, CollectionTopicCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CollectionTopics and returns the data saved in the database.
     * @param {CollectionTopicCreateManyAndReturnArgs} args - Arguments to create many CollectionTopics.
     * @example
     * // Create many CollectionTopics
     * const collectionTopic = await prisma.collectionTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CollectionTopics and only return the `collectionId`
     * const collectionTopicWithCollectionIdOnly = await prisma.collectionTopic.createManyAndReturn({
     *   select: { collectionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CollectionTopicCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CollectionTopicCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CollectionTopicPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a CollectionTopic.
     * @param {CollectionTopicDeleteArgs} args - Arguments to delete one CollectionTopic.
     * @example
     * // Delete one CollectionTopic
     * const CollectionTopic = await prisma.collectionTopic.delete({
     *   where: {
     *     // ... filter to delete one CollectionTopic
     *   }
     * })
     *
     */
    delete<T extends CollectionTopicDeleteArgs>(
      args: SelectSubset<T, CollectionTopicDeleteArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CollectionTopic.
     * @param {CollectionTopicUpdateArgs} args - Arguments to update one CollectionTopic.
     * @example
     * // Update one CollectionTopic
     * const collectionTopic = await prisma.collectionTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CollectionTopicUpdateArgs>(
      args: SelectSubset<T, CollectionTopicUpdateArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CollectionTopics.
     * @param {CollectionTopicDeleteManyArgs} args - Arguments to filter CollectionTopics to delete.
     * @example
     * // Delete a few CollectionTopics
     * const { count } = await prisma.collectionTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CollectionTopicDeleteManyArgs>(
      args?: SelectSubset<T, CollectionTopicDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CollectionTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionTopics
     * const collectionTopic = await prisma.collectionTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CollectionTopicUpdateManyArgs>(
      args: SelectSubset<T, CollectionTopicUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CollectionTopics and returns the data updated in the database.
     * @param {CollectionTopicUpdateManyAndReturnArgs} args - Arguments to update many CollectionTopics.
     * @example
     * // Update many CollectionTopics
     * const collectionTopic = await prisma.collectionTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CollectionTopics and only return the `collectionId`
     * const collectionTopicWithCollectionIdOnly = await prisma.collectionTopic.updateManyAndReturn({
     *   select: { collectionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CollectionTopicUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CollectionTopicUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CollectionTopicPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one CollectionTopic.
     * @param {CollectionTopicUpsertArgs} args - Arguments to update or create a CollectionTopic.
     * @example
     * // Update or create a CollectionTopic
     * const collectionTopic = await prisma.collectionTopic.upsert({
     *   create: {
     *     // ... data to create a CollectionTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionTopic we want to update
     *   }
     * })
     */
    upsert<T extends CollectionTopicUpsertArgs>(
      args: SelectSubset<T, CollectionTopicUpsertArgs<ExtArgs>>,
    ): Prisma__CollectionTopicClient<
      $Result.GetResult<Prisma.$CollectionTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CollectionTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicCountArgs} args - Arguments to filter CollectionTopics to count.
     * @example
     * // Count the number of CollectionTopics
     * const count = await prisma.collectionTopic.count({
     *   where: {
     *     // ... the filter for the CollectionTopics we want to count
     *   }
     * })
     **/
    count<T extends CollectionTopicCountArgs>(
      args?: Subset<T, CollectionTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CollectionTopicCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CollectionTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CollectionTopicAggregateArgs>(
      args: Subset<T, CollectionTopicAggregateArgs>,
    ): Prisma.PrismaPromise<GetCollectionTopicAggregateType<T>>;

    /**
     * Group by CollectionTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CollectionTopicGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionTopicGroupByArgs["orderBy"] }
        : { orderBy?: CollectionTopicGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CollectionTopicGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCollectionTopicGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CollectionTopic model
     */
    readonly fields: CollectionTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionTopicClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CollectionDefaultArgs<ExtArgs>>,
    ): Prisma__CollectionClient<
      | $Result.GetResult<
          Prisma.$CollectionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TopicDefaultArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      | $Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CollectionTopic model
   */
  interface CollectionTopicFieldRefs {
    readonly collectionId: FieldRef<"CollectionTopic", "String">;
    readonly topicId: FieldRef<"CollectionTopic", "String">;
    readonly createdAt: FieldRef<"CollectionTopic", "DateTime">;
  }

  // Custom InputTypes
  /**
   * CollectionTopic findUnique
   */
  export type CollectionTopicFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * Filter, which CollectionTopic to fetch.
     */
    where: CollectionTopicWhereUniqueInput;
  };

  /**
   * CollectionTopic findUniqueOrThrow
   */
  export type CollectionTopicFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * Filter, which CollectionTopic to fetch.
     */
    where: CollectionTopicWhereUniqueInput;
  };

  /**
   * CollectionTopic findFirst
   */
  export type CollectionTopicFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * Filter, which CollectionTopic to fetch.
     */
    where?: CollectionTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CollectionTopics to fetch.
     */
    orderBy?: CollectionTopicOrderByWithRelationInput | CollectionTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CollectionTopics.
     */
    cursor?: CollectionTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CollectionTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CollectionTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CollectionTopics.
     */
    distinct?: CollectionTopicScalarFieldEnum | CollectionTopicScalarFieldEnum[];
  };

  /**
   * CollectionTopic findFirstOrThrow
   */
  export type CollectionTopicFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * Filter, which CollectionTopic to fetch.
     */
    where?: CollectionTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CollectionTopics to fetch.
     */
    orderBy?: CollectionTopicOrderByWithRelationInput | CollectionTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CollectionTopics.
     */
    cursor?: CollectionTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CollectionTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CollectionTopics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CollectionTopics.
     */
    distinct?: CollectionTopicScalarFieldEnum | CollectionTopicScalarFieldEnum[];
  };

  /**
   * CollectionTopic findMany
   */
  export type CollectionTopicFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * Filter, which CollectionTopics to fetch.
     */
    where?: CollectionTopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CollectionTopics to fetch.
     */
    orderBy?: CollectionTopicOrderByWithRelationInput | CollectionTopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CollectionTopics.
     */
    cursor?: CollectionTopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CollectionTopics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CollectionTopics.
     */
    skip?: number;
    distinct?: CollectionTopicScalarFieldEnum | CollectionTopicScalarFieldEnum[];
  };

  /**
   * CollectionTopic create
   */
  export type CollectionTopicCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * The data needed to create a CollectionTopic.
     */
    data: XOR<CollectionTopicCreateInput, CollectionTopicUncheckedCreateInput>;
  };

  /**
   * CollectionTopic createMany
   */
  export type CollectionTopicCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CollectionTopics.
     */
    data: CollectionTopicCreateManyInput | CollectionTopicCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CollectionTopic createManyAndReturn
   */
  export type CollectionTopicCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * The data used to create many CollectionTopics.
     */
    data: CollectionTopicCreateManyInput | CollectionTopicCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CollectionTopic update
   */
  export type CollectionTopicUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * The data needed to update a CollectionTopic.
     */
    data: XOR<CollectionTopicUpdateInput, CollectionTopicUncheckedUpdateInput>;
    /**
     * Choose, which CollectionTopic to update.
     */
    where: CollectionTopicWhereUniqueInput;
  };

  /**
   * CollectionTopic updateMany
   */
  export type CollectionTopicUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CollectionTopics.
     */
    data: XOR<CollectionTopicUpdateManyMutationInput, CollectionTopicUncheckedUpdateManyInput>;
    /**
     * Filter which CollectionTopics to update
     */
    where?: CollectionTopicWhereInput;
    /**
     * Limit how many CollectionTopics to update.
     */
    limit?: number;
  };

  /**
   * CollectionTopic updateManyAndReturn
   */
  export type CollectionTopicUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * The data used to update CollectionTopics.
     */
    data: XOR<CollectionTopicUpdateManyMutationInput, CollectionTopicUncheckedUpdateManyInput>;
    /**
     * Filter which CollectionTopics to update
     */
    where?: CollectionTopicWhereInput;
    /**
     * Limit how many CollectionTopics to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CollectionTopic upsert
   */
  export type CollectionTopicUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * The filter to search for the CollectionTopic to update in case it exists.
     */
    where: CollectionTopicWhereUniqueInput;
    /**
     * In case the CollectionTopic found by the `where` argument doesn't exist, create a new CollectionTopic with this data.
     */
    create: XOR<CollectionTopicCreateInput, CollectionTopicUncheckedCreateInput>;
    /**
     * In case the CollectionTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionTopicUpdateInput, CollectionTopicUncheckedUpdateInput>;
  };

  /**
   * CollectionTopic delete
   */
  export type CollectionTopicDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
    /**
     * Filter which CollectionTopic to delete.
     */
    where: CollectionTopicWhereUniqueInput;
  };

  /**
   * CollectionTopic deleteMany
   */
  export type CollectionTopicDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CollectionTopics to delete
     */
    where?: CollectionTopicWhereInput;
    /**
     * Limit how many CollectionTopics to delete.
     */
    limit?: number;
  };

  /**
   * CollectionTopic without action
   */
  export type CollectionTopicDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CollectionTopic
     */
    select?: CollectionTopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CollectionTopic
     */
    omit?: CollectionTopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionTopicInclude<ExtArgs> | null;
  };

  /**
   * Model UserLectureProgress
   */

  export type AggregateUserLectureProgress = {
    _count: UserLectureProgressCountAggregateOutputType | null;
    _avg: UserLectureProgressAvgAggregateOutputType | null;
    _sum: UserLectureProgressSumAggregateOutputType | null;
    _min: UserLectureProgressMinAggregateOutputType | null;
    _max: UserLectureProgressMaxAggregateOutputType | null;
  };

  export type UserLectureProgressAvgAggregateOutputType = {
    positionSeconds: number | null;
  };

  export type UserLectureProgressSumAggregateOutputType = {
    positionSeconds: number | null;
  };

  export type UserLectureProgressMinAggregateOutputType = {
    userId: string | null;
    lectureId: string | null;
    positionSeconds: number | null;
    isCompleted: boolean | null;
    updatedAt: Date | null;
  };

  export type UserLectureProgressMaxAggregateOutputType = {
    userId: string | null;
    lectureId: string | null;
    positionSeconds: number | null;
    isCompleted: boolean | null;
    updatedAt: Date | null;
  };

  export type UserLectureProgressCountAggregateOutputType = {
    userId: number;
    lectureId: number;
    positionSeconds: number;
    isCompleted: number;
    updatedAt: number;
    _all: number;
  };

  export type UserLectureProgressAvgAggregateInputType = {
    positionSeconds?: true;
  };

  export type UserLectureProgressSumAggregateInputType = {
    positionSeconds?: true;
  };

  export type UserLectureProgressMinAggregateInputType = {
    userId?: true;
    lectureId?: true;
    positionSeconds?: true;
    isCompleted?: true;
    updatedAt?: true;
  };

  export type UserLectureProgressMaxAggregateInputType = {
    userId?: true;
    lectureId?: true;
    positionSeconds?: true;
    isCompleted?: true;
    updatedAt?: true;
  };

  export type UserLectureProgressCountAggregateInputType = {
    userId?: true;
    lectureId?: true;
    positionSeconds?: true;
    isCompleted?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserLectureProgressAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserLectureProgress to aggregate.
     */
    where?: UserLectureProgressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLectureProgresses to fetch.
     */
    orderBy?:
      | UserLectureProgressOrderByWithRelationInput
      | UserLectureProgressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserLectureProgressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLectureProgresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLectureProgresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserLectureProgresses
     **/
    _count?: true | UserLectureProgressCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserLectureProgressAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserLectureProgressSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserLectureProgressMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserLectureProgressMaxAggregateInputType;
  };

  export type GetUserLectureProgressAggregateType<T extends UserLectureProgressAggregateArgs> = {
    [P in keyof T & keyof AggregateUserLectureProgress]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLectureProgress[P]>
      : GetScalarType<T[P], AggregateUserLectureProgress[P]>;
  };

  export type UserLectureProgressGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserLectureProgressWhereInput;
    orderBy?:
      | UserLectureProgressOrderByWithAggregationInput
      | UserLectureProgressOrderByWithAggregationInput[];
    by: UserLectureProgressScalarFieldEnum[] | UserLectureProgressScalarFieldEnum;
    having?: UserLectureProgressScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserLectureProgressCountAggregateInputType | true;
    _avg?: UserLectureProgressAvgAggregateInputType;
    _sum?: UserLectureProgressSumAggregateInputType;
    _min?: UserLectureProgressMinAggregateInputType;
    _max?: UserLectureProgressMaxAggregateInputType;
  };

  export type UserLectureProgressGroupByOutputType = {
    userId: string;
    lectureId: string;
    positionSeconds: number;
    isCompleted: boolean;
    updatedAt: Date;
    _count: UserLectureProgressCountAggregateOutputType | null;
    _avg: UserLectureProgressAvgAggregateOutputType | null;
    _sum: UserLectureProgressSumAggregateOutputType | null;
    _min: UserLectureProgressMinAggregateOutputType | null;
    _max: UserLectureProgressMaxAggregateOutputType | null;
  };

  type GetUserLectureProgressGroupByPayload<T extends UserLectureProgressGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserLectureProgressGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof UserLectureProgressGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLectureProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserLectureProgressGroupByOutputType[P]>;
        }
      >
    >;

  export type UserLectureProgressSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      lectureId?: boolean;
      positionSeconds?: boolean;
      isCompleted?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userLectureProgress"]
  >;

  export type UserLectureProgressSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      lectureId?: boolean;
      positionSeconds?: boolean;
      isCompleted?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userLectureProgress"]
  >;

  export type UserLectureProgressSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      lectureId?: boolean;
      positionSeconds?: boolean;
      isCompleted?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userLectureProgress"]
  >;

  export type UserLectureProgressSelectScalar = {
    userId?: boolean;
    lectureId?: boolean;
    positionSeconds?: boolean;
    isCompleted?: boolean;
    updatedAt?: boolean;
  };

  export type UserLectureProgressOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "userId" | "lectureId" | "positionSeconds" | "isCompleted" | "updatedAt",
    ExtArgs["result"]["userLectureProgress"]
  >;
  export type UserLectureProgressInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };
  export type UserLectureProgressIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };
  export type UserLectureProgressIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };

  export type $UserLectureProgressPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "UserLectureProgress";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      lecture: Prisma.$LecturePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        lectureId: string;
        positionSeconds: number;
        isCompleted: boolean;
        updatedAt: Date;
      },
      ExtArgs["result"]["userLectureProgress"]
    >;
    composites: {};
  };

  type UserLectureProgressGetPayload<
    S extends boolean | null | undefined | UserLectureProgressDefaultArgs,
  > = $Result.GetResult<Prisma.$UserLectureProgressPayload, S>;

  type UserLectureProgressCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserLectureProgressFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserLectureProgressCountAggregateInputType | true;
  };

  export interface UserLectureProgressDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["UserLectureProgress"];
      meta: { name: "UserLectureProgress" };
    };
    /**
     * Find zero or one UserLectureProgress that matches the filter.
     * @param {UserLectureProgressFindUniqueArgs} args - Arguments to find a UserLectureProgress
     * @example
     * // Get one UserLectureProgress
     * const userLectureProgress = await prisma.userLectureProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLectureProgressFindUniqueArgs>(
      args: SelectSubset<T, UserLectureProgressFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserLectureProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLectureProgressFindUniqueOrThrowArgs} args - Arguments to find a UserLectureProgress
     * @example
     * // Get one UserLectureProgress
     * const userLectureProgress = await prisma.userLectureProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLectureProgressFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserLectureProgressFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserLectureProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressFindFirstArgs} args - Arguments to find a UserLectureProgress
     * @example
     * // Get one UserLectureProgress
     * const userLectureProgress = await prisma.userLectureProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLectureProgressFindFirstArgs>(
      args?: SelectSubset<T, UserLectureProgressFindFirstArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserLectureProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressFindFirstOrThrowArgs} args - Arguments to find a UserLectureProgress
     * @example
     * // Get one UserLectureProgress
     * const userLectureProgress = await prisma.userLectureProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLectureProgressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserLectureProgressFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserLectureProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLectureProgresses
     * const userLectureProgresses = await prisma.userLectureProgress.findMany()
     *
     * // Get first 10 UserLectureProgresses
     * const userLectureProgresses = await prisma.userLectureProgress.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const userLectureProgressWithUserIdOnly = await prisma.userLectureProgress.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends UserLectureProgressFindManyArgs>(
      args?: SelectSubset<T, UserLectureProgressFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserLectureProgress.
     * @param {UserLectureProgressCreateArgs} args - Arguments to create a UserLectureProgress.
     * @example
     * // Create one UserLectureProgress
     * const UserLectureProgress = await prisma.userLectureProgress.create({
     *   data: {
     *     // ... data to create a UserLectureProgress
     *   }
     * })
     *
     */
    create<T extends UserLectureProgressCreateArgs>(
      args: SelectSubset<T, UserLectureProgressCreateArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserLectureProgresses.
     * @param {UserLectureProgressCreateManyArgs} args - Arguments to create many UserLectureProgresses.
     * @example
     * // Create many UserLectureProgresses
     * const userLectureProgress = await prisma.userLectureProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserLectureProgressCreateManyArgs>(
      args?: SelectSubset<T, UserLectureProgressCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserLectureProgresses and returns the data saved in the database.
     * @param {UserLectureProgressCreateManyAndReturnArgs} args - Arguments to create many UserLectureProgresses.
     * @example
     * // Create many UserLectureProgresses
     * const userLectureProgress = await prisma.userLectureProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserLectureProgresses and only return the `userId`
     * const userLectureProgressWithUserIdOnly = await prisma.userLectureProgress.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserLectureProgressCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserLectureProgressCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserLectureProgress.
     * @param {UserLectureProgressDeleteArgs} args - Arguments to delete one UserLectureProgress.
     * @example
     * // Delete one UserLectureProgress
     * const UserLectureProgress = await prisma.userLectureProgress.delete({
     *   where: {
     *     // ... filter to delete one UserLectureProgress
     *   }
     * })
     *
     */
    delete<T extends UserLectureProgressDeleteArgs>(
      args: SelectSubset<T, UserLectureProgressDeleteArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserLectureProgress.
     * @param {UserLectureProgressUpdateArgs} args - Arguments to update one UserLectureProgress.
     * @example
     * // Update one UserLectureProgress
     * const userLectureProgress = await prisma.userLectureProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserLectureProgressUpdateArgs>(
      args: SelectSubset<T, UserLectureProgressUpdateArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserLectureProgresses.
     * @param {UserLectureProgressDeleteManyArgs} args - Arguments to filter UserLectureProgresses to delete.
     * @example
     * // Delete a few UserLectureProgresses
     * const { count } = await prisma.userLectureProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserLectureProgressDeleteManyArgs>(
      args?: SelectSubset<T, UserLectureProgressDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserLectureProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLectureProgresses
     * const userLectureProgress = await prisma.userLectureProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserLectureProgressUpdateManyArgs>(
      args: SelectSubset<T, UserLectureProgressUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserLectureProgresses and returns the data updated in the database.
     * @param {UserLectureProgressUpdateManyAndReturnArgs} args - Arguments to update many UserLectureProgresses.
     * @example
     * // Update many UserLectureProgresses
     * const userLectureProgress = await prisma.userLectureProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserLectureProgresses and only return the `userId`
     * const userLectureProgressWithUserIdOnly = await prisma.userLectureProgress.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserLectureProgressUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserLectureProgressUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserLectureProgress.
     * @param {UserLectureProgressUpsertArgs} args - Arguments to update or create a UserLectureProgress.
     * @example
     * // Update or create a UserLectureProgress
     * const userLectureProgress = await prisma.userLectureProgress.upsert({
     *   create: {
     *     // ... data to create a UserLectureProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLectureProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserLectureProgressUpsertArgs>(
      args: SelectSubset<T, UserLectureProgressUpsertArgs<ExtArgs>>,
    ): Prisma__UserLectureProgressClient<
      $Result.GetResult<
        Prisma.$UserLectureProgressPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserLectureProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressCountArgs} args - Arguments to filter UserLectureProgresses to count.
     * @example
     * // Count the number of UserLectureProgresses
     * const count = await prisma.userLectureProgress.count({
     *   where: {
     *     // ... the filter for the UserLectureProgresses we want to count
     *   }
     * })
     **/
    count<T extends UserLectureProgressCountArgs>(
      args?: Subset<T, UserLectureProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserLectureProgressCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserLectureProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserLectureProgressAggregateArgs>(
      args: Subset<T, UserLectureProgressAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserLectureProgressAggregateType<T>>;

    /**
     * Group by UserLectureProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLectureProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserLectureProgressGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLectureProgressGroupByArgs["orderBy"] }
        : { orderBy?: UserLectureProgressGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserLectureProgressGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserLectureProgressGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserLectureProgress model
     */
    readonly fields: UserLectureProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLectureProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLectureProgressClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LectureDefaultArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      | $Result.GetResult<
          Prisma.$LecturePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserLectureProgress model
   */
  interface UserLectureProgressFieldRefs {
    readonly userId: FieldRef<"UserLectureProgress", "String">;
    readonly lectureId: FieldRef<"UserLectureProgress", "String">;
    readonly positionSeconds: FieldRef<"UserLectureProgress", "Int">;
    readonly isCompleted: FieldRef<"UserLectureProgress", "Boolean">;
    readonly updatedAt: FieldRef<"UserLectureProgress", "DateTime">;
  }

  // Custom InputTypes
  /**
   * UserLectureProgress findUnique
   */
  export type UserLectureProgressFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * Filter, which UserLectureProgress to fetch.
     */
    where: UserLectureProgressWhereUniqueInput;
  };

  /**
   * UserLectureProgress findUniqueOrThrow
   */
  export type UserLectureProgressFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * Filter, which UserLectureProgress to fetch.
     */
    where: UserLectureProgressWhereUniqueInput;
  };

  /**
   * UserLectureProgress findFirst
   */
  export type UserLectureProgressFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * Filter, which UserLectureProgress to fetch.
     */
    where?: UserLectureProgressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLectureProgresses to fetch.
     */
    orderBy?:
      | UserLectureProgressOrderByWithRelationInput
      | UserLectureProgressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserLectureProgresses.
     */
    cursor?: UserLectureProgressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLectureProgresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLectureProgresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserLectureProgresses.
     */
    distinct?: UserLectureProgressScalarFieldEnum | UserLectureProgressScalarFieldEnum[];
  };

  /**
   * UserLectureProgress findFirstOrThrow
   */
  export type UserLectureProgressFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * Filter, which UserLectureProgress to fetch.
     */
    where?: UserLectureProgressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLectureProgresses to fetch.
     */
    orderBy?:
      | UserLectureProgressOrderByWithRelationInput
      | UserLectureProgressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserLectureProgresses.
     */
    cursor?: UserLectureProgressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLectureProgresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLectureProgresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserLectureProgresses.
     */
    distinct?: UserLectureProgressScalarFieldEnum | UserLectureProgressScalarFieldEnum[];
  };

  /**
   * UserLectureProgress findMany
   */
  export type UserLectureProgressFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * Filter, which UserLectureProgresses to fetch.
     */
    where?: UserLectureProgressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLectureProgresses to fetch.
     */
    orderBy?:
      | UserLectureProgressOrderByWithRelationInput
      | UserLectureProgressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserLectureProgresses.
     */
    cursor?: UserLectureProgressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLectureProgresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLectureProgresses.
     */
    skip?: number;
    distinct?: UserLectureProgressScalarFieldEnum | UserLectureProgressScalarFieldEnum[];
  };

  /**
   * UserLectureProgress create
   */
  export type UserLectureProgressCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserLectureProgress.
     */
    data: XOR<UserLectureProgressCreateInput, UserLectureProgressUncheckedCreateInput>;
  };

  /**
   * UserLectureProgress createMany
   */
  export type UserLectureProgressCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserLectureProgresses.
     */
    data: UserLectureProgressCreateManyInput | UserLectureProgressCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserLectureProgress createManyAndReturn
   */
  export type UserLectureProgressCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * The data used to create many UserLectureProgresses.
     */
    data: UserLectureProgressCreateManyInput | UserLectureProgressCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserLectureProgress update
   */
  export type UserLectureProgressUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserLectureProgress.
     */
    data: XOR<UserLectureProgressUpdateInput, UserLectureProgressUncheckedUpdateInput>;
    /**
     * Choose, which UserLectureProgress to update.
     */
    where: UserLectureProgressWhereUniqueInput;
  };

  /**
   * UserLectureProgress updateMany
   */
  export type UserLectureProgressUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserLectureProgresses.
     */
    data: XOR<
      UserLectureProgressUpdateManyMutationInput,
      UserLectureProgressUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserLectureProgresses to update
     */
    where?: UserLectureProgressWhereInput;
    /**
     * Limit how many UserLectureProgresses to update.
     */
    limit?: number;
  };

  /**
   * UserLectureProgress updateManyAndReturn
   */
  export type UserLectureProgressUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * The data used to update UserLectureProgresses.
     */
    data: XOR<
      UserLectureProgressUpdateManyMutationInput,
      UserLectureProgressUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserLectureProgresses to update
     */
    where?: UserLectureProgressWhereInput;
    /**
     * Limit how many UserLectureProgresses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserLectureProgress upsert
   */
  export type UserLectureProgressUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserLectureProgress to update in case it exists.
     */
    where: UserLectureProgressWhereUniqueInput;
    /**
     * In case the UserLectureProgress found by the `where` argument doesn't exist, create a new UserLectureProgress with this data.
     */
    create: XOR<UserLectureProgressCreateInput, UserLectureProgressUncheckedCreateInput>;
    /**
     * In case the UserLectureProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLectureProgressUpdateInput, UserLectureProgressUncheckedUpdateInput>;
  };

  /**
   * UserLectureProgress delete
   */
  export type UserLectureProgressDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
    /**
     * Filter which UserLectureProgress to delete.
     */
    where: UserLectureProgressWhereUniqueInput;
  };

  /**
   * UserLectureProgress deleteMany
   */
  export type UserLectureProgressDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserLectureProgresses to delete
     */
    where?: UserLectureProgressWhereInput;
    /**
     * Limit how many UserLectureProgresses to delete.
     */
    limit?: number;
  };

  /**
   * UserLectureProgress without action
   */
  export type UserLectureProgressDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLectureProgress
     */
    select?: UserLectureProgressSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLectureProgress
     */
    omit?: UserLectureProgressOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLectureProgressInclude<ExtArgs> | null;
  };

  /**
   * Model FavoriteLecture
   */

  export type AggregateFavoriteLecture = {
    _count: FavoriteLectureCountAggregateOutputType | null;
    _min: FavoriteLectureMinAggregateOutputType | null;
    _max: FavoriteLectureMaxAggregateOutputType | null;
  };

  export type FavoriteLectureMinAggregateOutputType = {
    userId: string | null;
    lectureId: string | null;
    createdAt: Date | null;
  };

  export type FavoriteLectureMaxAggregateOutputType = {
    userId: string | null;
    lectureId: string | null;
    createdAt: Date | null;
  };

  export type FavoriteLectureCountAggregateOutputType = {
    userId: number;
    lectureId: number;
    createdAt: number;
    _all: number;
  };

  export type FavoriteLectureMinAggregateInputType = {
    userId?: true;
    lectureId?: true;
    createdAt?: true;
  };

  export type FavoriteLectureMaxAggregateInputType = {
    userId?: true;
    lectureId?: true;
    createdAt?: true;
  };

  export type FavoriteLectureCountAggregateInputType = {
    userId?: true;
    lectureId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type FavoriteLectureAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FavoriteLecture to aggregate.
     */
    where?: FavoriteLectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FavoriteLectures to fetch.
     */
    orderBy?: FavoriteLectureOrderByWithRelationInput | FavoriteLectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FavoriteLectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FavoriteLectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FavoriteLectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FavoriteLectures
     **/
    _count?: true | FavoriteLectureCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FavoriteLectureMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FavoriteLectureMaxAggregateInputType;
  };

  export type GetFavoriteLectureAggregateType<T extends FavoriteLectureAggregateArgs> = {
    [P in keyof T & keyof AggregateFavoriteLecture]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteLecture[P]>
      : GetScalarType<T[P], AggregateFavoriteLecture[P]>;
  };

  export type FavoriteLectureGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FavoriteLectureWhereInput;
    orderBy?:
      | FavoriteLectureOrderByWithAggregationInput
      | FavoriteLectureOrderByWithAggregationInput[];
    by: FavoriteLectureScalarFieldEnum[] | FavoriteLectureScalarFieldEnum;
    having?: FavoriteLectureScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FavoriteLectureCountAggregateInputType | true;
    _min?: FavoriteLectureMinAggregateInputType;
    _max?: FavoriteLectureMaxAggregateInputType;
  };

  export type FavoriteLectureGroupByOutputType = {
    userId: string;
    lectureId: string;
    createdAt: Date;
    _count: FavoriteLectureCountAggregateOutputType | null;
    _min: FavoriteLectureMinAggregateOutputType | null;
    _max: FavoriteLectureMaxAggregateOutputType | null;
  };

  type GetFavoriteLectureGroupByPayload<T extends FavoriteLectureGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FavoriteLectureGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof FavoriteLectureGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteLectureGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteLectureGroupByOutputType[P]>;
        }
      >
    >;

  export type FavoriteLectureSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      lectureId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["favoriteLecture"]
  >;

  export type FavoriteLectureSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      lectureId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["favoriteLecture"]
  >;

  export type FavoriteLectureSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      lectureId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      lecture?: boolean | LectureDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["favoriteLecture"]
  >;

  export type FavoriteLectureSelectScalar = {
    userId?: boolean;
    lectureId?: boolean;
    createdAt?: boolean;
  };

  export type FavoriteLectureOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "userId" | "lectureId" | "createdAt",
    ExtArgs["result"]["favoriteLecture"]
  >;
  export type FavoriteLectureInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };
  export type FavoriteLectureIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };
  export type FavoriteLectureIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    lecture?: boolean | LectureDefaultArgs<ExtArgs>;
  };

  export type $FavoriteLecturePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FavoriteLecture";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      lecture: Prisma.$LecturePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        lectureId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["favoriteLecture"]
    >;
    composites: {};
  };

  type FavoriteLectureGetPayload<
    S extends boolean | null | undefined | FavoriteLectureDefaultArgs,
  > = $Result.GetResult<Prisma.$FavoriteLecturePayload, S>;

  type FavoriteLectureCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FavoriteLectureFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: FavoriteLectureCountAggregateInputType | true;
  };

  export interface FavoriteLectureDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FavoriteLecture"];
      meta: { name: "FavoriteLecture" };
    };
    /**
     * Find zero or one FavoriteLecture that matches the filter.
     * @param {FavoriteLectureFindUniqueArgs} args - Arguments to find a FavoriteLecture
     * @example
     * // Get one FavoriteLecture
     * const favoriteLecture = await prisma.favoriteLecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteLectureFindUniqueArgs>(
      args: SelectSubset<T, FavoriteLectureFindUniqueArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<
        Prisma.$FavoriteLecturePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FavoriteLecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteLectureFindUniqueOrThrowArgs} args - Arguments to find a FavoriteLecture
     * @example
     * // Get one FavoriteLecture
     * const favoriteLecture = await prisma.favoriteLecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteLectureFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FavoriteLectureFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<
        Prisma.$FavoriteLecturePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FavoriteLecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureFindFirstArgs} args - Arguments to find a FavoriteLecture
     * @example
     * // Get one FavoriteLecture
     * const favoriteLecture = await prisma.favoriteLecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteLectureFindFirstArgs>(
      args?: SelectSubset<T, FavoriteLectureFindFirstArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<
        Prisma.$FavoriteLecturePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FavoriteLecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureFindFirstOrThrowArgs} args - Arguments to find a FavoriteLecture
     * @example
     * // Get one FavoriteLecture
     * const favoriteLecture = await prisma.favoriteLecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteLectureFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FavoriteLectureFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<
        Prisma.$FavoriteLecturePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FavoriteLectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteLectures
     * const favoriteLectures = await prisma.favoriteLecture.findMany()
     *
     * // Get first 10 FavoriteLectures
     * const favoriteLectures = await prisma.favoriteLecture.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const favoriteLectureWithUserIdOnly = await prisma.favoriteLecture.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends FavoriteLectureFindManyArgs>(
      args?: SelectSubset<T, FavoriteLectureFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a FavoriteLecture.
     * @param {FavoriteLectureCreateArgs} args - Arguments to create a FavoriteLecture.
     * @example
     * // Create one FavoriteLecture
     * const FavoriteLecture = await prisma.favoriteLecture.create({
     *   data: {
     *     // ... data to create a FavoriteLecture
     *   }
     * })
     *
     */
    create<T extends FavoriteLectureCreateArgs>(
      args: SelectSubset<T, FavoriteLectureCreateArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FavoriteLectures.
     * @param {FavoriteLectureCreateManyArgs} args - Arguments to create many FavoriteLectures.
     * @example
     * // Create many FavoriteLectures
     * const favoriteLecture = await prisma.favoriteLecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FavoriteLectureCreateManyArgs>(
      args?: SelectSubset<T, FavoriteLectureCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FavoriteLectures and returns the data saved in the database.
     * @param {FavoriteLectureCreateManyAndReturnArgs} args - Arguments to create many FavoriteLectures.
     * @example
     * // Create many FavoriteLectures
     * const favoriteLecture = await prisma.favoriteLecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FavoriteLectures and only return the `userId`
     * const favoriteLectureWithUserIdOnly = await prisma.favoriteLecture.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FavoriteLectureCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FavoriteLectureCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FavoriteLecturePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FavoriteLecture.
     * @param {FavoriteLectureDeleteArgs} args - Arguments to delete one FavoriteLecture.
     * @example
     * // Delete one FavoriteLecture
     * const FavoriteLecture = await prisma.favoriteLecture.delete({
     *   where: {
     *     // ... filter to delete one FavoriteLecture
     *   }
     * })
     *
     */
    delete<T extends FavoriteLectureDeleteArgs>(
      args: SelectSubset<T, FavoriteLectureDeleteArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FavoriteLecture.
     * @param {FavoriteLectureUpdateArgs} args - Arguments to update one FavoriteLecture.
     * @example
     * // Update one FavoriteLecture
     * const favoriteLecture = await prisma.favoriteLecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FavoriteLectureUpdateArgs>(
      args: SelectSubset<T, FavoriteLectureUpdateArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FavoriteLectures.
     * @param {FavoriteLectureDeleteManyArgs} args - Arguments to filter FavoriteLectures to delete.
     * @example
     * // Delete a few FavoriteLectures
     * const { count } = await prisma.favoriteLecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FavoriteLectureDeleteManyArgs>(
      args?: SelectSubset<T, FavoriteLectureDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FavoriteLectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteLectures
     * const favoriteLecture = await prisma.favoriteLecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FavoriteLectureUpdateManyArgs>(
      args: SelectSubset<T, FavoriteLectureUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FavoriteLectures and returns the data updated in the database.
     * @param {FavoriteLectureUpdateManyAndReturnArgs} args - Arguments to update many FavoriteLectures.
     * @example
     * // Update many FavoriteLectures
     * const favoriteLecture = await prisma.favoriteLecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FavoriteLectures and only return the `userId`
     * const favoriteLectureWithUserIdOnly = await prisma.favoriteLecture.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FavoriteLectureUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FavoriteLectureUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FavoriteLecturePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FavoriteLecture.
     * @param {FavoriteLectureUpsertArgs} args - Arguments to update or create a FavoriteLecture.
     * @example
     * // Update or create a FavoriteLecture
     * const favoriteLecture = await prisma.favoriteLecture.upsert({
     *   create: {
     *     // ... data to create a FavoriteLecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteLecture we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteLectureUpsertArgs>(
      args: SelectSubset<T, FavoriteLectureUpsertArgs<ExtArgs>>,
    ): Prisma__FavoriteLectureClient<
      $Result.GetResult<Prisma.$FavoriteLecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FavoriteLectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureCountArgs} args - Arguments to filter FavoriteLectures to count.
     * @example
     * // Count the number of FavoriteLectures
     * const count = await prisma.favoriteLecture.count({
     *   where: {
     *     // ... the filter for the FavoriteLectures we want to count
     *   }
     * })
     **/
    count<T extends FavoriteLectureCountArgs>(
      args?: Subset<T, FavoriteLectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FavoriteLectureCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FavoriteLecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FavoriteLectureAggregateArgs>(
      args: Subset<T, FavoriteLectureAggregateArgs>,
    ): Prisma.PrismaPromise<GetFavoriteLectureAggregateType<T>>;

    /**
     * Group by FavoriteLecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteLectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FavoriteLectureGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteLectureGroupByArgs["orderBy"] }
        : { orderBy?: FavoriteLectureGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FavoriteLectureGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFavoriteLectureGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FavoriteLecture model
     */
    readonly fields: FavoriteLectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteLecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteLectureClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LectureDefaultArgs<ExtArgs>>,
    ): Prisma__LectureClient<
      | $Result.GetResult<
          Prisma.$LecturePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FavoriteLecture model
   */
  interface FavoriteLectureFieldRefs {
    readonly userId: FieldRef<"FavoriteLecture", "String">;
    readonly lectureId: FieldRef<"FavoriteLecture", "String">;
    readonly createdAt: FieldRef<"FavoriteLecture", "DateTime">;
  }

  // Custom InputTypes
  /**
   * FavoriteLecture findUnique
   */
  export type FavoriteLectureFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * Filter, which FavoriteLecture to fetch.
     */
    where: FavoriteLectureWhereUniqueInput;
  };

  /**
   * FavoriteLecture findUniqueOrThrow
   */
  export type FavoriteLectureFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * Filter, which FavoriteLecture to fetch.
     */
    where: FavoriteLectureWhereUniqueInput;
  };

  /**
   * FavoriteLecture findFirst
   */
  export type FavoriteLectureFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * Filter, which FavoriteLecture to fetch.
     */
    where?: FavoriteLectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FavoriteLectures to fetch.
     */
    orderBy?: FavoriteLectureOrderByWithRelationInput | FavoriteLectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FavoriteLectures.
     */
    cursor?: FavoriteLectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FavoriteLectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FavoriteLectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FavoriteLectures.
     */
    distinct?: FavoriteLectureScalarFieldEnum | FavoriteLectureScalarFieldEnum[];
  };

  /**
   * FavoriteLecture findFirstOrThrow
   */
  export type FavoriteLectureFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * Filter, which FavoriteLecture to fetch.
     */
    where?: FavoriteLectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FavoriteLectures to fetch.
     */
    orderBy?: FavoriteLectureOrderByWithRelationInput | FavoriteLectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FavoriteLectures.
     */
    cursor?: FavoriteLectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FavoriteLectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FavoriteLectures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FavoriteLectures.
     */
    distinct?: FavoriteLectureScalarFieldEnum | FavoriteLectureScalarFieldEnum[];
  };

  /**
   * FavoriteLecture findMany
   */
  export type FavoriteLectureFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * Filter, which FavoriteLectures to fetch.
     */
    where?: FavoriteLectureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FavoriteLectures to fetch.
     */
    orderBy?: FavoriteLectureOrderByWithRelationInput | FavoriteLectureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FavoriteLectures.
     */
    cursor?: FavoriteLectureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FavoriteLectures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FavoriteLectures.
     */
    skip?: number;
    distinct?: FavoriteLectureScalarFieldEnum | FavoriteLectureScalarFieldEnum[];
  };

  /**
   * FavoriteLecture create
   */
  export type FavoriteLectureCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * The data needed to create a FavoriteLecture.
     */
    data: XOR<FavoriteLectureCreateInput, FavoriteLectureUncheckedCreateInput>;
  };

  /**
   * FavoriteLecture createMany
   */
  export type FavoriteLectureCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FavoriteLectures.
     */
    data: FavoriteLectureCreateManyInput | FavoriteLectureCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FavoriteLecture createManyAndReturn
   */
  export type FavoriteLectureCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * The data used to create many FavoriteLectures.
     */
    data: FavoriteLectureCreateManyInput | FavoriteLectureCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FavoriteLecture update
   */
  export type FavoriteLectureUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * The data needed to update a FavoriteLecture.
     */
    data: XOR<FavoriteLectureUpdateInput, FavoriteLectureUncheckedUpdateInput>;
    /**
     * Choose, which FavoriteLecture to update.
     */
    where: FavoriteLectureWhereUniqueInput;
  };

  /**
   * FavoriteLecture updateMany
   */
  export type FavoriteLectureUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FavoriteLectures.
     */
    data: XOR<FavoriteLectureUpdateManyMutationInput, FavoriteLectureUncheckedUpdateManyInput>;
    /**
     * Filter which FavoriteLectures to update
     */
    where?: FavoriteLectureWhereInput;
    /**
     * Limit how many FavoriteLectures to update.
     */
    limit?: number;
  };

  /**
   * FavoriteLecture updateManyAndReturn
   */
  export type FavoriteLectureUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * The data used to update FavoriteLectures.
     */
    data: XOR<FavoriteLectureUpdateManyMutationInput, FavoriteLectureUncheckedUpdateManyInput>;
    /**
     * Filter which FavoriteLectures to update
     */
    where?: FavoriteLectureWhereInput;
    /**
     * Limit how many FavoriteLectures to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FavoriteLecture upsert
   */
  export type FavoriteLectureUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * The filter to search for the FavoriteLecture to update in case it exists.
     */
    where: FavoriteLectureWhereUniqueInput;
    /**
     * In case the FavoriteLecture found by the `where` argument doesn't exist, create a new FavoriteLecture with this data.
     */
    create: XOR<FavoriteLectureCreateInput, FavoriteLectureUncheckedCreateInput>;
    /**
     * In case the FavoriteLecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteLectureUpdateInput, FavoriteLectureUncheckedUpdateInput>;
  };

  /**
   * FavoriteLecture delete
   */
  export type FavoriteLectureDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
    /**
     * Filter which FavoriteLecture to delete.
     */
    where: FavoriteLectureWhereUniqueInput;
  };

  /**
   * FavoriteLecture deleteMany
   */
  export type FavoriteLectureDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FavoriteLectures to delete
     */
    where?: FavoriteLectureWhereInput;
    /**
     * Limit how many FavoriteLectures to delete.
     */
    limit?: number;
  };

  /**
   * FavoriteLecture without action
   */
  export type FavoriteLectureDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FavoriteLecture
     */
    select?: FavoriteLectureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FavoriteLecture
     */
    omit?: FavoriteLectureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteLectureInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const IngestionBatchScalarFieldEnum: {
    id: "id";
    tag: "tag";
    environment: "environment";
    createdAt: "createdAt";
  };

  export type IngestionBatchScalarFieldEnum =
    (typeof IngestionBatchScalarFieldEnum)[keyof typeof IngestionBatchScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: "id";
    email: "email";
    emailNormalized: "emailNormalized";
    emailVerifiedAt: "emailVerifiedAt";
    name: "name";
    preferredLanguage: "preferredLanguage";
    passwordHash: "passwordHash";
    passwordUpdatedAt: "passwordUpdatedAt";
    lastLoginAt: "lastLoginAt";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    deactivatedAt: "deactivatedAt";
    erasureRequestedAt: "erasureRequestedAt";
    erasedAt: "erasedAt";
    isBanned: "isBanned";
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const UserGlobalRoleScalarFieldEnum: {
    userId: "userId";
    role: "role";
    createdAt: "createdAt";
  };

  export type UserGlobalRoleScalarFieldEnum =
    (typeof UserGlobalRoleScalarFieldEnum)[keyof typeof UserGlobalRoleScalarFieldEnum];

  export const UserScholarRoleScalarFieldEnum: {
    userId: "userId";
    scholarId: "scholarId";
    role: "role";
    createdAt: "createdAt";
    createdByUserId: "createdByUserId";
  };

  export type UserScholarRoleScalarFieldEnum =
    (typeof UserScholarRoleScalarFieldEnum)[keyof typeof UserScholarRoleScalarFieldEnum];

  export const ScholarScalarFieldEnum: {
    id: "id";
    slug: "slug";
    name: "name";
    bio: "bio";
    country: "country";
    mainLanguage: "mainLanguage";
    imageUrl: "imageUrl";
    isActive: "isActive";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    ingestionBatchId: "ingestionBatchId";
  };

  export type ScholarScalarFieldEnum =
    (typeof ScholarScalarFieldEnum)[keyof typeof ScholarScalarFieldEnum];

  export const CollectionScalarFieldEnum: {
    id: "id";
    scholarId: "scholarId";
    slug: "slug";
    title: "title";
    description: "description";
    coverImageUrl: "coverImageUrl";
    language: "language";
    status: "status";
    orderIndex: "orderIndex";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    deletedAt: "deletedAt";
    deleteAfterAt: "deleteAfterAt";
    ingestionBatchId: "ingestionBatchId";
  };

  export type CollectionScalarFieldEnum =
    (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum];

  export const SeriesScalarFieldEnum: {
    id: "id";
    scholarId: "scholarId";
    collectionId: "collectionId";
    slug: "slug";
    title: "title";
    description: "description";
    coverImageUrl: "coverImageUrl";
    language: "language";
    status: "status";
    orderIndex: "orderIndex";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    deletedAt: "deletedAt";
    deleteAfterAt: "deleteAfterAt";
    ingestionBatchId: "ingestionBatchId";
  };

  export type SeriesScalarFieldEnum =
    (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum];

  export const LectureScalarFieldEnum: {
    id: "id";
    scholarId: "scholarId";
    seriesId: "seriesId";
    slug: "slug";
    title: "title";
    description: "description";
    language: "language";
    status: "status";
    publishedAt: "publishedAt";
    orderIndex: "orderIndex";
    durationSeconds: "durationSeconds";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    deletedAt: "deletedAt";
    deleteAfterAt: "deleteAfterAt";
    ingestionBatchId: "ingestionBatchId";
  };

  export type LectureScalarFieldEnum =
    (typeof LectureScalarFieldEnum)[keyof typeof LectureScalarFieldEnum];

  export const AudioAssetScalarFieldEnum: {
    id: "id";
    lectureId: "lectureId";
    url: "url";
    format: "format";
    bitrateKbps: "bitrateKbps";
    sizeBytes: "sizeBytes";
    durationSeconds: "durationSeconds";
    source: "source";
    isPrimary: "isPrimary";
    createdAt: "createdAt";
    ingestionBatchId: "ingestionBatchId";
  };

  export type AudioAssetScalarFieldEnum =
    (typeof AudioAssetScalarFieldEnum)[keyof typeof AudioAssetScalarFieldEnum];

  export const TopicScalarFieldEnum: {
    id: "id";
    slug: "slug";
    name: "name";
    parentId: "parentId";
    createdAt: "createdAt";
  };

  export type TopicScalarFieldEnum =
    (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum];

  export const LectureTopicScalarFieldEnum: {
    lectureId: "lectureId";
    topicId: "topicId";
    createdAt: "createdAt";
  };

  export type LectureTopicScalarFieldEnum =
    (typeof LectureTopicScalarFieldEnum)[keyof typeof LectureTopicScalarFieldEnum];

  export const SeriesTopicScalarFieldEnum: {
    seriesId: "seriesId";
    topicId: "topicId";
    createdAt: "createdAt";
  };

  export type SeriesTopicScalarFieldEnum =
    (typeof SeriesTopicScalarFieldEnum)[keyof typeof SeriesTopicScalarFieldEnum];

  export const CollectionTopicScalarFieldEnum: {
    collectionId: "collectionId";
    topicId: "topicId";
    createdAt: "createdAt";
  };

  export type CollectionTopicScalarFieldEnum =
    (typeof CollectionTopicScalarFieldEnum)[keyof typeof CollectionTopicScalarFieldEnum];

  export const UserLectureProgressScalarFieldEnum: {
    userId: "userId";
    lectureId: "lectureId";
    positionSeconds: "positionSeconds";
    isCompleted: "isCompleted";
    updatedAt: "updatedAt";
  };

  export type UserLectureProgressScalarFieldEnum =
    (typeof UserLectureProgressScalarFieldEnum)[keyof typeof UserLectureProgressScalarFieldEnum];

  export const FavoriteLectureScalarFieldEnum: {
    userId: "userId";
    lectureId: "lectureId";
    createdAt: "createdAt";
  };

  export type FavoriteLectureScalarFieldEnum =
    (typeof FavoriteLectureScalarFieldEnum)[keyof typeof FavoriteLectureScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String">;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String[]">;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime">;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Boolean">;

  /**
   * Reference to a field of type 'GlobalRole'
   */
  export type EnumGlobalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "GlobalRole"
  >;

  /**
   * Reference to a field of type 'GlobalRole[]'
   */
  export type ListEnumGlobalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "GlobalRole[]"
  >;

  /**
   * Reference to a field of type 'ScholarRole'
   */
  export type EnumScholarRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ScholarRole"
  >;

  /**
   * Reference to a field of type 'ScholarRole[]'
   */
  export type ListEnumScholarRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ScholarRole[]"
  >;

  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Status">;

  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Status[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int">;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int[]">;

  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "BigInt">;

  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "BigInt[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float">;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float[]">;

  /**
   * Deep Input Types
   */

  export type IngestionBatchWhereInput = {
    AND?: IngestionBatchWhereInput | IngestionBatchWhereInput[];
    OR?: IngestionBatchWhereInput[];
    NOT?: IngestionBatchWhereInput | IngestionBatchWhereInput[];
    id?: StringFilter<"IngestionBatch"> | string;
    tag?: StringFilter<"IngestionBatch"> | string;
    environment?: StringFilter<"IngestionBatch"> | string;
    createdAt?: DateTimeFilter<"IngestionBatch"> | Date | string;
    scholars?: ScholarListRelationFilter;
    collections?: CollectionListRelationFilter;
    series?: SeriesListRelationFilter;
    lectures?: LectureListRelationFilter;
    audioAssets?: AudioAssetListRelationFilter;
  };

  export type IngestionBatchOrderByWithRelationInput = {
    id?: SortOrder;
    tag?: SortOrder;
    environment?: SortOrder;
    createdAt?: SortOrder;
    scholars?: ScholarOrderByRelationAggregateInput;
    collections?: CollectionOrderByRelationAggregateInput;
    series?: SeriesOrderByRelationAggregateInput;
    lectures?: LectureOrderByRelationAggregateInput;
    audioAssets?: AudioAssetOrderByRelationAggregateInput;
  };

  export type IngestionBatchWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      tag_environment?: IngestionBatchTagEnvironmentCompoundUniqueInput;
      AND?: IngestionBatchWhereInput | IngestionBatchWhereInput[];
      OR?: IngestionBatchWhereInput[];
      NOT?: IngestionBatchWhereInput | IngestionBatchWhereInput[];
      tag?: StringFilter<"IngestionBatch"> | string;
      environment?: StringFilter<"IngestionBatch"> | string;
      createdAt?: DateTimeFilter<"IngestionBatch"> | Date | string;
      scholars?: ScholarListRelationFilter;
      collections?: CollectionListRelationFilter;
      series?: SeriesListRelationFilter;
      lectures?: LectureListRelationFilter;
      audioAssets?: AudioAssetListRelationFilter;
    },
    "id" | "tag_environment"
  >;

  export type IngestionBatchOrderByWithAggregationInput = {
    id?: SortOrder;
    tag?: SortOrder;
    environment?: SortOrder;
    createdAt?: SortOrder;
    _count?: IngestionBatchCountOrderByAggregateInput;
    _max?: IngestionBatchMaxOrderByAggregateInput;
    _min?: IngestionBatchMinOrderByAggregateInput;
  };

  export type IngestionBatchScalarWhereWithAggregatesInput = {
    AND?:
      | IngestionBatchScalarWhereWithAggregatesInput
      | IngestionBatchScalarWhereWithAggregatesInput[];
    OR?: IngestionBatchScalarWhereWithAggregatesInput[];
    NOT?:
      | IngestionBatchScalarWhereWithAggregatesInput
      | IngestionBatchScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IngestionBatch"> | string;
    tag?: StringWithAggregatesFilter<"IngestionBatch"> | string;
    environment?: StringWithAggregatesFilter<"IngestionBatch"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"IngestionBatch"> | Date | string;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    email?: StringNullableFilter<"User"> | string | null;
    emailNormalized?: StringNullableFilter<"User"> | string | null;
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    name?: StringNullableFilter<"User"> | string | null;
    preferredLanguage?: StringNullableFilter<"User"> | string | null;
    passwordHash?: StringNullableFilter<"User"> | string | null;
    passwordUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    deactivatedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    erasureRequestedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    erasedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    isBanned?: BoolFilter<"User"> | boolean;
    globalRoles?: UserGlobalRoleListRelationFilter;
    scholarRoles?: UserScholarRoleListRelationFilter;
    createdScholarRoles?: UserScholarRoleListRelationFilter;
    progress?: UserLectureProgressListRelationFilter;
    favorites?: FavoriteLectureListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrderInput | SortOrder;
    emailNormalized?: SortOrderInput | SortOrder;
    emailVerifiedAt?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    preferredLanguage?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    passwordUpdatedAt?: SortOrderInput | SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deactivatedAt?: SortOrderInput | SortOrder;
    erasureRequestedAt?: SortOrderInput | SortOrder;
    erasedAt?: SortOrderInput | SortOrder;
    isBanned?: SortOrder;
    globalRoles?: UserGlobalRoleOrderByRelationAggregateInput;
    scholarRoles?: UserScholarRoleOrderByRelationAggregateInput;
    createdScholarRoles?: UserScholarRoleOrderByRelationAggregateInput;
    progress?: UserLectureProgressOrderByRelationAggregateInput;
    favorites?: FavoriteLectureOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      email?: StringNullableFilter<"User"> | string | null;
      emailNormalized?: StringNullableFilter<"User"> | string | null;
      emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      name?: StringNullableFilter<"User"> | string | null;
      preferredLanguage?: StringNullableFilter<"User"> | string | null;
      passwordHash?: StringNullableFilter<"User"> | string | null;
      passwordUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      deactivatedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      erasureRequestedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      erasedAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      isBanned?: BoolFilter<"User"> | boolean;
      globalRoles?: UserGlobalRoleListRelationFilter;
      scholarRoles?: UserScholarRoleListRelationFilter;
      createdScholarRoles?: UserScholarRoleListRelationFilter;
      progress?: UserLectureProgressListRelationFilter;
      favorites?: FavoriteLectureListRelationFilter;
    },
    "id"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrderInput | SortOrder;
    emailNormalized?: SortOrderInput | SortOrder;
    emailVerifiedAt?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    preferredLanguage?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    passwordUpdatedAt?: SortOrderInput | SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deactivatedAt?: SortOrderInput | SortOrder;
    erasureRequestedAt?: SortOrderInput | SortOrder;
    erasedAt?: SortOrderInput | SortOrder;
    isBanned?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    email?: StringNullableWithAggregatesFilter<"User"> | string | null;
    emailNormalized?: StringNullableWithAggregatesFilter<"User"> | string | null;
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    preferredLanguage?: StringNullableWithAggregatesFilter<"User"> | string | null;
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null;
    passwordUpdatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    deactivatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    erasureRequestedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    erasedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean;
  };

  export type UserGlobalRoleWhereInput = {
    AND?: UserGlobalRoleWhereInput | UserGlobalRoleWhereInput[];
    OR?: UserGlobalRoleWhereInput[];
    NOT?: UserGlobalRoleWhereInput | UserGlobalRoleWhereInput[];
    userId?: StringFilter<"UserGlobalRole"> | string;
    role?: EnumGlobalRoleFilter<"UserGlobalRole"> | $Enums.GlobalRole;
    createdAt?: DateTimeFilter<"UserGlobalRole"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type UserGlobalRoleOrderByWithRelationInput = {
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type UserGlobalRoleWhereUniqueInput = Prisma.AtLeast<
    {
      userId_role?: UserGlobalRoleUserIdRoleCompoundUniqueInput;
      AND?: UserGlobalRoleWhereInput | UserGlobalRoleWhereInput[];
      OR?: UserGlobalRoleWhereInput[];
      NOT?: UserGlobalRoleWhereInput | UserGlobalRoleWhereInput[];
      userId?: StringFilter<"UserGlobalRole"> | string;
      role?: EnumGlobalRoleFilter<"UserGlobalRole"> | $Enums.GlobalRole;
      createdAt?: DateTimeFilter<"UserGlobalRole"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "userId_role"
  >;

  export type UserGlobalRoleOrderByWithAggregationInput = {
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserGlobalRoleCountOrderByAggregateInput;
    _max?: UserGlobalRoleMaxOrderByAggregateInput;
    _min?: UserGlobalRoleMinOrderByAggregateInput;
  };

  export type UserGlobalRoleScalarWhereWithAggregatesInput = {
    AND?:
      | UserGlobalRoleScalarWhereWithAggregatesInput
      | UserGlobalRoleScalarWhereWithAggregatesInput[];
    OR?: UserGlobalRoleScalarWhereWithAggregatesInput[];
    NOT?:
      | UserGlobalRoleScalarWhereWithAggregatesInput
      | UserGlobalRoleScalarWhereWithAggregatesInput[];
    userId?: StringWithAggregatesFilter<"UserGlobalRole"> | string;
    role?: EnumGlobalRoleWithAggregatesFilter<"UserGlobalRole"> | $Enums.GlobalRole;
    createdAt?: DateTimeWithAggregatesFilter<"UserGlobalRole"> | Date | string;
  };

  export type UserScholarRoleWhereInput = {
    AND?: UserScholarRoleWhereInput | UserScholarRoleWhereInput[];
    OR?: UserScholarRoleWhereInput[];
    NOT?: UserScholarRoleWhereInput | UserScholarRoleWhereInput[];
    userId?: StringFilter<"UserScholarRole"> | string;
    scholarId?: StringFilter<"UserScholarRole"> | string;
    role?: EnumScholarRoleFilter<"UserScholarRole"> | $Enums.ScholarRole;
    createdAt?: DateTimeFilter<"UserScholarRole"> | Date | string;
    createdByUserId?: StringNullableFilter<"UserScholarRole"> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type UserScholarRoleOrderByWithRelationInput = {
    userId?: SortOrder;
    scholarId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    createdByUserId?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
    scholar?: ScholarOrderByWithRelationInput;
    createdByUser?: UserOrderByWithRelationInput;
  };

  export type UserScholarRoleWhereUniqueInput = Prisma.AtLeast<
    {
      userId_scholarId_role?: UserScholarRoleUserIdScholarIdRoleCompoundUniqueInput;
      AND?: UserScholarRoleWhereInput | UserScholarRoleWhereInput[];
      OR?: UserScholarRoleWhereInput[];
      NOT?: UserScholarRoleWhereInput | UserScholarRoleWhereInput[];
      userId?: StringFilter<"UserScholarRole"> | string;
      scholarId?: StringFilter<"UserScholarRole"> | string;
      role?: EnumScholarRoleFilter<"UserScholarRole"> | $Enums.ScholarRole;
      createdAt?: DateTimeFilter<"UserScholarRole"> | Date | string;
      createdByUserId?: StringNullableFilter<"UserScholarRole"> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
      createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    "userId_scholarId_role"
  >;

  export type UserScholarRoleOrderByWithAggregationInput = {
    userId?: SortOrder;
    scholarId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    createdByUserId?: SortOrderInput | SortOrder;
    _count?: UserScholarRoleCountOrderByAggregateInput;
    _max?: UserScholarRoleMaxOrderByAggregateInput;
    _min?: UserScholarRoleMinOrderByAggregateInput;
  };

  export type UserScholarRoleScalarWhereWithAggregatesInput = {
    AND?:
      | UserScholarRoleScalarWhereWithAggregatesInput
      | UserScholarRoleScalarWhereWithAggregatesInput[];
    OR?: UserScholarRoleScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScholarRoleScalarWhereWithAggregatesInput
      | UserScholarRoleScalarWhereWithAggregatesInput[];
    userId?: StringWithAggregatesFilter<"UserScholarRole"> | string;
    scholarId?: StringWithAggregatesFilter<"UserScholarRole"> | string;
    role?: EnumScholarRoleWithAggregatesFilter<"UserScholarRole"> | $Enums.ScholarRole;
    createdAt?: DateTimeWithAggregatesFilter<"UserScholarRole"> | Date | string;
    createdByUserId?: StringNullableWithAggregatesFilter<"UserScholarRole"> | string | null;
  };

  export type ScholarWhereInput = {
    AND?: ScholarWhereInput | ScholarWhereInput[];
    OR?: ScholarWhereInput[];
    NOT?: ScholarWhereInput | ScholarWhereInput[];
    id?: StringFilter<"Scholar"> | string;
    slug?: StringFilter<"Scholar"> | string;
    name?: StringFilter<"Scholar"> | string;
    bio?: StringNullableFilter<"Scholar"> | string | null;
    country?: StringNullableFilter<"Scholar"> | string | null;
    mainLanguage?: StringNullableFilter<"Scholar"> | string | null;
    imageUrl?: StringNullableFilter<"Scholar"> | string | null;
    isActive?: BoolFilter<"Scholar"> | boolean;
    createdAt?: DateTimeFilter<"Scholar"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Scholar"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Scholar"> | string | null;
    ingestionBatch?: XOR<
      IngestionBatchNullableScalarRelationFilter,
      IngestionBatchWhereInput
    > | null;
    collections?: CollectionListRelationFilter;
    series?: SeriesListRelationFilter;
    lectures?: LectureListRelationFilter;
    userRoles?: UserScholarRoleListRelationFilter;
  };

  export type ScholarOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    mainLanguage?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    ingestionBatch?: IngestionBatchOrderByWithRelationInput;
    collections?: CollectionOrderByRelationAggregateInput;
    series?: SeriesOrderByRelationAggregateInput;
    lectures?: LectureOrderByRelationAggregateInput;
    userRoles?: UserScholarRoleOrderByRelationAggregateInput;
  };

  export type ScholarWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: ScholarWhereInput | ScholarWhereInput[];
      OR?: ScholarWhereInput[];
      NOT?: ScholarWhereInput | ScholarWhereInput[];
      name?: StringFilter<"Scholar"> | string;
      bio?: StringNullableFilter<"Scholar"> | string | null;
      country?: StringNullableFilter<"Scholar"> | string | null;
      mainLanguage?: StringNullableFilter<"Scholar"> | string | null;
      imageUrl?: StringNullableFilter<"Scholar"> | string | null;
      isActive?: BoolFilter<"Scholar"> | boolean;
      createdAt?: DateTimeFilter<"Scholar"> | Date | string;
      updatedAt?: DateTimeNullableFilter<"Scholar"> | Date | string | null;
      ingestionBatchId?: StringNullableFilter<"Scholar"> | string | null;
      ingestionBatch?: XOR<
        IngestionBatchNullableScalarRelationFilter,
        IngestionBatchWhereInput
      > | null;
      collections?: CollectionListRelationFilter;
      series?: SeriesListRelationFilter;
      lectures?: LectureListRelationFilter;
      userRoles?: UserScholarRoleListRelationFilter;
    },
    "id" | "slug"
  >;

  export type ScholarOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    mainLanguage?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    _count?: ScholarCountOrderByAggregateInput;
    _max?: ScholarMaxOrderByAggregateInput;
    _min?: ScholarMinOrderByAggregateInput;
  };

  export type ScholarScalarWhereWithAggregatesInput = {
    AND?: ScholarScalarWhereWithAggregatesInput | ScholarScalarWhereWithAggregatesInput[];
    OR?: ScholarScalarWhereWithAggregatesInput[];
    NOT?: ScholarScalarWhereWithAggregatesInput | ScholarScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Scholar"> | string;
    slug?: StringWithAggregatesFilter<"Scholar"> | string;
    name?: StringWithAggregatesFilter<"Scholar"> | string;
    bio?: StringNullableWithAggregatesFilter<"Scholar"> | string | null;
    country?: StringNullableWithAggregatesFilter<"Scholar"> | string | null;
    mainLanguage?: StringNullableWithAggregatesFilter<"Scholar"> | string | null;
    imageUrl?: StringNullableWithAggregatesFilter<"Scholar"> | string | null;
    isActive?: BoolWithAggregatesFilter<"Scholar"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Scholar"> | Date | string;
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Scholar"> | Date | string | null;
    ingestionBatchId?: StringNullableWithAggregatesFilter<"Scholar"> | string | null;
  };

  export type CollectionWhereInput = {
    AND?: CollectionWhereInput | CollectionWhereInput[];
    OR?: CollectionWhereInput[];
    NOT?: CollectionWhereInput | CollectionWhereInput[];
    id?: StringFilter<"Collection"> | string;
    scholarId?: StringFilter<"Collection"> | string;
    slug?: StringFilter<"Collection"> | string;
    title?: StringFilter<"Collection"> | string;
    description?: StringNullableFilter<"Collection"> | string | null;
    coverImageUrl?: StringNullableFilter<"Collection"> | string | null;
    language?: StringNullableFilter<"Collection"> | string | null;
    status?: EnumStatusFilter<"Collection"> | $Enums.Status;
    orderIndex?: IntNullableFilter<"Collection"> | number | null;
    createdAt?: DateTimeFilter<"Collection"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
    deletedAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Collection"> | string | null;
    ingestionBatch?: XOR<
      IngestionBatchNullableScalarRelationFilter,
      IngestionBatchWhereInput
    > | null;
    scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
    series?: SeriesListRelationFilter;
    topics?: CollectionTopicListRelationFilter;
  };

  export type CollectionOrderByWithRelationInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    coverImageUrl?: SortOrderInput | SortOrder;
    language?: SortOrderInput | SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    deleteAfterAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    ingestionBatch?: IngestionBatchOrderByWithRelationInput;
    scholar?: ScholarOrderByWithRelationInput;
    series?: SeriesOrderByRelationAggregateInput;
    topics?: CollectionTopicOrderByRelationAggregateInput;
  };

  export type CollectionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      scholarId_slug?: CollectionScholarIdSlugCompoundUniqueInput;
      AND?: CollectionWhereInput | CollectionWhereInput[];
      OR?: CollectionWhereInput[];
      NOT?: CollectionWhereInput | CollectionWhereInput[];
      scholarId?: StringFilter<"Collection"> | string;
      slug?: StringFilter<"Collection"> | string;
      title?: StringFilter<"Collection"> | string;
      description?: StringNullableFilter<"Collection"> | string | null;
      coverImageUrl?: StringNullableFilter<"Collection"> | string | null;
      language?: StringNullableFilter<"Collection"> | string | null;
      status?: EnumStatusFilter<"Collection"> | $Enums.Status;
      orderIndex?: IntNullableFilter<"Collection"> | number | null;
      createdAt?: DateTimeFilter<"Collection"> | Date | string;
      updatedAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
      deletedAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
      deleteAfterAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
      ingestionBatchId?: StringNullableFilter<"Collection"> | string | null;
      ingestionBatch?: XOR<
        IngestionBatchNullableScalarRelationFilter,
        IngestionBatchWhereInput
      > | null;
      scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
      series?: SeriesListRelationFilter;
      topics?: CollectionTopicListRelationFilter;
    },
    "id" | "scholarId_slug"
  >;

  export type CollectionOrderByWithAggregationInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    coverImageUrl?: SortOrderInput | SortOrder;
    language?: SortOrderInput | SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    deleteAfterAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    _count?: CollectionCountOrderByAggregateInput;
    _avg?: CollectionAvgOrderByAggregateInput;
    _max?: CollectionMaxOrderByAggregateInput;
    _min?: CollectionMinOrderByAggregateInput;
    _sum?: CollectionSumOrderByAggregateInput;
  };

  export type CollectionScalarWhereWithAggregatesInput = {
    AND?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[];
    OR?: CollectionScalarWhereWithAggregatesInput[];
    NOT?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Collection"> | string;
    scholarId?: StringWithAggregatesFilter<"Collection"> | string;
    slug?: StringWithAggregatesFilter<"Collection"> | string;
    title?: StringWithAggregatesFilter<"Collection"> | string;
    description?: StringNullableWithAggregatesFilter<"Collection"> | string | null;
    coverImageUrl?: StringNullableWithAggregatesFilter<"Collection"> | string | null;
    language?: StringNullableWithAggregatesFilter<"Collection"> | string | null;
    status?: EnumStatusWithAggregatesFilter<"Collection"> | $Enums.Status;
    orderIndex?: IntNullableWithAggregatesFilter<"Collection"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"Collection"> | Date | string;
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Collection"> | Date | string | null;
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Collection"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableWithAggregatesFilter<"Collection"> | Date | string | null;
    ingestionBatchId?: StringNullableWithAggregatesFilter<"Collection"> | string | null;
  };

  export type SeriesWhereInput = {
    AND?: SeriesWhereInput | SeriesWhereInput[];
    OR?: SeriesWhereInput[];
    NOT?: SeriesWhereInput | SeriesWhereInput[];
    id?: StringFilter<"Series"> | string;
    scholarId?: StringFilter<"Series"> | string;
    collectionId?: StringNullableFilter<"Series"> | string | null;
    slug?: StringFilter<"Series"> | string;
    title?: StringFilter<"Series"> | string;
    description?: StringNullableFilter<"Series"> | string | null;
    coverImageUrl?: StringNullableFilter<"Series"> | string | null;
    language?: StringNullableFilter<"Series"> | string | null;
    status?: EnumStatusFilter<"Series"> | $Enums.Status;
    orderIndex?: IntNullableFilter<"Series"> | number | null;
    createdAt?: DateTimeFilter<"Series"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
    deletedAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Series"> | string | null;
    ingestionBatch?: XOR<
      IngestionBatchNullableScalarRelationFilter,
      IngestionBatchWhereInput
    > | null;
    scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null;
    lectures?: LectureListRelationFilter;
    topics?: SeriesTopicListRelationFilter;
  };

  export type SeriesOrderByWithRelationInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    collectionId?: SortOrderInput | SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    coverImageUrl?: SortOrderInput | SortOrder;
    language?: SortOrderInput | SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    deleteAfterAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    ingestionBatch?: IngestionBatchOrderByWithRelationInput;
    scholar?: ScholarOrderByWithRelationInput;
    collection?: CollectionOrderByWithRelationInput;
    lectures?: LectureOrderByRelationAggregateInput;
    topics?: SeriesTopicOrderByRelationAggregateInput;
  };

  export type SeriesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      scholarId_slug?: SeriesScholarIdSlugCompoundUniqueInput;
      AND?: SeriesWhereInput | SeriesWhereInput[];
      OR?: SeriesWhereInput[];
      NOT?: SeriesWhereInput | SeriesWhereInput[];
      scholarId?: StringFilter<"Series"> | string;
      collectionId?: StringNullableFilter<"Series"> | string | null;
      slug?: StringFilter<"Series"> | string;
      title?: StringFilter<"Series"> | string;
      description?: StringNullableFilter<"Series"> | string | null;
      coverImageUrl?: StringNullableFilter<"Series"> | string | null;
      language?: StringNullableFilter<"Series"> | string | null;
      status?: EnumStatusFilter<"Series"> | $Enums.Status;
      orderIndex?: IntNullableFilter<"Series"> | number | null;
      createdAt?: DateTimeFilter<"Series"> | Date | string;
      updatedAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
      deletedAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
      deleteAfterAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
      ingestionBatchId?: StringNullableFilter<"Series"> | string | null;
      ingestionBatch?: XOR<
        IngestionBatchNullableScalarRelationFilter,
        IngestionBatchWhereInput
      > | null;
      scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
      collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null;
      lectures?: LectureListRelationFilter;
      topics?: SeriesTopicListRelationFilter;
    },
    "id" | "scholarId_slug"
  >;

  export type SeriesOrderByWithAggregationInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    collectionId?: SortOrderInput | SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    coverImageUrl?: SortOrderInput | SortOrder;
    language?: SortOrderInput | SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    deleteAfterAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    _count?: SeriesCountOrderByAggregateInput;
    _avg?: SeriesAvgOrderByAggregateInput;
    _max?: SeriesMaxOrderByAggregateInput;
    _min?: SeriesMinOrderByAggregateInput;
    _sum?: SeriesSumOrderByAggregateInput;
  };

  export type SeriesScalarWhereWithAggregatesInput = {
    AND?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[];
    OR?: SeriesScalarWhereWithAggregatesInput[];
    NOT?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Series"> | string;
    scholarId?: StringWithAggregatesFilter<"Series"> | string;
    collectionId?: StringNullableWithAggregatesFilter<"Series"> | string | null;
    slug?: StringWithAggregatesFilter<"Series"> | string;
    title?: StringWithAggregatesFilter<"Series"> | string;
    description?: StringNullableWithAggregatesFilter<"Series"> | string | null;
    coverImageUrl?: StringNullableWithAggregatesFilter<"Series"> | string | null;
    language?: StringNullableWithAggregatesFilter<"Series"> | string | null;
    status?: EnumStatusWithAggregatesFilter<"Series"> | $Enums.Status;
    orderIndex?: IntNullableWithAggregatesFilter<"Series"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string;
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Series"> | Date | string | null;
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Series"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableWithAggregatesFilter<"Series"> | Date | string | null;
    ingestionBatchId?: StringNullableWithAggregatesFilter<"Series"> | string | null;
  };

  export type LectureWhereInput = {
    AND?: LectureWhereInput | LectureWhereInput[];
    OR?: LectureWhereInput[];
    NOT?: LectureWhereInput | LectureWhereInput[];
    id?: StringFilter<"Lecture"> | string;
    scholarId?: StringFilter<"Lecture"> | string;
    seriesId?: StringNullableFilter<"Lecture"> | string | null;
    slug?: StringFilter<"Lecture"> | string;
    title?: StringFilter<"Lecture"> | string;
    description?: StringNullableFilter<"Lecture"> | string | null;
    language?: StringNullableFilter<"Lecture"> | string | null;
    status?: EnumStatusFilter<"Lecture"> | $Enums.Status;
    publishedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    orderIndex?: IntNullableFilter<"Lecture"> | number | null;
    durationSeconds?: IntNullableFilter<"Lecture"> | number | null;
    createdAt?: DateTimeFilter<"Lecture"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    deletedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Lecture"> | string | null;
    ingestionBatch?: XOR<
      IngestionBatchNullableScalarRelationFilter,
      IngestionBatchWhereInput
    > | null;
    scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null;
    audioAssets?: AudioAssetListRelationFilter;
    topics?: LectureTopicListRelationFilter;
    progress?: UserLectureProgressListRelationFilter;
    favorites?: FavoriteLectureListRelationFilter;
  };

  export type LectureOrderByWithRelationInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    seriesId?: SortOrderInput | SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    language?: SortOrderInput | SortOrder;
    status?: SortOrder;
    publishedAt?: SortOrderInput | SortOrder;
    orderIndex?: SortOrderInput | SortOrder;
    durationSeconds?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    deleteAfterAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    ingestionBatch?: IngestionBatchOrderByWithRelationInput;
    scholar?: ScholarOrderByWithRelationInput;
    series?: SeriesOrderByWithRelationInput;
    audioAssets?: AudioAssetOrderByRelationAggregateInput;
    topics?: LectureTopicOrderByRelationAggregateInput;
    progress?: UserLectureProgressOrderByRelationAggregateInput;
    favorites?: FavoriteLectureOrderByRelationAggregateInput;
  };

  export type LectureWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      scholarId_slug?: LectureScholarIdSlugCompoundUniqueInput;
      AND?: LectureWhereInput | LectureWhereInput[];
      OR?: LectureWhereInput[];
      NOT?: LectureWhereInput | LectureWhereInput[];
      scholarId?: StringFilter<"Lecture"> | string;
      seriesId?: StringNullableFilter<"Lecture"> | string | null;
      slug?: StringFilter<"Lecture"> | string;
      title?: StringFilter<"Lecture"> | string;
      description?: StringNullableFilter<"Lecture"> | string | null;
      language?: StringNullableFilter<"Lecture"> | string | null;
      status?: EnumStatusFilter<"Lecture"> | $Enums.Status;
      publishedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
      orderIndex?: IntNullableFilter<"Lecture"> | number | null;
      durationSeconds?: IntNullableFilter<"Lecture"> | number | null;
      createdAt?: DateTimeFilter<"Lecture"> | Date | string;
      updatedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
      deletedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
      deleteAfterAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
      ingestionBatchId?: StringNullableFilter<"Lecture"> | string | null;
      ingestionBatch?: XOR<
        IngestionBatchNullableScalarRelationFilter,
        IngestionBatchWhereInput
      > | null;
      scholar?: XOR<ScholarScalarRelationFilter, ScholarWhereInput>;
      series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null;
      audioAssets?: AudioAssetListRelationFilter;
      topics?: LectureTopicListRelationFilter;
      progress?: UserLectureProgressListRelationFilter;
      favorites?: FavoriteLectureListRelationFilter;
    },
    "id" | "scholarId_slug"
  >;

  export type LectureOrderByWithAggregationInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    seriesId?: SortOrderInput | SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    language?: SortOrderInput | SortOrder;
    status?: SortOrder;
    publishedAt?: SortOrderInput | SortOrder;
    orderIndex?: SortOrderInput | SortOrder;
    durationSeconds?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    deleteAfterAt?: SortOrderInput | SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    _count?: LectureCountOrderByAggregateInput;
    _avg?: LectureAvgOrderByAggregateInput;
    _max?: LectureMaxOrderByAggregateInput;
    _min?: LectureMinOrderByAggregateInput;
    _sum?: LectureSumOrderByAggregateInput;
  };

  export type LectureScalarWhereWithAggregatesInput = {
    AND?: LectureScalarWhereWithAggregatesInput | LectureScalarWhereWithAggregatesInput[];
    OR?: LectureScalarWhereWithAggregatesInput[];
    NOT?: LectureScalarWhereWithAggregatesInput | LectureScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Lecture"> | string;
    scholarId?: StringWithAggregatesFilter<"Lecture"> | string;
    seriesId?: StringNullableWithAggregatesFilter<"Lecture"> | string | null;
    slug?: StringWithAggregatesFilter<"Lecture"> | string;
    title?: StringWithAggregatesFilter<"Lecture"> | string;
    description?: StringNullableWithAggregatesFilter<"Lecture"> | string | null;
    language?: StringNullableWithAggregatesFilter<"Lecture"> | string | null;
    status?: EnumStatusWithAggregatesFilter<"Lecture"> | $Enums.Status;
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null;
    orderIndex?: IntNullableWithAggregatesFilter<"Lecture"> | number | null;
    durationSeconds?: IntNullableWithAggregatesFilter<"Lecture"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"Lecture"> | Date | string;
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null;
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null;
    ingestionBatchId?: StringNullableWithAggregatesFilter<"Lecture"> | string | null;
  };

  export type AudioAssetWhereInput = {
    AND?: AudioAssetWhereInput | AudioAssetWhereInput[];
    OR?: AudioAssetWhereInput[];
    NOT?: AudioAssetWhereInput | AudioAssetWhereInput[];
    id?: StringFilter<"AudioAsset"> | string;
    lectureId?: StringFilter<"AudioAsset"> | string;
    url?: StringFilter<"AudioAsset"> | string;
    format?: StringNullableFilter<"AudioAsset"> | string | null;
    bitrateKbps?: IntNullableFilter<"AudioAsset"> | number | null;
    sizeBytes?: BigIntNullableFilter<"AudioAsset"> | bigint | number | null;
    durationSeconds?: IntNullableFilter<"AudioAsset"> | number | null;
    source?: StringNullableFilter<"AudioAsset"> | string | null;
    isPrimary?: BoolFilter<"AudioAsset"> | boolean;
    createdAt?: DateTimeFilter<"AudioAsset"> | Date | string;
    ingestionBatchId?: StringNullableFilter<"AudioAsset"> | string | null;
    ingestionBatch?: XOR<
      IngestionBatchNullableScalarRelationFilter,
      IngestionBatchWhereInput
    > | null;
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
  };

  export type AudioAssetOrderByWithRelationInput = {
    id?: SortOrder;
    lectureId?: SortOrder;
    url?: SortOrder;
    format?: SortOrderInput | SortOrder;
    bitrateKbps?: SortOrderInput | SortOrder;
    sizeBytes?: SortOrderInput | SortOrder;
    durationSeconds?: SortOrderInput | SortOrder;
    source?: SortOrderInput | SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    ingestionBatch?: IngestionBatchOrderByWithRelationInput;
    lecture?: LectureOrderByWithRelationInput;
  };

  export type AudioAssetWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AudioAssetWhereInput | AudioAssetWhereInput[];
      OR?: AudioAssetWhereInput[];
      NOT?: AudioAssetWhereInput | AudioAssetWhereInput[];
      lectureId?: StringFilter<"AudioAsset"> | string;
      url?: StringFilter<"AudioAsset"> | string;
      format?: StringNullableFilter<"AudioAsset"> | string | null;
      bitrateKbps?: IntNullableFilter<"AudioAsset"> | number | null;
      sizeBytes?: BigIntNullableFilter<"AudioAsset"> | bigint | number | null;
      durationSeconds?: IntNullableFilter<"AudioAsset"> | number | null;
      source?: StringNullableFilter<"AudioAsset"> | string | null;
      isPrimary?: BoolFilter<"AudioAsset"> | boolean;
      createdAt?: DateTimeFilter<"AudioAsset"> | Date | string;
      ingestionBatchId?: StringNullableFilter<"AudioAsset"> | string | null;
      ingestionBatch?: XOR<
        IngestionBatchNullableScalarRelationFilter,
        IngestionBatchWhereInput
      > | null;
      lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
    },
    "id"
  >;

  export type AudioAssetOrderByWithAggregationInput = {
    id?: SortOrder;
    lectureId?: SortOrder;
    url?: SortOrder;
    format?: SortOrderInput | SortOrder;
    bitrateKbps?: SortOrderInput | SortOrder;
    sizeBytes?: SortOrderInput | SortOrder;
    durationSeconds?: SortOrderInput | SortOrder;
    source?: SortOrderInput | SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    ingestionBatchId?: SortOrderInput | SortOrder;
    _count?: AudioAssetCountOrderByAggregateInput;
    _avg?: AudioAssetAvgOrderByAggregateInput;
    _max?: AudioAssetMaxOrderByAggregateInput;
    _min?: AudioAssetMinOrderByAggregateInput;
    _sum?: AudioAssetSumOrderByAggregateInput;
  };

  export type AudioAssetScalarWhereWithAggregatesInput = {
    AND?: AudioAssetScalarWhereWithAggregatesInput | AudioAssetScalarWhereWithAggregatesInput[];
    OR?: AudioAssetScalarWhereWithAggregatesInput[];
    NOT?: AudioAssetScalarWhereWithAggregatesInput | AudioAssetScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AudioAsset"> | string;
    lectureId?: StringWithAggregatesFilter<"AudioAsset"> | string;
    url?: StringWithAggregatesFilter<"AudioAsset"> | string;
    format?: StringNullableWithAggregatesFilter<"AudioAsset"> | string | null;
    bitrateKbps?: IntNullableWithAggregatesFilter<"AudioAsset"> | number | null;
    sizeBytes?: BigIntNullableWithAggregatesFilter<"AudioAsset"> | bigint | number | null;
    durationSeconds?: IntNullableWithAggregatesFilter<"AudioAsset"> | number | null;
    source?: StringNullableWithAggregatesFilter<"AudioAsset"> | string | null;
    isPrimary?: BoolWithAggregatesFilter<"AudioAsset"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"AudioAsset"> | Date | string;
    ingestionBatchId?: StringNullableWithAggregatesFilter<"AudioAsset"> | string | null;
  };

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[];
    OR?: TopicWhereInput[];
    NOT?: TopicWhereInput | TopicWhereInput[];
    id?: StringFilter<"Topic"> | string;
    slug?: StringFilter<"Topic"> | string;
    name?: StringFilter<"Topic"> | string;
    parentId?: StringNullableFilter<"Topic"> | string | null;
    createdAt?: DateTimeFilter<"Topic"> | Date | string;
    parent?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null;
    children?: TopicListRelationFilter;
    lectureTopics?: LectureTopicListRelationFilter;
    seriesTopics?: SeriesTopicListRelationFilter;
    collectionTopics?: CollectionTopicListRelationFilter;
  };

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    parent?: TopicOrderByWithRelationInput;
    children?: TopicOrderByRelationAggregateInput;
    lectureTopics?: LectureTopicOrderByRelationAggregateInput;
    seriesTopics?: SeriesTopicOrderByRelationAggregateInput;
    collectionTopics?: CollectionTopicOrderByRelationAggregateInput;
  };

  export type TopicWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: TopicWhereInput | TopicWhereInput[];
      OR?: TopicWhereInput[];
      NOT?: TopicWhereInput | TopicWhereInput[];
      name?: StringFilter<"Topic"> | string;
      parentId?: StringNullableFilter<"Topic"> | string | null;
      createdAt?: DateTimeFilter<"Topic"> | Date | string;
      parent?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null;
      children?: TopicListRelationFilter;
      lectureTopics?: LectureTopicListRelationFilter;
      seriesTopics?: SeriesTopicListRelationFilter;
      collectionTopics?: CollectionTopicListRelationFilter;
    },
    "id" | "slug"
  >;

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: TopicCountOrderByAggregateInput;
    _max?: TopicMaxOrderByAggregateInput;
    _min?: TopicMinOrderByAggregateInput;
  };

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[];
    OR?: TopicScalarWhereWithAggregatesInput[];
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Topic"> | string;
    slug?: StringWithAggregatesFilter<"Topic"> | string;
    name?: StringWithAggregatesFilter<"Topic"> | string;
    parentId?: StringNullableWithAggregatesFilter<"Topic"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string;
  };

  export type LectureTopicWhereInput = {
    AND?: LectureTopicWhereInput | LectureTopicWhereInput[];
    OR?: LectureTopicWhereInput[];
    NOT?: LectureTopicWhereInput | LectureTopicWhereInput[];
    lectureId?: StringFilter<"LectureTopic"> | string;
    topicId?: StringFilter<"LectureTopic"> | string;
    createdAt?: DateTimeFilter<"LectureTopic"> | Date | string;
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
  };

  export type LectureTopicOrderByWithRelationInput = {
    lectureId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
    lecture?: LectureOrderByWithRelationInput;
    topic?: TopicOrderByWithRelationInput;
  };

  export type LectureTopicWhereUniqueInput = Prisma.AtLeast<
    {
      lectureId_topicId?: LectureTopicLectureIdTopicIdCompoundUniqueInput;
      AND?: LectureTopicWhereInput | LectureTopicWhereInput[];
      OR?: LectureTopicWhereInput[];
      NOT?: LectureTopicWhereInput | LectureTopicWhereInput[];
      lectureId?: StringFilter<"LectureTopic"> | string;
      topicId?: StringFilter<"LectureTopic"> | string;
      createdAt?: DateTimeFilter<"LectureTopic"> | Date | string;
      lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
      topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
    },
    "lectureId_topicId"
  >;

  export type LectureTopicOrderByWithAggregationInput = {
    lectureId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
    _count?: LectureTopicCountOrderByAggregateInput;
    _max?: LectureTopicMaxOrderByAggregateInput;
    _min?: LectureTopicMinOrderByAggregateInput;
  };

  export type LectureTopicScalarWhereWithAggregatesInput = {
    AND?: LectureTopicScalarWhereWithAggregatesInput | LectureTopicScalarWhereWithAggregatesInput[];
    OR?: LectureTopicScalarWhereWithAggregatesInput[];
    NOT?: LectureTopicScalarWhereWithAggregatesInput | LectureTopicScalarWhereWithAggregatesInput[];
    lectureId?: StringWithAggregatesFilter<"LectureTopic"> | string;
    topicId?: StringWithAggregatesFilter<"LectureTopic"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"LectureTopic"> | Date | string;
  };

  export type SeriesTopicWhereInput = {
    AND?: SeriesTopicWhereInput | SeriesTopicWhereInput[];
    OR?: SeriesTopicWhereInput[];
    NOT?: SeriesTopicWhereInput | SeriesTopicWhereInput[];
    seriesId?: StringFilter<"SeriesTopic"> | string;
    topicId?: StringFilter<"SeriesTopic"> | string;
    createdAt?: DateTimeFilter<"SeriesTopic"> | Date | string;
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>;
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
  };

  export type SeriesTopicOrderByWithRelationInput = {
    seriesId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
    series?: SeriesOrderByWithRelationInput;
    topic?: TopicOrderByWithRelationInput;
  };

  export type SeriesTopicWhereUniqueInput = Prisma.AtLeast<
    {
      seriesId_topicId?: SeriesTopicSeriesIdTopicIdCompoundUniqueInput;
      AND?: SeriesTopicWhereInput | SeriesTopicWhereInput[];
      OR?: SeriesTopicWhereInput[];
      NOT?: SeriesTopicWhereInput | SeriesTopicWhereInput[];
      seriesId?: StringFilter<"SeriesTopic"> | string;
      topicId?: StringFilter<"SeriesTopic"> | string;
      createdAt?: DateTimeFilter<"SeriesTopic"> | Date | string;
      series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>;
      topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
    },
    "seriesId_topicId"
  >;

  export type SeriesTopicOrderByWithAggregationInput = {
    seriesId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
    _count?: SeriesTopicCountOrderByAggregateInput;
    _max?: SeriesTopicMaxOrderByAggregateInput;
    _min?: SeriesTopicMinOrderByAggregateInput;
  };

  export type SeriesTopicScalarWhereWithAggregatesInput = {
    AND?: SeriesTopicScalarWhereWithAggregatesInput | SeriesTopicScalarWhereWithAggregatesInput[];
    OR?: SeriesTopicScalarWhereWithAggregatesInput[];
    NOT?: SeriesTopicScalarWhereWithAggregatesInput | SeriesTopicScalarWhereWithAggregatesInput[];
    seriesId?: StringWithAggregatesFilter<"SeriesTopic"> | string;
    topicId?: StringWithAggregatesFilter<"SeriesTopic"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"SeriesTopic"> | Date | string;
  };

  export type CollectionTopicWhereInput = {
    AND?: CollectionTopicWhereInput | CollectionTopicWhereInput[];
    OR?: CollectionTopicWhereInput[];
    NOT?: CollectionTopicWhereInput | CollectionTopicWhereInput[];
    collectionId?: StringFilter<"CollectionTopic"> | string;
    topicId?: StringFilter<"CollectionTopic"> | string;
    createdAt?: DateTimeFilter<"CollectionTopic"> | Date | string;
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>;
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
  };

  export type CollectionTopicOrderByWithRelationInput = {
    collectionId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
    collection?: CollectionOrderByWithRelationInput;
    topic?: TopicOrderByWithRelationInput;
  };

  export type CollectionTopicWhereUniqueInput = Prisma.AtLeast<
    {
      collectionId_topicId?: CollectionTopicCollectionIdTopicIdCompoundUniqueInput;
      AND?: CollectionTopicWhereInput | CollectionTopicWhereInput[];
      OR?: CollectionTopicWhereInput[];
      NOT?: CollectionTopicWhereInput | CollectionTopicWhereInput[];
      collectionId?: StringFilter<"CollectionTopic"> | string;
      topicId?: StringFilter<"CollectionTopic"> | string;
      createdAt?: DateTimeFilter<"CollectionTopic"> | Date | string;
      collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>;
      topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
    },
    "collectionId_topicId"
  >;

  export type CollectionTopicOrderByWithAggregationInput = {
    collectionId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
    _count?: CollectionTopicCountOrderByAggregateInput;
    _max?: CollectionTopicMaxOrderByAggregateInput;
    _min?: CollectionTopicMinOrderByAggregateInput;
  };

  export type CollectionTopicScalarWhereWithAggregatesInput = {
    AND?:
      | CollectionTopicScalarWhereWithAggregatesInput
      | CollectionTopicScalarWhereWithAggregatesInput[];
    OR?: CollectionTopicScalarWhereWithAggregatesInput[];
    NOT?:
      | CollectionTopicScalarWhereWithAggregatesInput
      | CollectionTopicScalarWhereWithAggregatesInput[];
    collectionId?: StringWithAggregatesFilter<"CollectionTopic"> | string;
    topicId?: StringWithAggregatesFilter<"CollectionTopic"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"CollectionTopic"> | Date | string;
  };

  export type UserLectureProgressWhereInput = {
    AND?: UserLectureProgressWhereInput | UserLectureProgressWhereInput[];
    OR?: UserLectureProgressWhereInput[];
    NOT?: UserLectureProgressWhereInput | UserLectureProgressWhereInput[];
    userId?: StringFilter<"UserLectureProgress"> | string;
    lectureId?: StringFilter<"UserLectureProgress"> | string;
    positionSeconds?: IntFilter<"UserLectureProgress"> | number;
    isCompleted?: BoolFilter<"UserLectureProgress"> | boolean;
    updatedAt?: DateTimeFilter<"UserLectureProgress"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
  };

  export type UserLectureProgressOrderByWithRelationInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    positionSeconds?: SortOrder;
    isCompleted?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    lecture?: LectureOrderByWithRelationInput;
  };

  export type UserLectureProgressWhereUniqueInput = Prisma.AtLeast<
    {
      userId_lectureId?: UserLectureProgressUserIdLectureIdCompoundUniqueInput;
      AND?: UserLectureProgressWhereInput | UserLectureProgressWhereInput[];
      OR?: UserLectureProgressWhereInput[];
      NOT?: UserLectureProgressWhereInput | UserLectureProgressWhereInput[];
      userId?: StringFilter<"UserLectureProgress"> | string;
      lectureId?: StringFilter<"UserLectureProgress"> | string;
      positionSeconds?: IntFilter<"UserLectureProgress"> | number;
      isCompleted?: BoolFilter<"UserLectureProgress"> | boolean;
      updatedAt?: DateTimeFilter<"UserLectureProgress"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
    },
    "userId_lectureId"
  >;

  export type UserLectureProgressOrderByWithAggregationInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    positionSeconds?: SortOrder;
    isCompleted?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserLectureProgressCountOrderByAggregateInput;
    _avg?: UserLectureProgressAvgOrderByAggregateInput;
    _max?: UserLectureProgressMaxOrderByAggregateInput;
    _min?: UserLectureProgressMinOrderByAggregateInput;
    _sum?: UserLectureProgressSumOrderByAggregateInput;
  };

  export type UserLectureProgressScalarWhereWithAggregatesInput = {
    AND?:
      | UserLectureProgressScalarWhereWithAggregatesInput
      | UserLectureProgressScalarWhereWithAggregatesInput[];
    OR?: UserLectureProgressScalarWhereWithAggregatesInput[];
    NOT?:
      | UserLectureProgressScalarWhereWithAggregatesInput
      | UserLectureProgressScalarWhereWithAggregatesInput[];
    userId?: StringWithAggregatesFilter<"UserLectureProgress"> | string;
    lectureId?: StringWithAggregatesFilter<"UserLectureProgress"> | string;
    positionSeconds?: IntWithAggregatesFilter<"UserLectureProgress"> | number;
    isCompleted?: BoolWithAggregatesFilter<"UserLectureProgress"> | boolean;
    updatedAt?: DateTimeWithAggregatesFilter<"UserLectureProgress"> | Date | string;
  };

  export type FavoriteLectureWhereInput = {
    AND?: FavoriteLectureWhereInput | FavoriteLectureWhereInput[];
    OR?: FavoriteLectureWhereInput[];
    NOT?: FavoriteLectureWhereInput | FavoriteLectureWhereInput[];
    userId?: StringFilter<"FavoriteLecture"> | string;
    lectureId?: StringFilter<"FavoriteLecture"> | string;
    createdAt?: DateTimeFilter<"FavoriteLecture"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
  };

  export type FavoriteLectureOrderByWithRelationInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    lecture?: LectureOrderByWithRelationInput;
  };

  export type FavoriteLectureWhereUniqueInput = Prisma.AtLeast<
    {
      userId_lectureId?: FavoriteLectureUserIdLectureIdCompoundUniqueInput;
      AND?: FavoriteLectureWhereInput | FavoriteLectureWhereInput[];
      OR?: FavoriteLectureWhereInput[];
      NOT?: FavoriteLectureWhereInput | FavoriteLectureWhereInput[];
      userId?: StringFilter<"FavoriteLecture"> | string;
      lectureId?: StringFilter<"FavoriteLecture"> | string;
      createdAt?: DateTimeFilter<"FavoriteLecture"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>;
    },
    "userId_lectureId"
  >;

  export type FavoriteLectureOrderByWithAggregationInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    createdAt?: SortOrder;
    _count?: FavoriteLectureCountOrderByAggregateInput;
    _max?: FavoriteLectureMaxOrderByAggregateInput;
    _min?: FavoriteLectureMinOrderByAggregateInput;
  };

  export type FavoriteLectureScalarWhereWithAggregatesInput = {
    AND?:
      | FavoriteLectureScalarWhereWithAggregatesInput
      | FavoriteLectureScalarWhereWithAggregatesInput[];
    OR?: FavoriteLectureScalarWhereWithAggregatesInput[];
    NOT?:
      | FavoriteLectureScalarWhereWithAggregatesInput
      | FavoriteLectureScalarWhereWithAggregatesInput[];
    userId?: StringWithAggregatesFilter<"FavoriteLecture"> | string;
    lectureId?: StringWithAggregatesFilter<"FavoriteLecture"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"FavoriteLecture"> | Date | string;
  };

  export type IngestionBatchCreateInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUncheckedCreateInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarUncheckedCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionUncheckedCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesUncheckedCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchCreateManyInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
  };

  export type IngestionBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IngestionBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleUncheckedCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUncheckedUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserGlobalRoleCreateInput = {
    role: $Enums.GlobalRole;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutGlobalRolesInput;
  };

  export type UserGlobalRoleUncheckedCreateInput = {
    userId: string;
    role: $Enums.GlobalRole;
    createdAt?: Date | string;
  };

  export type UserGlobalRoleUpdateInput = {
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutGlobalRolesNestedInput;
  };

  export type UserGlobalRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserGlobalRoleCreateManyInput = {
    userId: string;
    role: $Enums.GlobalRole;
    createdAt?: Date | string;
  };

  export type UserGlobalRoleUpdateManyMutationInput = {
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserGlobalRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserScholarRoleCreateInput = {
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutScholarRolesInput;
    scholar: ScholarCreateNestedOneWithoutUserRolesInput;
    createdByUser?: UserCreateNestedOneWithoutCreatedScholarRolesInput;
  };

  export type UserScholarRoleUncheckedCreateInput = {
    userId: string;
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    createdByUserId?: string | null;
  };

  export type UserScholarRoleUpdateInput = {
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutScholarRolesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutUserRolesNestedInput;
    createdByUser?: UserUpdateOneWithoutCreatedScholarRolesNestedInput;
  };

  export type UserScholarRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserScholarRoleCreateManyInput = {
    userId: string;
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    createdByUserId?: string | null;
  };

  export type UserScholarRoleUpdateManyMutationInput = {
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserScholarRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ScholarCreateInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutScholarsInput;
    collections?: CollectionCreateNestedManyWithoutScholarInput;
    series?: SeriesCreateNestedManyWithoutScholarInput;
    lectures?: LectureCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUncheckedCreateInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatchId?: string | null;
    collections?: CollectionUncheckedCreateNestedManyWithoutScholarInput;
    series?: SeriesUncheckedCreateNestedManyWithoutScholarInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutScholarsNestedInput;
    collections?: CollectionUpdateManyWithoutScholarNestedInput;
    series?: SeriesUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    collections?: CollectionUncheckedUpdateManyWithoutScholarNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUncheckedUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarCreateManyInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type ScholarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ScholarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CollectionCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutCollectionsInput;
    scholar: ScholarCreateNestedOneWithoutCollectionsInput;
    series?: SeriesCreateNestedManyWithoutCollectionInput;
    topics?: CollectionTopicCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionUncheckedCreateInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput;
    topics?: CollectionTopicUncheckedCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutCollectionsNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutCollectionsNestedInput;
    series?: SeriesUpdateManyWithoutCollectionNestedInput;
    topics?: CollectionTopicUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput;
    topics?: CollectionTopicUncheckedUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionCreateManyInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type CollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type CollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SeriesCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutSeriesInput;
    scholar: ScholarCreateNestedOneWithoutSeriesInput;
    collection?: CollectionCreateNestedOneWithoutSeriesInput;
    lectures?: LectureCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUncheckedCreateInput = {
    id?: string;
    scholarId: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    lectures?: LectureUncheckedCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicUncheckedCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutSeriesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutSeriesNestedInput;
    collection?: CollectionUpdateOneWithoutSeriesNestedInput;
    lectures?: LectureUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    lectures?: LectureUncheckedUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUncheckedUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesCreateManyInput = {
    id?: string;
    scholarId: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type SeriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type SeriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LectureCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type LectureCreateManyInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type LectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type LectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AudioAssetCreateInput = {
    id?: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutAudioAssetsInput;
    lecture: LectureCreateNestedOneWithoutAudioAssetsInput;
  };

  export type AudioAssetUncheckedCreateInput = {
    id?: string;
    lectureId: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    ingestionBatchId?: string | null;
  };

  export type AudioAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ingestionBatch?: IngestionBatchUpdateOneWithoutAudioAssetsNestedInput;
    lecture?: LectureUpdateOneRequiredWithoutAudioAssetsNestedInput;
  };

  export type AudioAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AudioAssetCreateManyInput = {
    id?: string;
    lectureId: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    ingestionBatchId?: string | null;
  };

  export type AudioAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AudioAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TopicCreateInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    parent?: TopicCreateNestedOneWithoutChildrenInput;
    children?: TopicCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateInput = {
    id?: string;
    slug: string;
    name: string;
    parentId?: string | null;
    createdAt?: Date | string;
    children?: TopicUncheckedCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicUncheckedCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicUncheckedCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: TopicUpdateOneWithoutChildrenNestedInput;
    children?: TopicUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: TopicUncheckedUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUncheckedUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUncheckedUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type TopicCreateManyInput = {
    id?: string;
    slug: string;
    name: string;
    parentId?: string | null;
    createdAt?: Date | string;
  };

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureTopicCreateInput = {
    createdAt?: Date | string;
    lecture: LectureCreateNestedOneWithoutTopicsInput;
    topic: TopicCreateNestedOneWithoutLectureTopicsInput;
  };

  export type LectureTopicUncheckedCreateInput = {
    lectureId: string;
    topicId: string;
    createdAt?: Date | string;
  };

  export type LectureTopicUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lecture?: LectureUpdateOneRequiredWithoutTopicsNestedInput;
    topic?: TopicUpdateOneRequiredWithoutLectureTopicsNestedInput;
  };

  export type LectureTopicUncheckedUpdateInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureTopicCreateManyInput = {
    lectureId: string;
    topicId: string;
    createdAt?: Date | string;
  };

  export type LectureTopicUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureTopicUncheckedUpdateManyInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SeriesTopicCreateInput = {
    createdAt?: Date | string;
    series: SeriesCreateNestedOneWithoutTopicsInput;
    topic: TopicCreateNestedOneWithoutSeriesTopicsInput;
  };

  export type SeriesTopicUncheckedCreateInput = {
    seriesId: string;
    topicId: string;
    createdAt?: Date | string;
  };

  export type SeriesTopicUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    series?: SeriesUpdateOneRequiredWithoutTopicsNestedInput;
    topic?: TopicUpdateOneRequiredWithoutSeriesTopicsNestedInput;
  };

  export type SeriesTopicUncheckedUpdateInput = {
    seriesId?: StringFieldUpdateOperationsInput | string;
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SeriesTopicCreateManyInput = {
    seriesId: string;
    topicId: string;
    createdAt?: Date | string;
  };

  export type SeriesTopicUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SeriesTopicUncheckedUpdateManyInput = {
    seriesId?: StringFieldUpdateOperationsInput | string;
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionTopicCreateInput = {
    createdAt?: Date | string;
    collection: CollectionCreateNestedOneWithoutTopicsInput;
    topic: TopicCreateNestedOneWithoutCollectionTopicsInput;
  };

  export type CollectionTopicUncheckedCreateInput = {
    collectionId: string;
    topicId: string;
    createdAt?: Date | string;
  };

  export type CollectionTopicUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    collection?: CollectionUpdateOneRequiredWithoutTopicsNestedInput;
    topic?: TopicUpdateOneRequiredWithoutCollectionTopicsNestedInput;
  };

  export type CollectionTopicUncheckedUpdateInput = {
    collectionId?: StringFieldUpdateOperationsInput | string;
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionTopicCreateManyInput = {
    collectionId: string;
    topicId: string;
    createdAt?: Date | string;
  };

  export type CollectionTopicUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionTopicUncheckedUpdateManyInput = {
    collectionId?: StringFieldUpdateOperationsInput | string;
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressCreateInput = {
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutProgressInput;
    lecture: LectureCreateNestedOneWithoutProgressInput;
  };

  export type UserLectureProgressUncheckedCreateInput = {
    userId: string;
    lectureId: string;
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
  };

  export type UserLectureProgressUpdateInput = {
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutProgressNestedInput;
    lecture?: LectureUpdateOneRequiredWithoutProgressNestedInput;
  };

  export type UserLectureProgressUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressCreateManyInput = {
    userId: string;
    lectureId: string;
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
  };

  export type UserLectureProgressUpdateManyMutationInput = {
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureCreateInput = {
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutFavoritesInput;
    lecture: LectureCreateNestedOneWithoutFavoritesInput;
  };

  export type FavoriteLectureUncheckedCreateInput = {
    userId: string;
    lectureId: string;
    createdAt?: Date | string;
  };

  export type FavoriteLectureUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput;
    lecture?: LectureUpdateOneRequiredWithoutFavoritesNestedInput;
  };

  export type FavoriteLectureUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureCreateManyInput = {
    userId: string;
    lectureId: string;
    createdAt?: Date | string;
  };

  export type FavoriteLectureUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type ScholarListRelationFilter = {
    every?: ScholarWhereInput;
    some?: ScholarWhereInput;
    none?: ScholarWhereInput;
  };

  export type CollectionListRelationFilter = {
    every?: CollectionWhereInput;
    some?: CollectionWhereInput;
    none?: CollectionWhereInput;
  };

  export type SeriesListRelationFilter = {
    every?: SeriesWhereInput;
    some?: SeriesWhereInput;
    none?: SeriesWhereInput;
  };

  export type LectureListRelationFilter = {
    every?: LectureWhereInput;
    some?: LectureWhereInput;
    none?: LectureWhereInput;
  };

  export type AudioAssetListRelationFilter = {
    every?: AudioAssetWhereInput;
    some?: AudioAssetWhereInput;
    none?: AudioAssetWhereInput;
  };

  export type ScholarOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CollectionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SeriesOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LectureOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AudioAssetOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type IngestionBatchTagEnvironmentCompoundUniqueInput = {
    tag: string;
    environment: string;
  };

  export type IngestionBatchCountOrderByAggregateInput = {
    id?: SortOrder;
    tag?: SortOrder;
    environment?: SortOrder;
    createdAt?: SortOrder;
  };

  export type IngestionBatchMaxOrderByAggregateInput = {
    id?: SortOrder;
    tag?: SortOrder;
    environment?: SortOrder;
    createdAt?: SortOrder;
  };

  export type IngestionBatchMinOrderByAggregateInput = {
    id?: SortOrder;
    tag?: SortOrder;
    environment?: SortOrder;
    createdAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type UserGlobalRoleListRelationFilter = {
    every?: UserGlobalRoleWhereInput;
    some?: UserGlobalRoleWhereInput;
    none?: UserGlobalRoleWhereInput;
  };

  export type UserScholarRoleListRelationFilter = {
    every?: UserScholarRoleWhereInput;
    some?: UserScholarRoleWhereInput;
    none?: UserScholarRoleWhereInput;
  };

  export type UserLectureProgressListRelationFilter = {
    every?: UserLectureProgressWhereInput;
    some?: UserLectureProgressWhereInput;
    none?: UserLectureProgressWhereInput;
  };

  export type FavoriteLectureListRelationFilter = {
    every?: FavoriteLectureWhereInput;
    some?: FavoriteLectureWhereInput;
    none?: FavoriteLectureWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UserGlobalRoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserScholarRoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserLectureProgressOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FavoriteLectureOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailNormalized?: SortOrder;
    emailVerifiedAt?: SortOrder;
    name?: SortOrder;
    preferredLanguage?: SortOrder;
    passwordHash?: SortOrder;
    passwordUpdatedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deactivatedAt?: SortOrder;
    erasureRequestedAt?: SortOrder;
    erasedAt?: SortOrder;
    isBanned?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailNormalized?: SortOrder;
    emailVerifiedAt?: SortOrder;
    name?: SortOrder;
    preferredLanguage?: SortOrder;
    passwordHash?: SortOrder;
    passwordUpdatedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deactivatedAt?: SortOrder;
    erasureRequestedAt?: SortOrder;
    erasedAt?: SortOrder;
    isBanned?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailNormalized?: SortOrder;
    emailVerifiedAt?: SortOrder;
    name?: SortOrder;
    preferredLanguage?: SortOrder;
    passwordHash?: SortOrder;
    passwordUpdatedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deactivatedAt?: SortOrder;
    erasureRequestedAt?: SortOrder;
    erasedAt?: SortOrder;
    isBanned?: SortOrder;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type EnumGlobalRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GlobalRole | EnumGlobalRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumGlobalRoleFilter<$PrismaModel> | $Enums.GlobalRole;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type UserGlobalRoleUserIdRoleCompoundUniqueInput = {
    userId: string;
    role: $Enums.GlobalRole;
  };

  export type UserGlobalRoleCountOrderByAggregateInput = {
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserGlobalRoleMaxOrderByAggregateInput = {
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserGlobalRoleMinOrderByAggregateInput = {
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumGlobalRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GlobalRole | EnumGlobalRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumGlobalRoleWithAggregatesFilter<$PrismaModel> | $Enums.GlobalRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGlobalRoleFilter<$PrismaModel>;
    _max?: NestedEnumGlobalRoleFilter<$PrismaModel>;
  };

  export type EnumScholarRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ScholarRole | EnumScholarRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumScholarRoleFilter<$PrismaModel> | $Enums.ScholarRole;
  };

  export type ScholarScalarRelationFilter = {
    is?: ScholarWhereInput;
    isNot?: ScholarWhereInput;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type UserScholarRoleUserIdScholarIdRoleCompoundUniqueInput = {
    userId: string;
    scholarId: string;
    role: $Enums.ScholarRole;
  };

  export type UserScholarRoleCountOrderByAggregateInput = {
    userId?: SortOrder;
    scholarId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    createdByUserId?: SortOrder;
  };

  export type UserScholarRoleMaxOrderByAggregateInput = {
    userId?: SortOrder;
    scholarId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    createdByUserId?: SortOrder;
  };

  export type UserScholarRoleMinOrderByAggregateInput = {
    userId?: SortOrder;
    scholarId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    createdByUserId?: SortOrder;
  };

  export type EnumScholarRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScholarRole | EnumScholarRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumScholarRoleWithAggregatesFilter<$PrismaModel> | $Enums.ScholarRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumScholarRoleFilter<$PrismaModel>;
    _max?: NestedEnumScholarRoleFilter<$PrismaModel>;
  };

  export type IngestionBatchNullableScalarRelationFilter = {
    is?: IngestionBatchWhereInput | null;
    isNot?: IngestionBatchWhereInput | null;
  };

  export type ScholarCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    bio?: SortOrder;
    country?: SortOrder;
    mainLanguage?: SortOrder;
    imageUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type ScholarMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    bio?: SortOrder;
    country?: SortOrder;
    mainLanguage?: SortOrder;
    imageUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type ScholarMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    bio?: SortOrder;
    country?: SortOrder;
    mainLanguage?: SortOrder;
    imageUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type CollectionTopicListRelationFilter = {
    every?: CollectionTopicWhereInput;
    some?: CollectionTopicWhereInput;
    none?: CollectionTopicWhereInput;
  };

  export type CollectionTopicOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CollectionScholarIdSlugCompoundUniqueInput = {
    scholarId: string;
    slug: string;
  };

  export type CollectionCountOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImageUrl?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type CollectionAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type CollectionMaxOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImageUrl?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type CollectionMinOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImageUrl?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type CollectionSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStatusFilter<$PrismaModel>;
    _max?: NestedEnumStatusFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type CollectionNullableScalarRelationFilter = {
    is?: CollectionWhereInput | null;
    isNot?: CollectionWhereInput | null;
  };

  export type SeriesTopicListRelationFilter = {
    every?: SeriesTopicWhereInput;
    some?: SeriesTopicWhereInput;
    none?: SeriesTopicWhereInput;
  };

  export type SeriesTopicOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SeriesScholarIdSlugCompoundUniqueInput = {
    scholarId: string;
    slug: string;
  };

  export type SeriesCountOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    collectionId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImageUrl?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type SeriesAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type SeriesMaxOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    collectionId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImageUrl?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type SeriesMinOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    collectionId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImageUrl?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    orderIndex?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type SeriesSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type SeriesNullableScalarRelationFilter = {
    is?: SeriesWhereInput | null;
    isNot?: SeriesWhereInput | null;
  };

  export type LectureTopicListRelationFilter = {
    every?: LectureTopicWhereInput;
    some?: LectureTopicWhereInput;
    none?: LectureTopicWhereInput;
  };

  export type LectureTopicOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LectureScholarIdSlugCompoundUniqueInput = {
    scholarId: string;
    slug: string;
  };

  export type LectureCountOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    seriesId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    publishedAt?: SortOrder;
    orderIndex?: SortOrder;
    durationSeconds?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type LectureAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
    durationSeconds?: SortOrder;
  };

  export type LectureMaxOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    seriesId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    publishedAt?: SortOrder;
    orderIndex?: SortOrder;
    durationSeconds?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type LectureMinOrderByAggregateInput = {
    id?: SortOrder;
    scholarId?: SortOrder;
    seriesId?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    language?: SortOrder;
    status?: SortOrder;
    publishedAt?: SortOrder;
    orderIndex?: SortOrder;
    durationSeconds?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
    deleteAfterAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type LectureSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
    durationSeconds?: SortOrder;
  };

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null;
  };

  export type LectureScalarRelationFilter = {
    is?: LectureWhereInput;
    isNot?: LectureWhereInput;
  };

  export type AudioAssetCountOrderByAggregateInput = {
    id?: SortOrder;
    lectureId?: SortOrder;
    url?: SortOrder;
    format?: SortOrder;
    bitrateKbps?: SortOrder;
    sizeBytes?: SortOrder;
    durationSeconds?: SortOrder;
    source?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type AudioAssetAvgOrderByAggregateInput = {
    bitrateKbps?: SortOrder;
    sizeBytes?: SortOrder;
    durationSeconds?: SortOrder;
  };

  export type AudioAssetMaxOrderByAggregateInput = {
    id?: SortOrder;
    lectureId?: SortOrder;
    url?: SortOrder;
    format?: SortOrder;
    bitrateKbps?: SortOrder;
    sizeBytes?: SortOrder;
    durationSeconds?: SortOrder;
    source?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type AudioAssetMinOrderByAggregateInput = {
    id?: SortOrder;
    lectureId?: SortOrder;
    url?: SortOrder;
    format?: SortOrder;
    bitrateKbps?: SortOrder;
    sizeBytes?: SortOrder;
    durationSeconds?: SortOrder;
    source?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    ingestionBatchId?: SortOrder;
  };

  export type AudioAssetSumOrderByAggregateInput = {
    bitrateKbps?: SortOrder;
    sizeBytes?: SortOrder;
    durationSeconds?: SortOrder;
  };

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedBigIntNullableFilter<$PrismaModel>;
    _min?: NestedBigIntNullableFilter<$PrismaModel>;
    _max?: NestedBigIntNullableFilter<$PrismaModel>;
  };

  export type TopicNullableScalarRelationFilter = {
    is?: TopicWhereInput | null;
    isNot?: TopicWhereInput | null;
  };

  export type TopicListRelationFilter = {
    every?: TopicWhereInput;
    some?: TopicWhereInput;
    none?: TopicWhereInput;
  };

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TopicScalarRelationFilter = {
    is?: TopicWhereInput;
    isNot?: TopicWhereInput;
  };

  export type LectureTopicLectureIdTopicIdCompoundUniqueInput = {
    lectureId: string;
    topicId: string;
  };

  export type LectureTopicCountOrderByAggregateInput = {
    lectureId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type LectureTopicMaxOrderByAggregateInput = {
    lectureId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type LectureTopicMinOrderByAggregateInput = {
    lectureId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SeriesScalarRelationFilter = {
    is?: SeriesWhereInput;
    isNot?: SeriesWhereInput;
  };

  export type SeriesTopicSeriesIdTopicIdCompoundUniqueInput = {
    seriesId: string;
    topicId: string;
  };

  export type SeriesTopicCountOrderByAggregateInput = {
    seriesId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SeriesTopicMaxOrderByAggregateInput = {
    seriesId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type SeriesTopicMinOrderByAggregateInput = {
    seriesId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CollectionScalarRelationFilter = {
    is?: CollectionWhereInput;
    isNot?: CollectionWhereInput;
  };

  export type CollectionTopicCollectionIdTopicIdCompoundUniqueInput = {
    collectionId: string;
    topicId: string;
  };

  export type CollectionTopicCountOrderByAggregateInput = {
    collectionId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CollectionTopicMaxOrderByAggregateInput = {
    collectionId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CollectionTopicMinOrderByAggregateInput = {
    collectionId?: SortOrder;
    topicId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type UserLectureProgressUserIdLectureIdCompoundUniqueInput = {
    userId: string;
    lectureId: string;
  };

  export type UserLectureProgressCountOrderByAggregateInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    positionSeconds?: SortOrder;
    isCompleted?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserLectureProgressAvgOrderByAggregateInput = {
    positionSeconds?: SortOrder;
  };

  export type UserLectureProgressMaxOrderByAggregateInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    positionSeconds?: SortOrder;
    isCompleted?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserLectureProgressMinOrderByAggregateInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    positionSeconds?: SortOrder;
    isCompleted?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserLectureProgressSumOrderByAggregateInput = {
    positionSeconds?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type FavoriteLectureUserIdLectureIdCompoundUniqueInput = {
    userId: string;
    lectureId: string;
  };

  export type FavoriteLectureCountOrderByAggregateInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FavoriteLectureMaxOrderByAggregateInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FavoriteLectureMinOrderByAggregateInput = {
    userId?: SortOrder;
    lectureId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ScholarCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          ScholarCreateWithoutIngestionBatchInput,
          ScholarUncheckedCreateWithoutIngestionBatchInput
        >
      | ScholarCreateWithoutIngestionBatchInput[]
      | ScholarUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | ScholarCreateOrConnectWithoutIngestionBatchInput
      | ScholarCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: ScholarCreateManyIngestionBatchInputEnvelope;
    connect?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
  };

  export type CollectionCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          CollectionCreateWithoutIngestionBatchInput,
          CollectionUncheckedCreateWithoutIngestionBatchInput
        >
      | CollectionCreateWithoutIngestionBatchInput[]
      | CollectionUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutIngestionBatchInput
      | CollectionCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: CollectionCreateManyIngestionBatchInputEnvelope;
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
  };

  export type SeriesCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<SeriesCreateWithoutIngestionBatchInput, SeriesUncheckedCreateWithoutIngestionBatchInput>
      | SeriesCreateWithoutIngestionBatchInput[]
      | SeriesUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutIngestionBatchInput
      | SeriesCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: SeriesCreateManyIngestionBatchInputEnvelope;
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
  };

  export type LectureCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          LectureCreateWithoutIngestionBatchInput,
          LectureUncheckedCreateWithoutIngestionBatchInput
        >
      | LectureCreateWithoutIngestionBatchInput[]
      | LectureUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutIngestionBatchInput
      | LectureCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: LectureCreateManyIngestionBatchInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type AudioAssetCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          AudioAssetCreateWithoutIngestionBatchInput,
          AudioAssetUncheckedCreateWithoutIngestionBatchInput
        >
      | AudioAssetCreateWithoutIngestionBatchInput[]
      | AudioAssetUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: AudioAssetCreateManyIngestionBatchInputEnvelope;
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
  };

  export type ScholarUncheckedCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          ScholarCreateWithoutIngestionBatchInput,
          ScholarUncheckedCreateWithoutIngestionBatchInput
        >
      | ScholarCreateWithoutIngestionBatchInput[]
      | ScholarUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | ScholarCreateOrConnectWithoutIngestionBatchInput
      | ScholarCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: ScholarCreateManyIngestionBatchInputEnvelope;
    connect?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
  };

  export type CollectionUncheckedCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          CollectionCreateWithoutIngestionBatchInput,
          CollectionUncheckedCreateWithoutIngestionBatchInput
        >
      | CollectionCreateWithoutIngestionBatchInput[]
      | CollectionUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutIngestionBatchInput
      | CollectionCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: CollectionCreateManyIngestionBatchInputEnvelope;
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
  };

  export type SeriesUncheckedCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<SeriesCreateWithoutIngestionBatchInput, SeriesUncheckedCreateWithoutIngestionBatchInput>
      | SeriesCreateWithoutIngestionBatchInput[]
      | SeriesUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutIngestionBatchInput
      | SeriesCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: SeriesCreateManyIngestionBatchInputEnvelope;
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
  };

  export type LectureUncheckedCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          LectureCreateWithoutIngestionBatchInput,
          LectureUncheckedCreateWithoutIngestionBatchInput
        >
      | LectureCreateWithoutIngestionBatchInput[]
      | LectureUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutIngestionBatchInput
      | LectureCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: LectureCreateManyIngestionBatchInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type AudioAssetUncheckedCreateNestedManyWithoutIngestionBatchInput = {
    create?:
      | XOR<
          AudioAssetCreateWithoutIngestionBatchInput,
          AudioAssetUncheckedCreateWithoutIngestionBatchInput
        >
      | AudioAssetCreateWithoutIngestionBatchInput[]
      | AudioAssetUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput[];
    createMany?: AudioAssetCreateManyIngestionBatchInputEnvelope;
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type ScholarUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          ScholarCreateWithoutIngestionBatchInput,
          ScholarUncheckedCreateWithoutIngestionBatchInput
        >
      | ScholarCreateWithoutIngestionBatchInput[]
      | ScholarUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | ScholarCreateOrConnectWithoutIngestionBatchInput
      | ScholarCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | ScholarUpsertWithWhereUniqueWithoutIngestionBatchInput
      | ScholarUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: ScholarCreateManyIngestionBatchInputEnvelope;
    set?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    disconnect?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    delete?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    connect?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    update?:
      | ScholarUpdateWithWhereUniqueWithoutIngestionBatchInput
      | ScholarUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | ScholarUpdateManyWithWhereWithoutIngestionBatchInput
      | ScholarUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: ScholarScalarWhereInput | ScholarScalarWhereInput[];
  };

  export type CollectionUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          CollectionCreateWithoutIngestionBatchInput,
          CollectionUncheckedCreateWithoutIngestionBatchInput
        >
      | CollectionCreateWithoutIngestionBatchInput[]
      | CollectionUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutIngestionBatchInput
      | CollectionCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | CollectionUpsertWithWhereUniqueWithoutIngestionBatchInput
      | CollectionUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: CollectionCreateManyIngestionBatchInputEnvelope;
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    update?:
      | CollectionUpdateWithWhereUniqueWithoutIngestionBatchInput
      | CollectionUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | CollectionUpdateManyWithWhereWithoutIngestionBatchInput
      | CollectionUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[];
  };

  export type SeriesUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<SeriesCreateWithoutIngestionBatchInput, SeriesUncheckedCreateWithoutIngestionBatchInput>
      | SeriesCreateWithoutIngestionBatchInput[]
      | SeriesUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutIngestionBatchInput
      | SeriesCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | SeriesUpsertWithWhereUniqueWithoutIngestionBatchInput
      | SeriesUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: SeriesCreateManyIngestionBatchInputEnvelope;
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    update?:
      | SeriesUpdateWithWhereUniqueWithoutIngestionBatchInput
      | SeriesUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | SeriesUpdateManyWithWhereWithoutIngestionBatchInput
      | SeriesUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
  };

  export type LectureUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          LectureCreateWithoutIngestionBatchInput,
          LectureUncheckedCreateWithoutIngestionBatchInput
        >
      | LectureCreateWithoutIngestionBatchInput[]
      | LectureUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutIngestionBatchInput
      | LectureCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutIngestionBatchInput
      | LectureUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: LectureCreateManyIngestionBatchInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutIngestionBatchInput
      | LectureUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutIngestionBatchInput
      | LectureUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type AudioAssetUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          AudioAssetCreateWithoutIngestionBatchInput,
          AudioAssetUncheckedCreateWithoutIngestionBatchInput
        >
      | AudioAssetCreateWithoutIngestionBatchInput[]
      | AudioAssetUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | AudioAssetUpsertWithWhereUniqueWithoutIngestionBatchInput
      | AudioAssetUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: AudioAssetCreateManyIngestionBatchInputEnvelope;
    set?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    disconnect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    delete?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    update?:
      | AudioAssetUpdateWithWhereUniqueWithoutIngestionBatchInput
      | AudioAssetUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | AudioAssetUpdateManyWithWhereWithoutIngestionBatchInput
      | AudioAssetUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: AudioAssetScalarWhereInput | AudioAssetScalarWhereInput[];
  };

  export type ScholarUncheckedUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          ScholarCreateWithoutIngestionBatchInput,
          ScholarUncheckedCreateWithoutIngestionBatchInput
        >
      | ScholarCreateWithoutIngestionBatchInput[]
      | ScholarUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | ScholarCreateOrConnectWithoutIngestionBatchInput
      | ScholarCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | ScholarUpsertWithWhereUniqueWithoutIngestionBatchInput
      | ScholarUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: ScholarCreateManyIngestionBatchInputEnvelope;
    set?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    disconnect?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    delete?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    connect?: ScholarWhereUniqueInput | ScholarWhereUniqueInput[];
    update?:
      | ScholarUpdateWithWhereUniqueWithoutIngestionBatchInput
      | ScholarUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | ScholarUpdateManyWithWhereWithoutIngestionBatchInput
      | ScholarUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: ScholarScalarWhereInput | ScholarScalarWhereInput[];
  };

  export type CollectionUncheckedUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          CollectionCreateWithoutIngestionBatchInput,
          CollectionUncheckedCreateWithoutIngestionBatchInput
        >
      | CollectionCreateWithoutIngestionBatchInput[]
      | CollectionUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutIngestionBatchInput
      | CollectionCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | CollectionUpsertWithWhereUniqueWithoutIngestionBatchInput
      | CollectionUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: CollectionCreateManyIngestionBatchInputEnvelope;
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    update?:
      | CollectionUpdateWithWhereUniqueWithoutIngestionBatchInput
      | CollectionUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | CollectionUpdateManyWithWhereWithoutIngestionBatchInput
      | CollectionUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[];
  };

  export type SeriesUncheckedUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<SeriesCreateWithoutIngestionBatchInput, SeriesUncheckedCreateWithoutIngestionBatchInput>
      | SeriesCreateWithoutIngestionBatchInput[]
      | SeriesUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutIngestionBatchInput
      | SeriesCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | SeriesUpsertWithWhereUniqueWithoutIngestionBatchInput
      | SeriesUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: SeriesCreateManyIngestionBatchInputEnvelope;
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    update?:
      | SeriesUpdateWithWhereUniqueWithoutIngestionBatchInput
      | SeriesUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | SeriesUpdateManyWithWhereWithoutIngestionBatchInput
      | SeriesUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
  };

  export type LectureUncheckedUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          LectureCreateWithoutIngestionBatchInput,
          LectureUncheckedCreateWithoutIngestionBatchInput
        >
      | LectureCreateWithoutIngestionBatchInput[]
      | LectureUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutIngestionBatchInput
      | LectureCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutIngestionBatchInput
      | LectureUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: LectureCreateManyIngestionBatchInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutIngestionBatchInput
      | LectureUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutIngestionBatchInput
      | LectureUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type AudioAssetUncheckedUpdateManyWithoutIngestionBatchNestedInput = {
    create?:
      | XOR<
          AudioAssetCreateWithoutIngestionBatchInput,
          AudioAssetUncheckedCreateWithoutIngestionBatchInput
        >
      | AudioAssetCreateWithoutIngestionBatchInput[]
      | AudioAssetUncheckedCreateWithoutIngestionBatchInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput
      | AudioAssetCreateOrConnectWithoutIngestionBatchInput[];
    upsert?:
      | AudioAssetUpsertWithWhereUniqueWithoutIngestionBatchInput
      | AudioAssetUpsertWithWhereUniqueWithoutIngestionBatchInput[];
    createMany?: AudioAssetCreateManyIngestionBatchInputEnvelope;
    set?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    disconnect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    delete?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    update?:
      | AudioAssetUpdateWithWhereUniqueWithoutIngestionBatchInput
      | AudioAssetUpdateWithWhereUniqueWithoutIngestionBatchInput[];
    updateMany?:
      | AudioAssetUpdateManyWithWhereWithoutIngestionBatchInput
      | AudioAssetUpdateManyWithWhereWithoutIngestionBatchInput[];
    deleteMany?: AudioAssetScalarWhereInput | AudioAssetScalarWhereInput[];
  };

  export type UserGlobalRoleCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserGlobalRoleCreateWithoutUserInput, UserGlobalRoleUncheckedCreateWithoutUserInput>
      | UserGlobalRoleCreateWithoutUserInput[]
      | UserGlobalRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserGlobalRoleCreateOrConnectWithoutUserInput
      | UserGlobalRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserGlobalRoleCreateManyUserInputEnvelope;
    connect?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
  };

  export type UserScholarRoleCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserScholarRoleCreateWithoutUserInput, UserScholarRoleUncheckedCreateWithoutUserInput>
      | UserScholarRoleCreateWithoutUserInput[]
      | UserScholarRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutUserInput
      | UserScholarRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserScholarRoleCreateManyUserInputEnvelope;
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
  };

  export type UserScholarRoleCreateNestedManyWithoutCreatedByUserInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutCreatedByUserInput,
          UserScholarRoleUncheckedCreateWithoutCreatedByUserInput
        >
      | UserScholarRoleCreateWithoutCreatedByUserInput[]
      | UserScholarRoleUncheckedCreateWithoutCreatedByUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput[];
    createMany?: UserScholarRoleCreateManyCreatedByUserInputEnvelope;
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
  };

  export type UserLectureProgressCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutUserInput,
          UserLectureProgressUncheckedCreateWithoutUserInput
        >
      | UserLectureProgressCreateWithoutUserInput[]
      | UserLectureProgressUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutUserInput
      | UserLectureProgressCreateOrConnectWithoutUserInput[];
    createMany?: UserLectureProgressCreateManyUserInputEnvelope;
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
  };

  export type FavoriteLectureCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<FavoriteLectureCreateWithoutUserInput, FavoriteLectureUncheckedCreateWithoutUserInput>
      | FavoriteLectureCreateWithoutUserInput[]
      | FavoriteLectureUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutUserInput
      | FavoriteLectureCreateOrConnectWithoutUserInput[];
    createMany?: FavoriteLectureCreateManyUserInputEnvelope;
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
  };

  export type UserGlobalRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserGlobalRoleCreateWithoutUserInput, UserGlobalRoleUncheckedCreateWithoutUserInput>
      | UserGlobalRoleCreateWithoutUserInput[]
      | UserGlobalRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserGlobalRoleCreateOrConnectWithoutUserInput
      | UserGlobalRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserGlobalRoleCreateManyUserInputEnvelope;
    connect?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
  };

  export type UserScholarRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserScholarRoleCreateWithoutUserInput, UserScholarRoleUncheckedCreateWithoutUserInput>
      | UserScholarRoleCreateWithoutUserInput[]
      | UserScholarRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutUserInput
      | UserScholarRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserScholarRoleCreateManyUserInputEnvelope;
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
  };

  export type UserScholarRoleUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutCreatedByUserInput,
          UserScholarRoleUncheckedCreateWithoutCreatedByUserInput
        >
      | UserScholarRoleCreateWithoutCreatedByUserInput[]
      | UserScholarRoleUncheckedCreateWithoutCreatedByUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput[];
    createMany?: UserScholarRoleCreateManyCreatedByUserInputEnvelope;
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
  };

  export type UserLectureProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutUserInput,
          UserLectureProgressUncheckedCreateWithoutUserInput
        >
      | UserLectureProgressCreateWithoutUserInput[]
      | UserLectureProgressUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutUserInput
      | UserLectureProgressCreateOrConnectWithoutUserInput[];
    createMany?: UserLectureProgressCreateManyUserInputEnvelope;
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
  };

  export type FavoriteLectureUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<FavoriteLectureCreateWithoutUserInput, FavoriteLectureUncheckedCreateWithoutUserInput>
      | FavoriteLectureCreateWithoutUserInput[]
      | FavoriteLectureUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutUserInput
      | FavoriteLectureCreateOrConnectWithoutUserInput[];
    createMany?: FavoriteLectureCreateManyUserInputEnvelope;
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type UserGlobalRoleUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserGlobalRoleCreateWithoutUserInput, UserGlobalRoleUncheckedCreateWithoutUserInput>
      | UserGlobalRoleCreateWithoutUserInput[]
      | UserGlobalRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserGlobalRoleCreateOrConnectWithoutUserInput
      | UserGlobalRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserGlobalRoleUpsertWithWhereUniqueWithoutUserInput
      | UserGlobalRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserGlobalRoleCreateManyUserInputEnvelope;
    set?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    disconnect?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    delete?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    connect?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    update?:
      | UserGlobalRoleUpdateWithWhereUniqueWithoutUserInput
      | UserGlobalRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserGlobalRoleUpdateManyWithWhereWithoutUserInput
      | UserGlobalRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserGlobalRoleScalarWhereInput | UserGlobalRoleScalarWhereInput[];
  };

  export type UserScholarRoleUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserScholarRoleCreateWithoutUserInput, UserScholarRoleUncheckedCreateWithoutUserInput>
      | UserScholarRoleCreateWithoutUserInput[]
      | UserScholarRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutUserInput
      | UserScholarRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserScholarRoleUpsertWithWhereUniqueWithoutUserInput
      | UserScholarRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserScholarRoleCreateManyUserInputEnvelope;
    set?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    disconnect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    delete?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    update?:
      | UserScholarRoleUpdateWithWhereUniqueWithoutUserInput
      | UserScholarRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserScholarRoleUpdateManyWithWhereWithoutUserInput
      | UserScholarRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
  };

  export type UserScholarRoleUpdateManyWithoutCreatedByUserNestedInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutCreatedByUserInput,
          UserScholarRoleUncheckedCreateWithoutCreatedByUserInput
        >
      | UserScholarRoleCreateWithoutCreatedByUserInput[]
      | UserScholarRoleUncheckedCreateWithoutCreatedByUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput[];
    upsert?:
      | UserScholarRoleUpsertWithWhereUniqueWithoutCreatedByUserInput
      | UserScholarRoleUpsertWithWhereUniqueWithoutCreatedByUserInput[];
    createMany?: UserScholarRoleCreateManyCreatedByUserInputEnvelope;
    set?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    disconnect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    delete?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    update?:
      | UserScholarRoleUpdateWithWhereUniqueWithoutCreatedByUserInput
      | UserScholarRoleUpdateWithWhereUniqueWithoutCreatedByUserInput[];
    updateMany?:
      | UserScholarRoleUpdateManyWithWhereWithoutCreatedByUserInput
      | UserScholarRoleUpdateManyWithWhereWithoutCreatedByUserInput[];
    deleteMany?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
  };

  export type UserLectureProgressUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutUserInput,
          UserLectureProgressUncheckedCreateWithoutUserInput
        >
      | UserLectureProgressCreateWithoutUserInput[]
      | UserLectureProgressUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutUserInput
      | UserLectureProgressCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserLectureProgressUpsertWithWhereUniqueWithoutUserInput
      | UserLectureProgressUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserLectureProgressCreateManyUserInputEnvelope;
    set?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    disconnect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    delete?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    update?:
      | UserLectureProgressUpdateWithWhereUniqueWithoutUserInput
      | UserLectureProgressUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserLectureProgressUpdateManyWithWhereWithoutUserInput
      | UserLectureProgressUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserLectureProgressScalarWhereInput | UserLectureProgressScalarWhereInput[];
  };

  export type FavoriteLectureUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<FavoriteLectureCreateWithoutUserInput, FavoriteLectureUncheckedCreateWithoutUserInput>
      | FavoriteLectureCreateWithoutUserInput[]
      | FavoriteLectureUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutUserInput
      | FavoriteLectureCreateOrConnectWithoutUserInput[];
    upsert?:
      | FavoriteLectureUpsertWithWhereUniqueWithoutUserInput
      | FavoriteLectureUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: FavoriteLectureCreateManyUserInputEnvelope;
    set?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    disconnect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    delete?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    update?:
      | FavoriteLectureUpdateWithWhereUniqueWithoutUserInput
      | FavoriteLectureUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | FavoriteLectureUpdateManyWithWhereWithoutUserInput
      | FavoriteLectureUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: FavoriteLectureScalarWhereInput | FavoriteLectureScalarWhereInput[];
  };

  export type UserGlobalRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserGlobalRoleCreateWithoutUserInput, UserGlobalRoleUncheckedCreateWithoutUserInput>
      | UserGlobalRoleCreateWithoutUserInput[]
      | UserGlobalRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserGlobalRoleCreateOrConnectWithoutUserInput
      | UserGlobalRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserGlobalRoleUpsertWithWhereUniqueWithoutUserInput
      | UserGlobalRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserGlobalRoleCreateManyUserInputEnvelope;
    set?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    disconnect?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    delete?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    connect?: UserGlobalRoleWhereUniqueInput | UserGlobalRoleWhereUniqueInput[];
    update?:
      | UserGlobalRoleUpdateWithWhereUniqueWithoutUserInput
      | UserGlobalRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserGlobalRoleUpdateManyWithWhereWithoutUserInput
      | UserGlobalRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserGlobalRoleScalarWhereInput | UserGlobalRoleScalarWhereInput[];
  };

  export type UserScholarRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserScholarRoleCreateWithoutUserInput, UserScholarRoleUncheckedCreateWithoutUserInput>
      | UserScholarRoleCreateWithoutUserInput[]
      | UserScholarRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutUserInput
      | UserScholarRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserScholarRoleUpsertWithWhereUniqueWithoutUserInput
      | UserScholarRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserScholarRoleCreateManyUserInputEnvelope;
    set?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    disconnect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    delete?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    update?:
      | UserScholarRoleUpdateWithWhereUniqueWithoutUserInput
      | UserScholarRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserScholarRoleUpdateManyWithWhereWithoutUserInput
      | UserScholarRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
  };

  export type UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutCreatedByUserInput,
          UserScholarRoleUncheckedCreateWithoutCreatedByUserInput
        >
      | UserScholarRoleCreateWithoutCreatedByUserInput[]
      | UserScholarRoleUncheckedCreateWithoutCreatedByUserInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput
      | UserScholarRoleCreateOrConnectWithoutCreatedByUserInput[];
    upsert?:
      | UserScholarRoleUpsertWithWhereUniqueWithoutCreatedByUserInput
      | UserScholarRoleUpsertWithWhereUniqueWithoutCreatedByUserInput[];
    createMany?: UserScholarRoleCreateManyCreatedByUserInputEnvelope;
    set?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    disconnect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    delete?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    update?:
      | UserScholarRoleUpdateWithWhereUniqueWithoutCreatedByUserInput
      | UserScholarRoleUpdateWithWhereUniqueWithoutCreatedByUserInput[];
    updateMany?:
      | UserScholarRoleUpdateManyWithWhereWithoutCreatedByUserInput
      | UserScholarRoleUpdateManyWithWhereWithoutCreatedByUserInput[];
    deleteMany?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
  };

  export type UserLectureProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutUserInput,
          UserLectureProgressUncheckedCreateWithoutUserInput
        >
      | UserLectureProgressCreateWithoutUserInput[]
      | UserLectureProgressUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutUserInput
      | UserLectureProgressCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserLectureProgressUpsertWithWhereUniqueWithoutUserInput
      | UserLectureProgressUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserLectureProgressCreateManyUserInputEnvelope;
    set?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    disconnect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    delete?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    update?:
      | UserLectureProgressUpdateWithWhereUniqueWithoutUserInput
      | UserLectureProgressUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserLectureProgressUpdateManyWithWhereWithoutUserInput
      | UserLectureProgressUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserLectureProgressScalarWhereInput | UserLectureProgressScalarWhereInput[];
  };

  export type FavoriteLectureUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<FavoriteLectureCreateWithoutUserInput, FavoriteLectureUncheckedCreateWithoutUserInput>
      | FavoriteLectureCreateWithoutUserInput[]
      | FavoriteLectureUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutUserInput
      | FavoriteLectureCreateOrConnectWithoutUserInput[];
    upsert?:
      | FavoriteLectureUpsertWithWhereUniqueWithoutUserInput
      | FavoriteLectureUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: FavoriteLectureCreateManyUserInputEnvelope;
    set?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    disconnect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    delete?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    update?:
      | FavoriteLectureUpdateWithWhereUniqueWithoutUserInput
      | FavoriteLectureUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | FavoriteLectureUpdateManyWithWhereWithoutUserInput
      | FavoriteLectureUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: FavoriteLectureScalarWhereInput | FavoriteLectureScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutGlobalRolesInput = {
    create?: XOR<UserCreateWithoutGlobalRolesInput, UserUncheckedCreateWithoutGlobalRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutGlobalRolesInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumGlobalRoleFieldUpdateOperationsInput = {
    set?: $Enums.GlobalRole;
  };

  export type UserUpdateOneRequiredWithoutGlobalRolesNestedInput = {
    create?: XOR<UserCreateWithoutGlobalRolesInput, UserUncheckedCreateWithoutGlobalRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutGlobalRolesInput;
    upsert?: UserUpsertWithoutGlobalRolesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutGlobalRolesInput, UserUpdateWithoutGlobalRolesInput>,
      UserUncheckedUpdateWithoutGlobalRolesInput
    >;
  };

  export type UserCreateNestedOneWithoutScholarRolesInput = {
    create?: XOR<UserCreateWithoutScholarRolesInput, UserUncheckedCreateWithoutScholarRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutScholarRolesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ScholarCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<ScholarCreateWithoutUserRolesInput, ScholarUncheckedCreateWithoutUserRolesInput>;
    connectOrCreate?: ScholarCreateOrConnectWithoutUserRolesInput;
    connect?: ScholarWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutCreatedScholarRolesInput = {
    create?: XOR<
      UserCreateWithoutCreatedScholarRolesInput,
      UserUncheckedCreateWithoutCreatedScholarRolesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedScholarRolesInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumScholarRoleFieldUpdateOperationsInput = {
    set?: $Enums.ScholarRole;
  };

  export type UserUpdateOneRequiredWithoutScholarRolesNestedInput = {
    create?: XOR<UserCreateWithoutScholarRolesInput, UserUncheckedCreateWithoutScholarRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutScholarRolesInput;
    upsert?: UserUpsertWithoutScholarRolesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutScholarRolesInput, UserUpdateWithoutScholarRolesInput>,
      UserUncheckedUpdateWithoutScholarRolesInput
    >;
  };

  export type ScholarUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<ScholarCreateWithoutUserRolesInput, ScholarUncheckedCreateWithoutUserRolesInput>;
    connectOrCreate?: ScholarCreateOrConnectWithoutUserRolesInput;
    upsert?: ScholarUpsertWithoutUserRolesInput;
    connect?: ScholarWhereUniqueInput;
    update?: XOR<
      XOR<ScholarUpdateToOneWithWhereWithoutUserRolesInput, ScholarUpdateWithoutUserRolesInput>,
      ScholarUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type UserUpdateOneWithoutCreatedScholarRolesNestedInput = {
    create?: XOR<
      UserCreateWithoutCreatedScholarRolesInput,
      UserUncheckedCreateWithoutCreatedScholarRolesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedScholarRolesInput;
    upsert?: UserUpsertWithoutCreatedScholarRolesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCreatedScholarRolesInput,
        UserUpdateWithoutCreatedScholarRolesInput
      >,
      UserUncheckedUpdateWithoutCreatedScholarRolesInput
    >;
  };

  export type IngestionBatchCreateNestedOneWithoutScholarsInput = {
    create?: XOR<
      IngestionBatchCreateWithoutScholarsInput,
      IngestionBatchUncheckedCreateWithoutScholarsInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutScholarsInput;
    connect?: IngestionBatchWhereUniqueInput;
  };

  export type CollectionCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<CollectionCreateWithoutScholarInput, CollectionUncheckedCreateWithoutScholarInput>
      | CollectionCreateWithoutScholarInput[]
      | CollectionUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutScholarInput
      | CollectionCreateOrConnectWithoutScholarInput[];
    createMany?: CollectionCreateManyScholarInputEnvelope;
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
  };

  export type SeriesCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<SeriesCreateWithoutScholarInput, SeriesUncheckedCreateWithoutScholarInput>
      | SeriesCreateWithoutScholarInput[]
      | SeriesUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutScholarInput
      | SeriesCreateOrConnectWithoutScholarInput[];
    createMany?: SeriesCreateManyScholarInputEnvelope;
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
  };

  export type LectureCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<LectureCreateWithoutScholarInput, LectureUncheckedCreateWithoutScholarInput>
      | LectureCreateWithoutScholarInput[]
      | LectureUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutScholarInput
      | LectureCreateOrConnectWithoutScholarInput[];
    createMany?: LectureCreateManyScholarInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type UserScholarRoleCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutScholarInput,
          UserScholarRoleUncheckedCreateWithoutScholarInput
        >
      | UserScholarRoleCreateWithoutScholarInput[]
      | UserScholarRoleUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutScholarInput
      | UserScholarRoleCreateOrConnectWithoutScholarInput[];
    createMany?: UserScholarRoleCreateManyScholarInputEnvelope;
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
  };

  export type CollectionUncheckedCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<CollectionCreateWithoutScholarInput, CollectionUncheckedCreateWithoutScholarInput>
      | CollectionCreateWithoutScholarInput[]
      | CollectionUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutScholarInput
      | CollectionCreateOrConnectWithoutScholarInput[];
    createMany?: CollectionCreateManyScholarInputEnvelope;
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
  };

  export type SeriesUncheckedCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<SeriesCreateWithoutScholarInput, SeriesUncheckedCreateWithoutScholarInput>
      | SeriesCreateWithoutScholarInput[]
      | SeriesUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutScholarInput
      | SeriesCreateOrConnectWithoutScholarInput[];
    createMany?: SeriesCreateManyScholarInputEnvelope;
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
  };

  export type LectureUncheckedCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<LectureCreateWithoutScholarInput, LectureUncheckedCreateWithoutScholarInput>
      | LectureCreateWithoutScholarInput[]
      | LectureUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutScholarInput
      | LectureCreateOrConnectWithoutScholarInput[];
    createMany?: LectureCreateManyScholarInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type UserScholarRoleUncheckedCreateNestedManyWithoutScholarInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutScholarInput,
          UserScholarRoleUncheckedCreateWithoutScholarInput
        >
      | UserScholarRoleCreateWithoutScholarInput[]
      | UserScholarRoleUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutScholarInput
      | UserScholarRoleCreateOrConnectWithoutScholarInput[];
    createMany?: UserScholarRoleCreateManyScholarInputEnvelope;
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
  };

  export type IngestionBatchUpdateOneWithoutScholarsNestedInput = {
    create?: XOR<
      IngestionBatchCreateWithoutScholarsInput,
      IngestionBatchUncheckedCreateWithoutScholarsInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutScholarsInput;
    upsert?: IngestionBatchUpsertWithoutScholarsInput;
    disconnect?: IngestionBatchWhereInput | boolean;
    delete?: IngestionBatchWhereInput | boolean;
    connect?: IngestionBatchWhereUniqueInput;
    update?: XOR<
      XOR<
        IngestionBatchUpdateToOneWithWhereWithoutScholarsInput,
        IngestionBatchUpdateWithoutScholarsInput
      >,
      IngestionBatchUncheckedUpdateWithoutScholarsInput
    >;
  };

  export type CollectionUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<CollectionCreateWithoutScholarInput, CollectionUncheckedCreateWithoutScholarInput>
      | CollectionCreateWithoutScholarInput[]
      | CollectionUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutScholarInput
      | CollectionCreateOrConnectWithoutScholarInput[];
    upsert?:
      | CollectionUpsertWithWhereUniqueWithoutScholarInput
      | CollectionUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: CollectionCreateManyScholarInputEnvelope;
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    update?:
      | CollectionUpdateWithWhereUniqueWithoutScholarInput
      | CollectionUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | CollectionUpdateManyWithWhereWithoutScholarInput
      | CollectionUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[];
  };

  export type SeriesUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<SeriesCreateWithoutScholarInput, SeriesUncheckedCreateWithoutScholarInput>
      | SeriesCreateWithoutScholarInput[]
      | SeriesUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutScholarInput
      | SeriesCreateOrConnectWithoutScholarInput[];
    upsert?:
      | SeriesUpsertWithWhereUniqueWithoutScholarInput
      | SeriesUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: SeriesCreateManyScholarInputEnvelope;
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    update?:
      | SeriesUpdateWithWhereUniqueWithoutScholarInput
      | SeriesUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | SeriesUpdateManyWithWhereWithoutScholarInput
      | SeriesUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
  };

  export type LectureUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<LectureCreateWithoutScholarInput, LectureUncheckedCreateWithoutScholarInput>
      | LectureCreateWithoutScholarInput[]
      | LectureUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutScholarInput
      | LectureCreateOrConnectWithoutScholarInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutScholarInput
      | LectureUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: LectureCreateManyScholarInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutScholarInput
      | LectureUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutScholarInput
      | LectureUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type UserScholarRoleUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutScholarInput,
          UserScholarRoleUncheckedCreateWithoutScholarInput
        >
      | UserScholarRoleCreateWithoutScholarInput[]
      | UserScholarRoleUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutScholarInput
      | UserScholarRoleCreateOrConnectWithoutScholarInput[];
    upsert?:
      | UserScholarRoleUpsertWithWhereUniqueWithoutScholarInput
      | UserScholarRoleUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: UserScholarRoleCreateManyScholarInputEnvelope;
    set?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    disconnect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    delete?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    update?:
      | UserScholarRoleUpdateWithWhereUniqueWithoutScholarInput
      | UserScholarRoleUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | UserScholarRoleUpdateManyWithWhereWithoutScholarInput
      | UserScholarRoleUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
  };

  export type CollectionUncheckedUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<CollectionCreateWithoutScholarInput, CollectionUncheckedCreateWithoutScholarInput>
      | CollectionCreateWithoutScholarInput[]
      | CollectionUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | CollectionCreateOrConnectWithoutScholarInput
      | CollectionCreateOrConnectWithoutScholarInput[];
    upsert?:
      | CollectionUpsertWithWhereUniqueWithoutScholarInput
      | CollectionUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: CollectionCreateManyScholarInputEnvelope;
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[];
    update?:
      | CollectionUpdateWithWhereUniqueWithoutScholarInput
      | CollectionUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | CollectionUpdateManyWithWhereWithoutScholarInput
      | CollectionUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[];
  };

  export type SeriesUncheckedUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<SeriesCreateWithoutScholarInput, SeriesUncheckedCreateWithoutScholarInput>
      | SeriesCreateWithoutScholarInput[]
      | SeriesUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutScholarInput
      | SeriesCreateOrConnectWithoutScholarInput[];
    upsert?:
      | SeriesUpsertWithWhereUniqueWithoutScholarInput
      | SeriesUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: SeriesCreateManyScholarInputEnvelope;
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    update?:
      | SeriesUpdateWithWhereUniqueWithoutScholarInput
      | SeriesUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | SeriesUpdateManyWithWhereWithoutScholarInput
      | SeriesUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
  };

  export type LectureUncheckedUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<LectureCreateWithoutScholarInput, LectureUncheckedCreateWithoutScholarInput>
      | LectureCreateWithoutScholarInput[]
      | LectureUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutScholarInput
      | LectureCreateOrConnectWithoutScholarInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutScholarInput
      | LectureUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: LectureCreateManyScholarInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutScholarInput
      | LectureUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutScholarInput
      | LectureUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type UserScholarRoleUncheckedUpdateManyWithoutScholarNestedInput = {
    create?:
      | XOR<
          UserScholarRoleCreateWithoutScholarInput,
          UserScholarRoleUncheckedCreateWithoutScholarInput
        >
      | UserScholarRoleCreateWithoutScholarInput[]
      | UserScholarRoleUncheckedCreateWithoutScholarInput[];
    connectOrCreate?:
      | UserScholarRoleCreateOrConnectWithoutScholarInput
      | UserScholarRoleCreateOrConnectWithoutScholarInput[];
    upsert?:
      | UserScholarRoleUpsertWithWhereUniqueWithoutScholarInput
      | UserScholarRoleUpsertWithWhereUniqueWithoutScholarInput[];
    createMany?: UserScholarRoleCreateManyScholarInputEnvelope;
    set?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    disconnect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    delete?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    connect?: UserScholarRoleWhereUniqueInput | UserScholarRoleWhereUniqueInput[];
    update?:
      | UserScholarRoleUpdateWithWhereUniqueWithoutScholarInput
      | UserScholarRoleUpdateWithWhereUniqueWithoutScholarInput[];
    updateMany?:
      | UserScholarRoleUpdateManyWithWhereWithoutScholarInput
      | UserScholarRoleUpdateManyWithWhereWithoutScholarInput[];
    deleteMany?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
  };

  export type IngestionBatchCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<
      IngestionBatchCreateWithoutCollectionsInput,
      IngestionBatchUncheckedCreateWithoutCollectionsInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutCollectionsInput;
    connect?: IngestionBatchWhereUniqueInput;
  };

  export type ScholarCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<
      ScholarCreateWithoutCollectionsInput,
      ScholarUncheckedCreateWithoutCollectionsInput
    >;
    connectOrCreate?: ScholarCreateOrConnectWithoutCollectionsInput;
    connect?: ScholarWhereUniqueInput;
  };

  export type SeriesCreateNestedManyWithoutCollectionInput = {
    create?:
      | XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>
      | SeriesCreateWithoutCollectionInput[]
      | SeriesUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutCollectionInput
      | SeriesCreateOrConnectWithoutCollectionInput[];
    createMany?: SeriesCreateManyCollectionInputEnvelope;
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
  };

  export type CollectionTopicCreateNestedManyWithoutCollectionInput = {
    create?:
      | XOR<
          CollectionTopicCreateWithoutCollectionInput,
          CollectionTopicUncheckedCreateWithoutCollectionInput
        >
      | CollectionTopicCreateWithoutCollectionInput[]
      | CollectionTopicUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutCollectionInput
      | CollectionTopicCreateOrConnectWithoutCollectionInput[];
    createMany?: CollectionTopicCreateManyCollectionInputEnvelope;
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
  };

  export type SeriesUncheckedCreateNestedManyWithoutCollectionInput = {
    create?:
      | XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>
      | SeriesCreateWithoutCollectionInput[]
      | SeriesUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutCollectionInput
      | SeriesCreateOrConnectWithoutCollectionInput[];
    createMany?: SeriesCreateManyCollectionInputEnvelope;
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
  };

  export type CollectionTopicUncheckedCreateNestedManyWithoutCollectionInput = {
    create?:
      | XOR<
          CollectionTopicCreateWithoutCollectionInput,
          CollectionTopicUncheckedCreateWithoutCollectionInput
        >
      | CollectionTopicCreateWithoutCollectionInput[]
      | CollectionTopicUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutCollectionInput
      | CollectionTopicCreateOrConnectWithoutCollectionInput[];
    createMany?: CollectionTopicCreateManyCollectionInputEnvelope;
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
  };

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type IngestionBatchUpdateOneWithoutCollectionsNestedInput = {
    create?: XOR<
      IngestionBatchCreateWithoutCollectionsInput,
      IngestionBatchUncheckedCreateWithoutCollectionsInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutCollectionsInput;
    upsert?: IngestionBatchUpsertWithoutCollectionsInput;
    disconnect?: IngestionBatchWhereInput | boolean;
    delete?: IngestionBatchWhereInput | boolean;
    connect?: IngestionBatchWhereUniqueInput;
    update?: XOR<
      XOR<
        IngestionBatchUpdateToOneWithWhereWithoutCollectionsInput,
        IngestionBatchUpdateWithoutCollectionsInput
      >,
      IngestionBatchUncheckedUpdateWithoutCollectionsInput
    >;
  };

  export type ScholarUpdateOneRequiredWithoutCollectionsNestedInput = {
    create?: XOR<
      ScholarCreateWithoutCollectionsInput,
      ScholarUncheckedCreateWithoutCollectionsInput
    >;
    connectOrCreate?: ScholarCreateOrConnectWithoutCollectionsInput;
    upsert?: ScholarUpsertWithoutCollectionsInput;
    connect?: ScholarWhereUniqueInput;
    update?: XOR<
      XOR<ScholarUpdateToOneWithWhereWithoutCollectionsInput, ScholarUpdateWithoutCollectionsInput>,
      ScholarUncheckedUpdateWithoutCollectionsInput
    >;
  };

  export type SeriesUpdateManyWithoutCollectionNestedInput = {
    create?:
      | XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>
      | SeriesCreateWithoutCollectionInput[]
      | SeriesUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutCollectionInput
      | SeriesCreateOrConnectWithoutCollectionInput[];
    upsert?:
      | SeriesUpsertWithWhereUniqueWithoutCollectionInput
      | SeriesUpsertWithWhereUniqueWithoutCollectionInput[];
    createMany?: SeriesCreateManyCollectionInputEnvelope;
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    update?:
      | SeriesUpdateWithWhereUniqueWithoutCollectionInput
      | SeriesUpdateWithWhereUniqueWithoutCollectionInput[];
    updateMany?:
      | SeriesUpdateManyWithWhereWithoutCollectionInput
      | SeriesUpdateManyWithWhereWithoutCollectionInput[];
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
  };

  export type CollectionTopicUpdateManyWithoutCollectionNestedInput = {
    create?:
      | XOR<
          CollectionTopicCreateWithoutCollectionInput,
          CollectionTopicUncheckedCreateWithoutCollectionInput
        >
      | CollectionTopicCreateWithoutCollectionInput[]
      | CollectionTopicUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutCollectionInput
      | CollectionTopicCreateOrConnectWithoutCollectionInput[];
    upsert?:
      | CollectionTopicUpsertWithWhereUniqueWithoutCollectionInput
      | CollectionTopicUpsertWithWhereUniqueWithoutCollectionInput[];
    createMany?: CollectionTopicCreateManyCollectionInputEnvelope;
    set?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    disconnect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    delete?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    update?:
      | CollectionTopicUpdateWithWhereUniqueWithoutCollectionInput
      | CollectionTopicUpdateWithWhereUniqueWithoutCollectionInput[];
    updateMany?:
      | CollectionTopicUpdateManyWithWhereWithoutCollectionInput
      | CollectionTopicUpdateManyWithWhereWithoutCollectionInput[];
    deleteMany?: CollectionTopicScalarWhereInput | CollectionTopicScalarWhereInput[];
  };

  export type SeriesUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?:
      | XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>
      | SeriesCreateWithoutCollectionInput[]
      | SeriesUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | SeriesCreateOrConnectWithoutCollectionInput
      | SeriesCreateOrConnectWithoutCollectionInput[];
    upsert?:
      | SeriesUpsertWithWhereUniqueWithoutCollectionInput
      | SeriesUpsertWithWhereUniqueWithoutCollectionInput[];
    createMany?: SeriesCreateManyCollectionInputEnvelope;
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[];
    update?:
      | SeriesUpdateWithWhereUniqueWithoutCollectionInput
      | SeriesUpdateWithWhereUniqueWithoutCollectionInput[];
    updateMany?:
      | SeriesUpdateManyWithWhereWithoutCollectionInput
      | SeriesUpdateManyWithWhereWithoutCollectionInput[];
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
  };

  export type CollectionTopicUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?:
      | XOR<
          CollectionTopicCreateWithoutCollectionInput,
          CollectionTopicUncheckedCreateWithoutCollectionInput
        >
      | CollectionTopicCreateWithoutCollectionInput[]
      | CollectionTopicUncheckedCreateWithoutCollectionInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutCollectionInput
      | CollectionTopicCreateOrConnectWithoutCollectionInput[];
    upsert?:
      | CollectionTopicUpsertWithWhereUniqueWithoutCollectionInput
      | CollectionTopicUpsertWithWhereUniqueWithoutCollectionInput[];
    createMany?: CollectionTopicCreateManyCollectionInputEnvelope;
    set?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    disconnect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    delete?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    update?:
      | CollectionTopicUpdateWithWhereUniqueWithoutCollectionInput
      | CollectionTopicUpdateWithWhereUniqueWithoutCollectionInput[];
    updateMany?:
      | CollectionTopicUpdateManyWithWhereWithoutCollectionInput
      | CollectionTopicUpdateManyWithWhereWithoutCollectionInput[];
    deleteMany?: CollectionTopicScalarWhereInput | CollectionTopicScalarWhereInput[];
  };

  export type IngestionBatchCreateNestedOneWithoutSeriesInput = {
    create?: XOR<
      IngestionBatchCreateWithoutSeriesInput,
      IngestionBatchUncheckedCreateWithoutSeriesInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutSeriesInput;
    connect?: IngestionBatchWhereUniqueInput;
  };

  export type ScholarCreateNestedOneWithoutSeriesInput = {
    create?: XOR<ScholarCreateWithoutSeriesInput, ScholarUncheckedCreateWithoutSeriesInput>;
    connectOrCreate?: ScholarCreateOrConnectWithoutSeriesInput;
    connect?: ScholarWhereUniqueInput;
  };

  export type CollectionCreateNestedOneWithoutSeriesInput = {
    create?: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>;
    connectOrCreate?: CollectionCreateOrConnectWithoutSeriesInput;
    connect?: CollectionWhereUniqueInput;
  };

  export type LectureCreateNestedManyWithoutSeriesInput = {
    create?:
      | XOR<LectureCreateWithoutSeriesInput, LectureUncheckedCreateWithoutSeriesInput>
      | LectureCreateWithoutSeriesInput[]
      | LectureUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSeriesInput
      | LectureCreateOrConnectWithoutSeriesInput[];
    createMany?: LectureCreateManySeriesInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type SeriesTopicCreateNestedManyWithoutSeriesInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutSeriesInput, SeriesTopicUncheckedCreateWithoutSeriesInput>
      | SeriesTopicCreateWithoutSeriesInput[]
      | SeriesTopicUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutSeriesInput
      | SeriesTopicCreateOrConnectWithoutSeriesInput[];
    createMany?: SeriesTopicCreateManySeriesInputEnvelope;
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
  };

  export type LectureUncheckedCreateNestedManyWithoutSeriesInput = {
    create?:
      | XOR<LectureCreateWithoutSeriesInput, LectureUncheckedCreateWithoutSeriesInput>
      | LectureCreateWithoutSeriesInput[]
      | LectureUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSeriesInput
      | LectureCreateOrConnectWithoutSeriesInput[];
    createMany?: LectureCreateManySeriesInputEnvelope;
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
  };

  export type SeriesTopicUncheckedCreateNestedManyWithoutSeriesInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutSeriesInput, SeriesTopicUncheckedCreateWithoutSeriesInput>
      | SeriesTopicCreateWithoutSeriesInput[]
      | SeriesTopicUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutSeriesInput
      | SeriesTopicCreateOrConnectWithoutSeriesInput[];
    createMany?: SeriesTopicCreateManySeriesInputEnvelope;
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
  };

  export type IngestionBatchUpdateOneWithoutSeriesNestedInput = {
    create?: XOR<
      IngestionBatchCreateWithoutSeriesInput,
      IngestionBatchUncheckedCreateWithoutSeriesInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutSeriesInput;
    upsert?: IngestionBatchUpsertWithoutSeriesInput;
    disconnect?: IngestionBatchWhereInput | boolean;
    delete?: IngestionBatchWhereInput | boolean;
    connect?: IngestionBatchWhereUniqueInput;
    update?: XOR<
      XOR<
        IngestionBatchUpdateToOneWithWhereWithoutSeriesInput,
        IngestionBatchUpdateWithoutSeriesInput
      >,
      IngestionBatchUncheckedUpdateWithoutSeriesInput
    >;
  };

  export type ScholarUpdateOneRequiredWithoutSeriesNestedInput = {
    create?: XOR<ScholarCreateWithoutSeriesInput, ScholarUncheckedCreateWithoutSeriesInput>;
    connectOrCreate?: ScholarCreateOrConnectWithoutSeriesInput;
    upsert?: ScholarUpsertWithoutSeriesInput;
    connect?: ScholarWhereUniqueInput;
    update?: XOR<
      XOR<ScholarUpdateToOneWithWhereWithoutSeriesInput, ScholarUpdateWithoutSeriesInput>,
      ScholarUncheckedUpdateWithoutSeriesInput
    >;
  };

  export type CollectionUpdateOneWithoutSeriesNestedInput = {
    create?: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>;
    connectOrCreate?: CollectionCreateOrConnectWithoutSeriesInput;
    upsert?: CollectionUpsertWithoutSeriesInput;
    disconnect?: CollectionWhereInput | boolean;
    delete?: CollectionWhereInput | boolean;
    connect?: CollectionWhereUniqueInput;
    update?: XOR<
      XOR<CollectionUpdateToOneWithWhereWithoutSeriesInput, CollectionUpdateWithoutSeriesInput>,
      CollectionUncheckedUpdateWithoutSeriesInput
    >;
  };

  export type LectureUpdateManyWithoutSeriesNestedInput = {
    create?:
      | XOR<LectureCreateWithoutSeriesInput, LectureUncheckedCreateWithoutSeriesInput>
      | LectureCreateWithoutSeriesInput[]
      | LectureUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSeriesInput
      | LectureCreateOrConnectWithoutSeriesInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutSeriesInput
      | LectureUpsertWithWhereUniqueWithoutSeriesInput[];
    createMany?: LectureCreateManySeriesInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutSeriesInput
      | LectureUpdateWithWhereUniqueWithoutSeriesInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutSeriesInput
      | LectureUpdateManyWithWhereWithoutSeriesInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type SeriesTopicUpdateManyWithoutSeriesNestedInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutSeriesInput, SeriesTopicUncheckedCreateWithoutSeriesInput>
      | SeriesTopicCreateWithoutSeriesInput[]
      | SeriesTopicUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutSeriesInput
      | SeriesTopicCreateOrConnectWithoutSeriesInput[];
    upsert?:
      | SeriesTopicUpsertWithWhereUniqueWithoutSeriesInput
      | SeriesTopicUpsertWithWhereUniqueWithoutSeriesInput[];
    createMany?: SeriesTopicCreateManySeriesInputEnvelope;
    set?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    disconnect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    delete?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    update?:
      | SeriesTopicUpdateWithWhereUniqueWithoutSeriesInput
      | SeriesTopicUpdateWithWhereUniqueWithoutSeriesInput[];
    updateMany?:
      | SeriesTopicUpdateManyWithWhereWithoutSeriesInput
      | SeriesTopicUpdateManyWithWhereWithoutSeriesInput[];
    deleteMany?: SeriesTopicScalarWhereInput | SeriesTopicScalarWhereInput[];
  };

  export type LectureUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?:
      | XOR<LectureCreateWithoutSeriesInput, LectureUncheckedCreateWithoutSeriesInput>
      | LectureCreateWithoutSeriesInput[]
      | LectureUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | LectureCreateOrConnectWithoutSeriesInput
      | LectureCreateOrConnectWithoutSeriesInput[];
    upsert?:
      | LectureUpsertWithWhereUniqueWithoutSeriesInput
      | LectureUpsertWithWhereUniqueWithoutSeriesInput[];
    createMany?: LectureCreateManySeriesInputEnvelope;
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[];
    update?:
      | LectureUpdateWithWhereUniqueWithoutSeriesInput
      | LectureUpdateWithWhereUniqueWithoutSeriesInput[];
    updateMany?:
      | LectureUpdateManyWithWhereWithoutSeriesInput
      | LectureUpdateManyWithWhereWithoutSeriesInput[];
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[];
  };

  export type SeriesTopicUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutSeriesInput, SeriesTopicUncheckedCreateWithoutSeriesInput>
      | SeriesTopicCreateWithoutSeriesInput[]
      | SeriesTopicUncheckedCreateWithoutSeriesInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutSeriesInput
      | SeriesTopicCreateOrConnectWithoutSeriesInput[];
    upsert?:
      | SeriesTopicUpsertWithWhereUniqueWithoutSeriesInput
      | SeriesTopicUpsertWithWhereUniqueWithoutSeriesInput[];
    createMany?: SeriesTopicCreateManySeriesInputEnvelope;
    set?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    disconnect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    delete?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    update?:
      | SeriesTopicUpdateWithWhereUniqueWithoutSeriesInput
      | SeriesTopicUpdateWithWhereUniqueWithoutSeriesInput[];
    updateMany?:
      | SeriesTopicUpdateManyWithWhereWithoutSeriesInput
      | SeriesTopicUpdateManyWithWhereWithoutSeriesInput[];
    deleteMany?: SeriesTopicScalarWhereInput | SeriesTopicScalarWhereInput[];
  };

  export type IngestionBatchCreateNestedOneWithoutLecturesInput = {
    create?: XOR<
      IngestionBatchCreateWithoutLecturesInput,
      IngestionBatchUncheckedCreateWithoutLecturesInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutLecturesInput;
    connect?: IngestionBatchWhereUniqueInput;
  };

  export type ScholarCreateNestedOneWithoutLecturesInput = {
    create?: XOR<ScholarCreateWithoutLecturesInput, ScholarUncheckedCreateWithoutLecturesInput>;
    connectOrCreate?: ScholarCreateOrConnectWithoutLecturesInput;
    connect?: ScholarWhereUniqueInput;
  };

  export type SeriesCreateNestedOneWithoutLecturesInput = {
    create?: XOR<SeriesCreateWithoutLecturesInput, SeriesUncheckedCreateWithoutLecturesInput>;
    connectOrCreate?: SeriesCreateOrConnectWithoutLecturesInput;
    connect?: SeriesWhereUniqueInput;
  };

  export type AudioAssetCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<AudioAssetCreateWithoutLectureInput, AudioAssetUncheckedCreateWithoutLectureInput>
      | AudioAssetCreateWithoutLectureInput[]
      | AudioAssetUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutLectureInput
      | AudioAssetCreateOrConnectWithoutLectureInput[];
    createMany?: AudioAssetCreateManyLectureInputEnvelope;
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
  };

  export type LectureTopicCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<LectureTopicCreateWithoutLectureInput, LectureTopicUncheckedCreateWithoutLectureInput>
      | LectureTopicCreateWithoutLectureInput[]
      | LectureTopicUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutLectureInput
      | LectureTopicCreateOrConnectWithoutLectureInput[];
    createMany?: LectureTopicCreateManyLectureInputEnvelope;
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
  };

  export type UserLectureProgressCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutLectureInput,
          UserLectureProgressUncheckedCreateWithoutLectureInput
        >
      | UserLectureProgressCreateWithoutLectureInput[]
      | UserLectureProgressUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutLectureInput
      | UserLectureProgressCreateOrConnectWithoutLectureInput[];
    createMany?: UserLectureProgressCreateManyLectureInputEnvelope;
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
  };

  export type FavoriteLectureCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          FavoriteLectureCreateWithoutLectureInput,
          FavoriteLectureUncheckedCreateWithoutLectureInput
        >
      | FavoriteLectureCreateWithoutLectureInput[]
      | FavoriteLectureUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutLectureInput
      | FavoriteLectureCreateOrConnectWithoutLectureInput[];
    createMany?: FavoriteLectureCreateManyLectureInputEnvelope;
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
  };

  export type AudioAssetUncheckedCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<AudioAssetCreateWithoutLectureInput, AudioAssetUncheckedCreateWithoutLectureInput>
      | AudioAssetCreateWithoutLectureInput[]
      | AudioAssetUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutLectureInput
      | AudioAssetCreateOrConnectWithoutLectureInput[];
    createMany?: AudioAssetCreateManyLectureInputEnvelope;
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
  };

  export type LectureTopicUncheckedCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<LectureTopicCreateWithoutLectureInput, LectureTopicUncheckedCreateWithoutLectureInput>
      | LectureTopicCreateWithoutLectureInput[]
      | LectureTopicUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutLectureInput
      | LectureTopicCreateOrConnectWithoutLectureInput[];
    createMany?: LectureTopicCreateManyLectureInputEnvelope;
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
  };

  export type UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutLectureInput,
          UserLectureProgressUncheckedCreateWithoutLectureInput
        >
      | UserLectureProgressCreateWithoutLectureInput[]
      | UserLectureProgressUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutLectureInput
      | UserLectureProgressCreateOrConnectWithoutLectureInput[];
    createMany?: UserLectureProgressCreateManyLectureInputEnvelope;
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
  };

  export type FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput = {
    create?:
      | XOR<
          FavoriteLectureCreateWithoutLectureInput,
          FavoriteLectureUncheckedCreateWithoutLectureInput
        >
      | FavoriteLectureCreateWithoutLectureInput[]
      | FavoriteLectureUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutLectureInput
      | FavoriteLectureCreateOrConnectWithoutLectureInput[];
    createMany?: FavoriteLectureCreateManyLectureInputEnvelope;
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
  };

  export type IngestionBatchUpdateOneWithoutLecturesNestedInput = {
    create?: XOR<
      IngestionBatchCreateWithoutLecturesInput,
      IngestionBatchUncheckedCreateWithoutLecturesInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutLecturesInput;
    upsert?: IngestionBatchUpsertWithoutLecturesInput;
    disconnect?: IngestionBatchWhereInput | boolean;
    delete?: IngestionBatchWhereInput | boolean;
    connect?: IngestionBatchWhereUniqueInput;
    update?: XOR<
      XOR<
        IngestionBatchUpdateToOneWithWhereWithoutLecturesInput,
        IngestionBatchUpdateWithoutLecturesInput
      >,
      IngestionBatchUncheckedUpdateWithoutLecturesInput
    >;
  };

  export type ScholarUpdateOneRequiredWithoutLecturesNestedInput = {
    create?: XOR<ScholarCreateWithoutLecturesInput, ScholarUncheckedCreateWithoutLecturesInput>;
    connectOrCreate?: ScholarCreateOrConnectWithoutLecturesInput;
    upsert?: ScholarUpsertWithoutLecturesInput;
    connect?: ScholarWhereUniqueInput;
    update?: XOR<
      XOR<ScholarUpdateToOneWithWhereWithoutLecturesInput, ScholarUpdateWithoutLecturesInput>,
      ScholarUncheckedUpdateWithoutLecturesInput
    >;
  };

  export type SeriesUpdateOneWithoutLecturesNestedInput = {
    create?: XOR<SeriesCreateWithoutLecturesInput, SeriesUncheckedCreateWithoutLecturesInput>;
    connectOrCreate?: SeriesCreateOrConnectWithoutLecturesInput;
    upsert?: SeriesUpsertWithoutLecturesInput;
    disconnect?: SeriesWhereInput | boolean;
    delete?: SeriesWhereInput | boolean;
    connect?: SeriesWhereUniqueInput;
    update?: XOR<
      XOR<SeriesUpdateToOneWithWhereWithoutLecturesInput, SeriesUpdateWithoutLecturesInput>,
      SeriesUncheckedUpdateWithoutLecturesInput
    >;
  };

  export type AudioAssetUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<AudioAssetCreateWithoutLectureInput, AudioAssetUncheckedCreateWithoutLectureInput>
      | AudioAssetCreateWithoutLectureInput[]
      | AudioAssetUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutLectureInput
      | AudioAssetCreateOrConnectWithoutLectureInput[];
    upsert?:
      | AudioAssetUpsertWithWhereUniqueWithoutLectureInput
      | AudioAssetUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: AudioAssetCreateManyLectureInputEnvelope;
    set?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    disconnect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    delete?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    update?:
      | AudioAssetUpdateWithWhereUniqueWithoutLectureInput
      | AudioAssetUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | AudioAssetUpdateManyWithWhereWithoutLectureInput
      | AudioAssetUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: AudioAssetScalarWhereInput | AudioAssetScalarWhereInput[];
  };

  export type LectureTopicUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<LectureTopicCreateWithoutLectureInput, LectureTopicUncheckedCreateWithoutLectureInput>
      | LectureTopicCreateWithoutLectureInput[]
      | LectureTopicUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutLectureInput
      | LectureTopicCreateOrConnectWithoutLectureInput[];
    upsert?:
      | LectureTopicUpsertWithWhereUniqueWithoutLectureInput
      | LectureTopicUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: LectureTopicCreateManyLectureInputEnvelope;
    set?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    disconnect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    delete?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    update?:
      | LectureTopicUpdateWithWhereUniqueWithoutLectureInput
      | LectureTopicUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | LectureTopicUpdateManyWithWhereWithoutLectureInput
      | LectureTopicUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: LectureTopicScalarWhereInput | LectureTopicScalarWhereInput[];
  };

  export type UserLectureProgressUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutLectureInput,
          UserLectureProgressUncheckedCreateWithoutLectureInput
        >
      | UserLectureProgressCreateWithoutLectureInput[]
      | UserLectureProgressUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutLectureInput
      | UserLectureProgressCreateOrConnectWithoutLectureInput[];
    upsert?:
      | UserLectureProgressUpsertWithWhereUniqueWithoutLectureInput
      | UserLectureProgressUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: UserLectureProgressCreateManyLectureInputEnvelope;
    set?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    disconnect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    delete?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    update?:
      | UserLectureProgressUpdateWithWhereUniqueWithoutLectureInput
      | UserLectureProgressUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | UserLectureProgressUpdateManyWithWhereWithoutLectureInput
      | UserLectureProgressUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: UserLectureProgressScalarWhereInput | UserLectureProgressScalarWhereInput[];
  };

  export type FavoriteLectureUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          FavoriteLectureCreateWithoutLectureInput,
          FavoriteLectureUncheckedCreateWithoutLectureInput
        >
      | FavoriteLectureCreateWithoutLectureInput[]
      | FavoriteLectureUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutLectureInput
      | FavoriteLectureCreateOrConnectWithoutLectureInput[];
    upsert?:
      | FavoriteLectureUpsertWithWhereUniqueWithoutLectureInput
      | FavoriteLectureUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: FavoriteLectureCreateManyLectureInputEnvelope;
    set?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    disconnect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    delete?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    update?:
      | FavoriteLectureUpdateWithWhereUniqueWithoutLectureInput
      | FavoriteLectureUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | FavoriteLectureUpdateManyWithWhereWithoutLectureInput
      | FavoriteLectureUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: FavoriteLectureScalarWhereInput | FavoriteLectureScalarWhereInput[];
  };

  export type AudioAssetUncheckedUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<AudioAssetCreateWithoutLectureInput, AudioAssetUncheckedCreateWithoutLectureInput>
      | AudioAssetCreateWithoutLectureInput[]
      | AudioAssetUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | AudioAssetCreateOrConnectWithoutLectureInput
      | AudioAssetCreateOrConnectWithoutLectureInput[];
    upsert?:
      | AudioAssetUpsertWithWhereUniqueWithoutLectureInput
      | AudioAssetUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: AudioAssetCreateManyLectureInputEnvelope;
    set?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    disconnect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    delete?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    connect?: AudioAssetWhereUniqueInput | AudioAssetWhereUniqueInput[];
    update?:
      | AudioAssetUpdateWithWhereUniqueWithoutLectureInput
      | AudioAssetUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | AudioAssetUpdateManyWithWhereWithoutLectureInput
      | AudioAssetUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: AudioAssetScalarWhereInput | AudioAssetScalarWhereInput[];
  };

  export type LectureTopicUncheckedUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<LectureTopicCreateWithoutLectureInput, LectureTopicUncheckedCreateWithoutLectureInput>
      | LectureTopicCreateWithoutLectureInput[]
      | LectureTopicUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutLectureInput
      | LectureTopicCreateOrConnectWithoutLectureInput[];
    upsert?:
      | LectureTopicUpsertWithWhereUniqueWithoutLectureInput
      | LectureTopicUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: LectureTopicCreateManyLectureInputEnvelope;
    set?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    disconnect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    delete?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    update?:
      | LectureTopicUpdateWithWhereUniqueWithoutLectureInput
      | LectureTopicUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | LectureTopicUpdateManyWithWhereWithoutLectureInput
      | LectureTopicUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: LectureTopicScalarWhereInput | LectureTopicScalarWhereInput[];
  };

  export type UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          UserLectureProgressCreateWithoutLectureInput,
          UserLectureProgressUncheckedCreateWithoutLectureInput
        >
      | UserLectureProgressCreateWithoutLectureInput[]
      | UserLectureProgressUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | UserLectureProgressCreateOrConnectWithoutLectureInput
      | UserLectureProgressCreateOrConnectWithoutLectureInput[];
    upsert?:
      | UserLectureProgressUpsertWithWhereUniqueWithoutLectureInput
      | UserLectureProgressUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: UserLectureProgressCreateManyLectureInputEnvelope;
    set?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    disconnect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    delete?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    connect?: UserLectureProgressWhereUniqueInput | UserLectureProgressWhereUniqueInput[];
    update?:
      | UserLectureProgressUpdateWithWhereUniqueWithoutLectureInput
      | UserLectureProgressUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | UserLectureProgressUpdateManyWithWhereWithoutLectureInput
      | UserLectureProgressUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: UserLectureProgressScalarWhereInput | UserLectureProgressScalarWhereInput[];
  };

  export type FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput = {
    create?:
      | XOR<
          FavoriteLectureCreateWithoutLectureInput,
          FavoriteLectureUncheckedCreateWithoutLectureInput
        >
      | FavoriteLectureCreateWithoutLectureInput[]
      | FavoriteLectureUncheckedCreateWithoutLectureInput[];
    connectOrCreate?:
      | FavoriteLectureCreateOrConnectWithoutLectureInput
      | FavoriteLectureCreateOrConnectWithoutLectureInput[];
    upsert?:
      | FavoriteLectureUpsertWithWhereUniqueWithoutLectureInput
      | FavoriteLectureUpsertWithWhereUniqueWithoutLectureInput[];
    createMany?: FavoriteLectureCreateManyLectureInputEnvelope;
    set?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    disconnect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    delete?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    connect?: FavoriteLectureWhereUniqueInput | FavoriteLectureWhereUniqueInput[];
    update?:
      | FavoriteLectureUpdateWithWhereUniqueWithoutLectureInput
      | FavoriteLectureUpdateWithWhereUniqueWithoutLectureInput[];
    updateMany?:
      | FavoriteLectureUpdateManyWithWhereWithoutLectureInput
      | FavoriteLectureUpdateManyWithWhereWithoutLectureInput[];
    deleteMany?: FavoriteLectureScalarWhereInput | FavoriteLectureScalarWhereInput[];
  };

  export type IngestionBatchCreateNestedOneWithoutAudioAssetsInput = {
    create?: XOR<
      IngestionBatchCreateWithoutAudioAssetsInput,
      IngestionBatchUncheckedCreateWithoutAudioAssetsInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutAudioAssetsInput;
    connect?: IngestionBatchWhereUniqueInput;
  };

  export type LectureCreateNestedOneWithoutAudioAssetsInput = {
    create?: XOR<
      LectureCreateWithoutAudioAssetsInput,
      LectureUncheckedCreateWithoutAudioAssetsInput
    >;
    connectOrCreate?: LectureCreateOrConnectWithoutAudioAssetsInput;
    connect?: LectureWhereUniqueInput;
  };

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null;
    increment?: bigint | number;
    decrement?: bigint | number;
    multiply?: bigint | number;
    divide?: bigint | number;
  };

  export type IngestionBatchUpdateOneWithoutAudioAssetsNestedInput = {
    create?: XOR<
      IngestionBatchCreateWithoutAudioAssetsInput,
      IngestionBatchUncheckedCreateWithoutAudioAssetsInput
    >;
    connectOrCreate?: IngestionBatchCreateOrConnectWithoutAudioAssetsInput;
    upsert?: IngestionBatchUpsertWithoutAudioAssetsInput;
    disconnect?: IngestionBatchWhereInput | boolean;
    delete?: IngestionBatchWhereInput | boolean;
    connect?: IngestionBatchWhereUniqueInput;
    update?: XOR<
      XOR<
        IngestionBatchUpdateToOneWithWhereWithoutAudioAssetsInput,
        IngestionBatchUpdateWithoutAudioAssetsInput
      >,
      IngestionBatchUncheckedUpdateWithoutAudioAssetsInput
    >;
  };

  export type LectureUpdateOneRequiredWithoutAudioAssetsNestedInput = {
    create?: XOR<
      LectureCreateWithoutAudioAssetsInput,
      LectureUncheckedCreateWithoutAudioAssetsInput
    >;
    connectOrCreate?: LectureCreateOrConnectWithoutAudioAssetsInput;
    upsert?: LectureUpsertWithoutAudioAssetsInput;
    connect?: LectureWhereUniqueInput;
    update?: XOR<
      XOR<LectureUpdateToOneWithWhereWithoutAudioAssetsInput, LectureUpdateWithoutAudioAssetsInput>,
      LectureUncheckedUpdateWithoutAudioAssetsInput
    >;
  };

  export type TopicCreateNestedOneWithoutChildrenInput = {
    create?: XOR<TopicCreateWithoutChildrenInput, TopicUncheckedCreateWithoutChildrenInput>;
    connectOrCreate?: TopicCreateOrConnectWithoutChildrenInput;
    connect?: TopicWhereUniqueInput;
  };

  export type TopicCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<TopicCreateWithoutParentInput, TopicUncheckedCreateWithoutParentInput>
      | TopicCreateWithoutParentInput[]
      | TopicUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TopicCreateOrConnectWithoutParentInput
      | TopicCreateOrConnectWithoutParentInput[];
    createMany?: TopicCreateManyParentInputEnvelope;
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
  };

  export type LectureTopicCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<LectureTopicCreateWithoutTopicInput, LectureTopicUncheckedCreateWithoutTopicInput>
      | LectureTopicCreateWithoutTopicInput[]
      | LectureTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutTopicInput
      | LectureTopicCreateOrConnectWithoutTopicInput[];
    createMany?: LectureTopicCreateManyTopicInputEnvelope;
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
  };

  export type SeriesTopicCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutTopicInput, SeriesTopicUncheckedCreateWithoutTopicInput>
      | SeriesTopicCreateWithoutTopicInput[]
      | SeriesTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutTopicInput
      | SeriesTopicCreateOrConnectWithoutTopicInput[];
    createMany?: SeriesTopicCreateManyTopicInputEnvelope;
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
  };

  export type CollectionTopicCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<CollectionTopicCreateWithoutTopicInput, CollectionTopicUncheckedCreateWithoutTopicInput>
      | CollectionTopicCreateWithoutTopicInput[]
      | CollectionTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutTopicInput
      | CollectionTopicCreateOrConnectWithoutTopicInput[];
    createMany?: CollectionTopicCreateManyTopicInputEnvelope;
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
  };

  export type TopicUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<TopicCreateWithoutParentInput, TopicUncheckedCreateWithoutParentInput>
      | TopicCreateWithoutParentInput[]
      | TopicUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TopicCreateOrConnectWithoutParentInput
      | TopicCreateOrConnectWithoutParentInput[];
    createMany?: TopicCreateManyParentInputEnvelope;
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
  };

  export type LectureTopicUncheckedCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<LectureTopicCreateWithoutTopicInput, LectureTopicUncheckedCreateWithoutTopicInput>
      | LectureTopicCreateWithoutTopicInput[]
      | LectureTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutTopicInput
      | LectureTopicCreateOrConnectWithoutTopicInput[];
    createMany?: LectureTopicCreateManyTopicInputEnvelope;
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
  };

  export type SeriesTopicUncheckedCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutTopicInput, SeriesTopicUncheckedCreateWithoutTopicInput>
      | SeriesTopicCreateWithoutTopicInput[]
      | SeriesTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutTopicInput
      | SeriesTopicCreateOrConnectWithoutTopicInput[];
    createMany?: SeriesTopicCreateManyTopicInputEnvelope;
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
  };

  export type CollectionTopicUncheckedCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<CollectionTopicCreateWithoutTopicInput, CollectionTopicUncheckedCreateWithoutTopicInput>
      | CollectionTopicCreateWithoutTopicInput[]
      | CollectionTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutTopicInput
      | CollectionTopicCreateOrConnectWithoutTopicInput[];
    createMany?: CollectionTopicCreateManyTopicInputEnvelope;
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
  };

  export type TopicUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<TopicCreateWithoutChildrenInput, TopicUncheckedCreateWithoutChildrenInput>;
    connectOrCreate?: TopicCreateOrConnectWithoutChildrenInput;
    upsert?: TopicUpsertWithoutChildrenInput;
    disconnect?: TopicWhereInput | boolean;
    delete?: TopicWhereInput | boolean;
    connect?: TopicWhereUniqueInput;
    update?: XOR<
      XOR<TopicUpdateToOneWithWhereWithoutChildrenInput, TopicUpdateWithoutChildrenInput>,
      TopicUncheckedUpdateWithoutChildrenInput
    >;
  };

  export type TopicUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<TopicCreateWithoutParentInput, TopicUncheckedCreateWithoutParentInput>
      | TopicCreateWithoutParentInput[]
      | TopicUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TopicCreateOrConnectWithoutParentInput
      | TopicCreateOrConnectWithoutParentInput[];
    upsert?:
      | TopicUpsertWithWhereUniqueWithoutParentInput
      | TopicUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: TopicCreateManyParentInputEnvelope;
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    update?:
      | TopicUpdateWithWhereUniqueWithoutParentInput
      | TopicUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | TopicUpdateManyWithWhereWithoutParentInput
      | TopicUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[];
  };

  export type LectureTopicUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<LectureTopicCreateWithoutTopicInput, LectureTopicUncheckedCreateWithoutTopicInput>
      | LectureTopicCreateWithoutTopicInput[]
      | LectureTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutTopicInput
      | LectureTopicCreateOrConnectWithoutTopicInput[];
    upsert?:
      | LectureTopicUpsertWithWhereUniqueWithoutTopicInput
      | LectureTopicUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: LectureTopicCreateManyTopicInputEnvelope;
    set?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    disconnect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    delete?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    update?:
      | LectureTopicUpdateWithWhereUniqueWithoutTopicInput
      | LectureTopicUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | LectureTopicUpdateManyWithWhereWithoutTopicInput
      | LectureTopicUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: LectureTopicScalarWhereInput | LectureTopicScalarWhereInput[];
  };

  export type SeriesTopicUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutTopicInput, SeriesTopicUncheckedCreateWithoutTopicInput>
      | SeriesTopicCreateWithoutTopicInput[]
      | SeriesTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutTopicInput
      | SeriesTopicCreateOrConnectWithoutTopicInput[];
    upsert?:
      | SeriesTopicUpsertWithWhereUniqueWithoutTopicInput
      | SeriesTopicUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: SeriesTopicCreateManyTopicInputEnvelope;
    set?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    disconnect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    delete?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    update?:
      | SeriesTopicUpdateWithWhereUniqueWithoutTopicInput
      | SeriesTopicUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | SeriesTopicUpdateManyWithWhereWithoutTopicInput
      | SeriesTopicUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: SeriesTopicScalarWhereInput | SeriesTopicScalarWhereInput[];
  };

  export type CollectionTopicUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<CollectionTopicCreateWithoutTopicInput, CollectionTopicUncheckedCreateWithoutTopicInput>
      | CollectionTopicCreateWithoutTopicInput[]
      | CollectionTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutTopicInput
      | CollectionTopicCreateOrConnectWithoutTopicInput[];
    upsert?:
      | CollectionTopicUpsertWithWhereUniqueWithoutTopicInput
      | CollectionTopicUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: CollectionTopicCreateManyTopicInputEnvelope;
    set?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    disconnect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    delete?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    update?:
      | CollectionTopicUpdateWithWhereUniqueWithoutTopicInput
      | CollectionTopicUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | CollectionTopicUpdateManyWithWhereWithoutTopicInput
      | CollectionTopicUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: CollectionTopicScalarWhereInput | CollectionTopicScalarWhereInput[];
  };

  export type TopicUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<TopicCreateWithoutParentInput, TopicUncheckedCreateWithoutParentInput>
      | TopicCreateWithoutParentInput[]
      | TopicUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | TopicCreateOrConnectWithoutParentInput
      | TopicCreateOrConnectWithoutParentInput[];
    upsert?:
      | TopicUpsertWithWhereUniqueWithoutParentInput
      | TopicUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: TopicCreateManyParentInputEnvelope;
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[];
    update?:
      | TopicUpdateWithWhereUniqueWithoutParentInput
      | TopicUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | TopicUpdateManyWithWhereWithoutParentInput
      | TopicUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[];
  };

  export type LectureTopicUncheckedUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<LectureTopicCreateWithoutTopicInput, LectureTopicUncheckedCreateWithoutTopicInput>
      | LectureTopicCreateWithoutTopicInput[]
      | LectureTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | LectureTopicCreateOrConnectWithoutTopicInput
      | LectureTopicCreateOrConnectWithoutTopicInput[];
    upsert?:
      | LectureTopicUpsertWithWhereUniqueWithoutTopicInput
      | LectureTopicUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: LectureTopicCreateManyTopicInputEnvelope;
    set?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    disconnect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    delete?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    connect?: LectureTopicWhereUniqueInput | LectureTopicWhereUniqueInput[];
    update?:
      | LectureTopicUpdateWithWhereUniqueWithoutTopicInput
      | LectureTopicUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | LectureTopicUpdateManyWithWhereWithoutTopicInput
      | LectureTopicUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: LectureTopicScalarWhereInput | LectureTopicScalarWhereInput[];
  };

  export type SeriesTopicUncheckedUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<SeriesTopicCreateWithoutTopicInput, SeriesTopicUncheckedCreateWithoutTopicInput>
      | SeriesTopicCreateWithoutTopicInput[]
      | SeriesTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | SeriesTopicCreateOrConnectWithoutTopicInput
      | SeriesTopicCreateOrConnectWithoutTopicInput[];
    upsert?:
      | SeriesTopicUpsertWithWhereUniqueWithoutTopicInput
      | SeriesTopicUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: SeriesTopicCreateManyTopicInputEnvelope;
    set?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    disconnect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    delete?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    connect?: SeriesTopicWhereUniqueInput | SeriesTopicWhereUniqueInput[];
    update?:
      | SeriesTopicUpdateWithWhereUniqueWithoutTopicInput
      | SeriesTopicUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | SeriesTopicUpdateManyWithWhereWithoutTopicInput
      | SeriesTopicUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: SeriesTopicScalarWhereInput | SeriesTopicScalarWhereInput[];
  };

  export type CollectionTopicUncheckedUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<CollectionTopicCreateWithoutTopicInput, CollectionTopicUncheckedCreateWithoutTopicInput>
      | CollectionTopicCreateWithoutTopicInput[]
      | CollectionTopicUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | CollectionTopicCreateOrConnectWithoutTopicInput
      | CollectionTopicCreateOrConnectWithoutTopicInput[];
    upsert?:
      | CollectionTopicUpsertWithWhereUniqueWithoutTopicInput
      | CollectionTopicUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: CollectionTopicCreateManyTopicInputEnvelope;
    set?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    disconnect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    delete?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    connect?: CollectionTopicWhereUniqueInput | CollectionTopicWhereUniqueInput[];
    update?:
      | CollectionTopicUpdateWithWhereUniqueWithoutTopicInput
      | CollectionTopicUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | CollectionTopicUpdateManyWithWhereWithoutTopicInput
      | CollectionTopicUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: CollectionTopicScalarWhereInput | CollectionTopicScalarWhereInput[];
  };

  export type LectureCreateNestedOneWithoutTopicsInput = {
    create?: XOR<LectureCreateWithoutTopicsInput, LectureUncheckedCreateWithoutTopicsInput>;
    connectOrCreate?: LectureCreateOrConnectWithoutTopicsInput;
    connect?: LectureWhereUniqueInput;
  };

  export type TopicCreateNestedOneWithoutLectureTopicsInput = {
    create?: XOR<
      TopicCreateWithoutLectureTopicsInput,
      TopicUncheckedCreateWithoutLectureTopicsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutLectureTopicsInput;
    connect?: TopicWhereUniqueInput;
  };

  export type LectureUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<LectureCreateWithoutTopicsInput, LectureUncheckedCreateWithoutTopicsInput>;
    connectOrCreate?: LectureCreateOrConnectWithoutTopicsInput;
    upsert?: LectureUpsertWithoutTopicsInput;
    connect?: LectureWhereUniqueInput;
    update?: XOR<
      XOR<LectureUpdateToOneWithWhereWithoutTopicsInput, LectureUpdateWithoutTopicsInput>,
      LectureUncheckedUpdateWithoutTopicsInput
    >;
  };

  export type TopicUpdateOneRequiredWithoutLectureTopicsNestedInput = {
    create?: XOR<
      TopicCreateWithoutLectureTopicsInput,
      TopicUncheckedCreateWithoutLectureTopicsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutLectureTopicsInput;
    upsert?: TopicUpsertWithoutLectureTopicsInput;
    connect?: TopicWhereUniqueInput;
    update?: XOR<
      XOR<TopicUpdateToOneWithWhereWithoutLectureTopicsInput, TopicUpdateWithoutLectureTopicsInput>,
      TopicUncheckedUpdateWithoutLectureTopicsInput
    >;
  };

  export type SeriesCreateNestedOneWithoutTopicsInput = {
    create?: XOR<SeriesCreateWithoutTopicsInput, SeriesUncheckedCreateWithoutTopicsInput>;
    connectOrCreate?: SeriesCreateOrConnectWithoutTopicsInput;
    connect?: SeriesWhereUniqueInput;
  };

  export type TopicCreateNestedOneWithoutSeriesTopicsInput = {
    create?: XOR<TopicCreateWithoutSeriesTopicsInput, TopicUncheckedCreateWithoutSeriesTopicsInput>;
    connectOrCreate?: TopicCreateOrConnectWithoutSeriesTopicsInput;
    connect?: TopicWhereUniqueInput;
  };

  export type SeriesUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<SeriesCreateWithoutTopicsInput, SeriesUncheckedCreateWithoutTopicsInput>;
    connectOrCreate?: SeriesCreateOrConnectWithoutTopicsInput;
    upsert?: SeriesUpsertWithoutTopicsInput;
    connect?: SeriesWhereUniqueInput;
    update?: XOR<
      XOR<SeriesUpdateToOneWithWhereWithoutTopicsInput, SeriesUpdateWithoutTopicsInput>,
      SeriesUncheckedUpdateWithoutTopicsInput
    >;
  };

  export type TopicUpdateOneRequiredWithoutSeriesTopicsNestedInput = {
    create?: XOR<TopicCreateWithoutSeriesTopicsInput, TopicUncheckedCreateWithoutSeriesTopicsInput>;
    connectOrCreate?: TopicCreateOrConnectWithoutSeriesTopicsInput;
    upsert?: TopicUpsertWithoutSeriesTopicsInput;
    connect?: TopicWhereUniqueInput;
    update?: XOR<
      XOR<TopicUpdateToOneWithWhereWithoutSeriesTopicsInput, TopicUpdateWithoutSeriesTopicsInput>,
      TopicUncheckedUpdateWithoutSeriesTopicsInput
    >;
  };

  export type CollectionCreateNestedOneWithoutTopicsInput = {
    create?: XOR<CollectionCreateWithoutTopicsInput, CollectionUncheckedCreateWithoutTopicsInput>;
    connectOrCreate?: CollectionCreateOrConnectWithoutTopicsInput;
    connect?: CollectionWhereUniqueInput;
  };

  export type TopicCreateNestedOneWithoutCollectionTopicsInput = {
    create?: XOR<
      TopicCreateWithoutCollectionTopicsInput,
      TopicUncheckedCreateWithoutCollectionTopicsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutCollectionTopicsInput;
    connect?: TopicWhereUniqueInput;
  };

  export type CollectionUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<CollectionCreateWithoutTopicsInput, CollectionUncheckedCreateWithoutTopicsInput>;
    connectOrCreate?: CollectionCreateOrConnectWithoutTopicsInput;
    upsert?: CollectionUpsertWithoutTopicsInput;
    connect?: CollectionWhereUniqueInput;
    update?: XOR<
      XOR<CollectionUpdateToOneWithWhereWithoutTopicsInput, CollectionUpdateWithoutTopicsInput>,
      CollectionUncheckedUpdateWithoutTopicsInput
    >;
  };

  export type TopicUpdateOneRequiredWithoutCollectionTopicsNestedInput = {
    create?: XOR<
      TopicCreateWithoutCollectionTopicsInput,
      TopicUncheckedCreateWithoutCollectionTopicsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutCollectionTopicsInput;
    upsert?: TopicUpsertWithoutCollectionTopicsInput;
    connect?: TopicWhereUniqueInput;
    update?: XOR<
      XOR<
        TopicUpdateToOneWithWhereWithoutCollectionTopicsInput,
        TopicUpdateWithoutCollectionTopicsInput
      >,
      TopicUncheckedUpdateWithoutCollectionTopicsInput
    >;
  };

  export type UserCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>;
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput;
    connect?: UserWhereUniqueInput;
  };

  export type LectureCreateNestedOneWithoutProgressInput = {
    create?: XOR<LectureCreateWithoutProgressInput, LectureUncheckedCreateWithoutProgressInput>;
    connectOrCreate?: LectureCreateOrConnectWithoutProgressInput;
    connect?: LectureWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>;
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput;
    upsert?: UserUpsertWithoutProgressInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutProgressInput, UserUpdateWithoutProgressInput>,
      UserUncheckedUpdateWithoutProgressInput
    >;
  };

  export type LectureUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<LectureCreateWithoutProgressInput, LectureUncheckedCreateWithoutProgressInput>;
    connectOrCreate?: LectureCreateOrConnectWithoutProgressInput;
    upsert?: LectureUpsertWithoutProgressInput;
    connect?: LectureWhereUniqueInput;
    update?: XOR<
      XOR<LectureUpdateToOneWithWhereWithoutProgressInput, LectureUpdateWithoutProgressInput>,
      LectureUncheckedUpdateWithoutProgressInput
    >;
  };

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput;
    connect?: UserWhereUniqueInput;
  };

  export type LectureCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<LectureCreateWithoutFavoritesInput, LectureUncheckedCreateWithoutFavoritesInput>;
    connectOrCreate?: LectureCreateOrConnectWithoutFavoritesInput;
    connect?: LectureWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput;
    upsert?: UserUpsertWithoutFavoritesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>,
      UserUncheckedUpdateWithoutFavoritesInput
    >;
  };

  export type LectureUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<LectureCreateWithoutFavoritesInput, LectureUncheckedCreateWithoutFavoritesInput>;
    connectOrCreate?: LectureCreateOrConnectWithoutFavoritesInput;
    upsert?: LectureUpsertWithoutFavoritesInput;
    connect?: LectureWhereUniqueInput;
    update?: XOR<
      XOR<LectureUpdateToOneWithWhereWithoutFavoritesInput, LectureUpdateWithoutFavoritesInput>,
      LectureUncheckedUpdateWithoutFavoritesInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumGlobalRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GlobalRole | EnumGlobalRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumGlobalRoleFilter<$PrismaModel> | $Enums.GlobalRole;
  };

  export type NestedEnumGlobalRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GlobalRole | EnumGlobalRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GlobalRole[] | ListEnumGlobalRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumGlobalRoleWithAggregatesFilter<$PrismaModel> | $Enums.GlobalRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGlobalRoleFilter<$PrismaModel>;
    _max?: NestedEnumGlobalRoleFilter<$PrismaModel>;
  };

  export type NestedEnumScholarRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ScholarRole | EnumScholarRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumScholarRoleFilter<$PrismaModel> | $Enums.ScholarRole;
  };

  export type NestedEnumScholarRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScholarRole | EnumScholarRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ScholarRole[] | ListEnumScholarRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumScholarRoleWithAggregatesFilter<$PrismaModel> | $Enums.ScholarRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumScholarRoleFilter<$PrismaModel>;
    _max?: NestedEnumScholarRoleFilter<$PrismaModel>;
  };

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status;
  };

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStatusFilter<$PrismaModel>;
    _max?: NestedEnumStatusFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null;
  };

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedBigIntNullableFilter<$PrismaModel>;
    _min?: NestedBigIntNullableFilter<$PrismaModel>;
    _max?: NestedBigIntNullableFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type ScholarCreateWithoutIngestionBatchInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    collections?: CollectionCreateNestedManyWithoutScholarInput;
    series?: SeriesCreateNestedManyWithoutScholarInput;
    lectures?: LectureCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUncheckedCreateWithoutIngestionBatchInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    collections?: CollectionUncheckedCreateNestedManyWithoutScholarInput;
    series?: SeriesUncheckedCreateNestedManyWithoutScholarInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutScholarInput;
  };

  export type ScholarCreateOrConnectWithoutIngestionBatchInput = {
    where: ScholarWhereUniqueInput;
    create: XOR<
      ScholarCreateWithoutIngestionBatchInput,
      ScholarUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type ScholarCreateManyIngestionBatchInputEnvelope = {
    data: ScholarCreateManyIngestionBatchInput | ScholarCreateManyIngestionBatchInput[];
    skipDuplicates?: boolean;
  };

  export type CollectionCreateWithoutIngestionBatchInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    scholar: ScholarCreateNestedOneWithoutCollectionsInput;
    series?: SeriesCreateNestedManyWithoutCollectionInput;
    topics?: CollectionTopicCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionUncheckedCreateWithoutIngestionBatchInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput;
    topics?: CollectionTopicUncheckedCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionCreateOrConnectWithoutIngestionBatchInput = {
    where: CollectionWhereUniqueInput;
    create: XOR<
      CollectionCreateWithoutIngestionBatchInput,
      CollectionUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type CollectionCreateManyIngestionBatchInputEnvelope = {
    data: CollectionCreateManyIngestionBatchInput | CollectionCreateManyIngestionBatchInput[];
    skipDuplicates?: boolean;
  };

  export type SeriesCreateWithoutIngestionBatchInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    scholar: ScholarCreateNestedOneWithoutSeriesInput;
    collection?: CollectionCreateNestedOneWithoutSeriesInput;
    lectures?: LectureCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUncheckedCreateWithoutIngestionBatchInput = {
    id?: string;
    scholarId: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    lectures?: LectureUncheckedCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicUncheckedCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesCreateOrConnectWithoutIngestionBatchInput = {
    where: SeriesWhereUniqueInput;
    create: XOR<
      SeriesCreateWithoutIngestionBatchInput,
      SeriesUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type SeriesCreateManyIngestionBatchInputEnvelope = {
    data: SeriesCreateManyIngestionBatchInput | SeriesCreateManyIngestionBatchInput[];
    skipDuplicates?: boolean;
  };

  export type LectureCreateWithoutIngestionBatchInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutIngestionBatchInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutIngestionBatchInput = {
    where: LectureWhereUniqueInput;
    create: XOR<
      LectureCreateWithoutIngestionBatchInput,
      LectureUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type LectureCreateManyIngestionBatchInputEnvelope = {
    data: LectureCreateManyIngestionBatchInput | LectureCreateManyIngestionBatchInput[];
    skipDuplicates?: boolean;
  };

  export type AudioAssetCreateWithoutIngestionBatchInput = {
    id?: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    lecture: LectureCreateNestedOneWithoutAudioAssetsInput;
  };

  export type AudioAssetUncheckedCreateWithoutIngestionBatchInput = {
    id?: string;
    lectureId: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
  };

  export type AudioAssetCreateOrConnectWithoutIngestionBatchInput = {
    where: AudioAssetWhereUniqueInput;
    create: XOR<
      AudioAssetCreateWithoutIngestionBatchInput,
      AudioAssetUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type AudioAssetCreateManyIngestionBatchInputEnvelope = {
    data: AudioAssetCreateManyIngestionBatchInput | AudioAssetCreateManyIngestionBatchInput[];
    skipDuplicates?: boolean;
  };

  export type ScholarUpsertWithWhereUniqueWithoutIngestionBatchInput = {
    where: ScholarWhereUniqueInput;
    update: XOR<
      ScholarUpdateWithoutIngestionBatchInput,
      ScholarUncheckedUpdateWithoutIngestionBatchInput
    >;
    create: XOR<
      ScholarCreateWithoutIngestionBatchInput,
      ScholarUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type ScholarUpdateWithWhereUniqueWithoutIngestionBatchInput = {
    where: ScholarWhereUniqueInput;
    data: XOR<
      ScholarUpdateWithoutIngestionBatchInput,
      ScholarUncheckedUpdateWithoutIngestionBatchInput
    >;
  };

  export type ScholarUpdateManyWithWhereWithoutIngestionBatchInput = {
    where: ScholarScalarWhereInput;
    data: XOR<ScholarUpdateManyMutationInput, ScholarUncheckedUpdateManyWithoutIngestionBatchInput>;
  };

  export type ScholarScalarWhereInput = {
    AND?: ScholarScalarWhereInput | ScholarScalarWhereInput[];
    OR?: ScholarScalarWhereInput[];
    NOT?: ScholarScalarWhereInput | ScholarScalarWhereInput[];
    id?: StringFilter<"Scholar"> | string;
    slug?: StringFilter<"Scholar"> | string;
    name?: StringFilter<"Scholar"> | string;
    bio?: StringNullableFilter<"Scholar"> | string | null;
    country?: StringNullableFilter<"Scholar"> | string | null;
    mainLanguage?: StringNullableFilter<"Scholar"> | string | null;
    imageUrl?: StringNullableFilter<"Scholar"> | string | null;
    isActive?: BoolFilter<"Scholar"> | boolean;
    createdAt?: DateTimeFilter<"Scholar"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Scholar"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Scholar"> | string | null;
  };

  export type CollectionUpsertWithWhereUniqueWithoutIngestionBatchInput = {
    where: CollectionWhereUniqueInput;
    update: XOR<
      CollectionUpdateWithoutIngestionBatchInput,
      CollectionUncheckedUpdateWithoutIngestionBatchInput
    >;
    create: XOR<
      CollectionCreateWithoutIngestionBatchInput,
      CollectionUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type CollectionUpdateWithWhereUniqueWithoutIngestionBatchInput = {
    where: CollectionWhereUniqueInput;
    data: XOR<
      CollectionUpdateWithoutIngestionBatchInput,
      CollectionUncheckedUpdateWithoutIngestionBatchInput
    >;
  };

  export type CollectionUpdateManyWithWhereWithoutIngestionBatchInput = {
    where: CollectionScalarWhereInput;
    data: XOR<
      CollectionUpdateManyMutationInput,
      CollectionUncheckedUpdateManyWithoutIngestionBatchInput
    >;
  };

  export type CollectionScalarWhereInput = {
    AND?: CollectionScalarWhereInput | CollectionScalarWhereInput[];
    OR?: CollectionScalarWhereInput[];
    NOT?: CollectionScalarWhereInput | CollectionScalarWhereInput[];
    id?: StringFilter<"Collection"> | string;
    scholarId?: StringFilter<"Collection"> | string;
    slug?: StringFilter<"Collection"> | string;
    title?: StringFilter<"Collection"> | string;
    description?: StringNullableFilter<"Collection"> | string | null;
    coverImageUrl?: StringNullableFilter<"Collection"> | string | null;
    language?: StringNullableFilter<"Collection"> | string | null;
    status?: EnumStatusFilter<"Collection"> | $Enums.Status;
    orderIndex?: IntNullableFilter<"Collection"> | number | null;
    createdAt?: DateTimeFilter<"Collection"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
    deletedAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableFilter<"Collection"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Collection"> | string | null;
  };

  export type SeriesUpsertWithWhereUniqueWithoutIngestionBatchInput = {
    where: SeriesWhereUniqueInput;
    update: XOR<
      SeriesUpdateWithoutIngestionBatchInput,
      SeriesUncheckedUpdateWithoutIngestionBatchInput
    >;
    create: XOR<
      SeriesCreateWithoutIngestionBatchInput,
      SeriesUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type SeriesUpdateWithWhereUniqueWithoutIngestionBatchInput = {
    where: SeriesWhereUniqueInput;
    data: XOR<
      SeriesUpdateWithoutIngestionBatchInput,
      SeriesUncheckedUpdateWithoutIngestionBatchInput
    >;
  };

  export type SeriesUpdateManyWithWhereWithoutIngestionBatchInput = {
    where: SeriesScalarWhereInput;
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutIngestionBatchInput>;
  };

  export type SeriesScalarWhereInput = {
    AND?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
    OR?: SeriesScalarWhereInput[];
    NOT?: SeriesScalarWhereInput | SeriesScalarWhereInput[];
    id?: StringFilter<"Series"> | string;
    scholarId?: StringFilter<"Series"> | string;
    collectionId?: StringNullableFilter<"Series"> | string | null;
    slug?: StringFilter<"Series"> | string;
    title?: StringFilter<"Series"> | string;
    description?: StringNullableFilter<"Series"> | string | null;
    coverImageUrl?: StringNullableFilter<"Series"> | string | null;
    language?: StringNullableFilter<"Series"> | string | null;
    status?: EnumStatusFilter<"Series"> | $Enums.Status;
    orderIndex?: IntNullableFilter<"Series"> | number | null;
    createdAt?: DateTimeFilter<"Series"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
    deletedAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableFilter<"Series"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Series"> | string | null;
  };

  export type LectureUpsertWithWhereUniqueWithoutIngestionBatchInput = {
    where: LectureWhereUniqueInput;
    update: XOR<
      LectureUpdateWithoutIngestionBatchInput,
      LectureUncheckedUpdateWithoutIngestionBatchInput
    >;
    create: XOR<
      LectureCreateWithoutIngestionBatchInput,
      LectureUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type LectureUpdateWithWhereUniqueWithoutIngestionBatchInput = {
    where: LectureWhereUniqueInput;
    data: XOR<
      LectureUpdateWithoutIngestionBatchInput,
      LectureUncheckedUpdateWithoutIngestionBatchInput
    >;
  };

  export type LectureUpdateManyWithWhereWithoutIngestionBatchInput = {
    where: LectureScalarWhereInput;
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutIngestionBatchInput>;
  };

  export type LectureScalarWhereInput = {
    AND?: LectureScalarWhereInput | LectureScalarWhereInput[];
    OR?: LectureScalarWhereInput[];
    NOT?: LectureScalarWhereInput | LectureScalarWhereInput[];
    id?: StringFilter<"Lecture"> | string;
    scholarId?: StringFilter<"Lecture"> | string;
    seriesId?: StringNullableFilter<"Lecture"> | string | null;
    slug?: StringFilter<"Lecture"> | string;
    title?: StringFilter<"Lecture"> | string;
    description?: StringNullableFilter<"Lecture"> | string | null;
    language?: StringNullableFilter<"Lecture"> | string | null;
    status?: EnumStatusFilter<"Lecture"> | $Enums.Status;
    publishedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    orderIndex?: IntNullableFilter<"Lecture"> | number | null;
    durationSeconds?: IntNullableFilter<"Lecture"> | number | null;
    createdAt?: DateTimeFilter<"Lecture"> | Date | string;
    updatedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    deletedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    deleteAfterAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null;
    ingestionBatchId?: StringNullableFilter<"Lecture"> | string | null;
  };

  export type AudioAssetUpsertWithWhereUniqueWithoutIngestionBatchInput = {
    where: AudioAssetWhereUniqueInput;
    update: XOR<
      AudioAssetUpdateWithoutIngestionBatchInput,
      AudioAssetUncheckedUpdateWithoutIngestionBatchInput
    >;
    create: XOR<
      AudioAssetCreateWithoutIngestionBatchInput,
      AudioAssetUncheckedCreateWithoutIngestionBatchInput
    >;
  };

  export type AudioAssetUpdateWithWhereUniqueWithoutIngestionBatchInput = {
    where: AudioAssetWhereUniqueInput;
    data: XOR<
      AudioAssetUpdateWithoutIngestionBatchInput,
      AudioAssetUncheckedUpdateWithoutIngestionBatchInput
    >;
  };

  export type AudioAssetUpdateManyWithWhereWithoutIngestionBatchInput = {
    where: AudioAssetScalarWhereInput;
    data: XOR<
      AudioAssetUpdateManyMutationInput,
      AudioAssetUncheckedUpdateManyWithoutIngestionBatchInput
    >;
  };

  export type AudioAssetScalarWhereInput = {
    AND?: AudioAssetScalarWhereInput | AudioAssetScalarWhereInput[];
    OR?: AudioAssetScalarWhereInput[];
    NOT?: AudioAssetScalarWhereInput | AudioAssetScalarWhereInput[];
    id?: StringFilter<"AudioAsset"> | string;
    lectureId?: StringFilter<"AudioAsset"> | string;
    url?: StringFilter<"AudioAsset"> | string;
    format?: StringNullableFilter<"AudioAsset"> | string | null;
    bitrateKbps?: IntNullableFilter<"AudioAsset"> | number | null;
    sizeBytes?: BigIntNullableFilter<"AudioAsset"> | bigint | number | null;
    durationSeconds?: IntNullableFilter<"AudioAsset"> | number | null;
    source?: StringNullableFilter<"AudioAsset"> | string | null;
    isPrimary?: BoolFilter<"AudioAsset"> | boolean;
    createdAt?: DateTimeFilter<"AudioAsset"> | Date | string;
    ingestionBatchId?: StringNullableFilter<"AudioAsset"> | string | null;
  };

  export type UserGlobalRoleCreateWithoutUserInput = {
    role: $Enums.GlobalRole;
    createdAt?: Date | string;
  };

  export type UserGlobalRoleUncheckedCreateWithoutUserInput = {
    role: $Enums.GlobalRole;
    createdAt?: Date | string;
  };

  export type UserGlobalRoleCreateOrConnectWithoutUserInput = {
    where: UserGlobalRoleWhereUniqueInput;
    create: XOR<
      UserGlobalRoleCreateWithoutUserInput,
      UserGlobalRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type UserGlobalRoleCreateManyUserInputEnvelope = {
    data: UserGlobalRoleCreateManyUserInput | UserGlobalRoleCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserScholarRoleCreateWithoutUserInput = {
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    scholar: ScholarCreateNestedOneWithoutUserRolesInput;
    createdByUser?: UserCreateNestedOneWithoutCreatedScholarRolesInput;
  };

  export type UserScholarRoleUncheckedCreateWithoutUserInput = {
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    createdByUserId?: string | null;
  };

  export type UserScholarRoleCreateOrConnectWithoutUserInput = {
    where: UserScholarRoleWhereUniqueInput;
    create: XOR<
      UserScholarRoleCreateWithoutUserInput,
      UserScholarRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type UserScholarRoleCreateManyUserInputEnvelope = {
    data: UserScholarRoleCreateManyUserInput | UserScholarRoleCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserScholarRoleCreateWithoutCreatedByUserInput = {
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutScholarRolesInput;
    scholar: ScholarCreateNestedOneWithoutUserRolesInput;
  };

  export type UserScholarRoleUncheckedCreateWithoutCreatedByUserInput = {
    userId: string;
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
  };

  export type UserScholarRoleCreateOrConnectWithoutCreatedByUserInput = {
    where: UserScholarRoleWhereUniqueInput;
    create: XOR<
      UserScholarRoleCreateWithoutCreatedByUserInput,
      UserScholarRoleUncheckedCreateWithoutCreatedByUserInput
    >;
  };

  export type UserScholarRoleCreateManyCreatedByUserInputEnvelope = {
    data:
      | UserScholarRoleCreateManyCreatedByUserInput
      | UserScholarRoleCreateManyCreatedByUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserLectureProgressCreateWithoutUserInput = {
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
    lecture: LectureCreateNestedOneWithoutProgressInput;
  };

  export type UserLectureProgressUncheckedCreateWithoutUserInput = {
    lectureId: string;
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
  };

  export type UserLectureProgressCreateOrConnectWithoutUserInput = {
    where: UserLectureProgressWhereUniqueInput;
    create: XOR<
      UserLectureProgressCreateWithoutUserInput,
      UserLectureProgressUncheckedCreateWithoutUserInput
    >;
  };

  export type UserLectureProgressCreateManyUserInputEnvelope = {
    data: UserLectureProgressCreateManyUserInput | UserLectureProgressCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type FavoriteLectureCreateWithoutUserInput = {
    createdAt?: Date | string;
    lecture: LectureCreateNestedOneWithoutFavoritesInput;
  };

  export type FavoriteLectureUncheckedCreateWithoutUserInput = {
    lectureId: string;
    createdAt?: Date | string;
  };

  export type FavoriteLectureCreateOrConnectWithoutUserInput = {
    where: FavoriteLectureWhereUniqueInput;
    create: XOR<
      FavoriteLectureCreateWithoutUserInput,
      FavoriteLectureUncheckedCreateWithoutUserInput
    >;
  };

  export type FavoriteLectureCreateManyUserInputEnvelope = {
    data: FavoriteLectureCreateManyUserInput | FavoriteLectureCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserGlobalRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGlobalRoleWhereUniqueInput;
    update: XOR<
      UserGlobalRoleUpdateWithoutUserInput,
      UserGlobalRoleUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserGlobalRoleCreateWithoutUserInput,
      UserGlobalRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type UserGlobalRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGlobalRoleWhereUniqueInput;
    data: XOR<UserGlobalRoleUpdateWithoutUserInput, UserGlobalRoleUncheckedUpdateWithoutUserInput>;
  };

  export type UserGlobalRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserGlobalRoleScalarWhereInput;
    data: XOR<
      UserGlobalRoleUpdateManyMutationInput,
      UserGlobalRoleUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserGlobalRoleScalarWhereInput = {
    AND?: UserGlobalRoleScalarWhereInput | UserGlobalRoleScalarWhereInput[];
    OR?: UserGlobalRoleScalarWhereInput[];
    NOT?: UserGlobalRoleScalarWhereInput | UserGlobalRoleScalarWhereInput[];
    userId?: StringFilter<"UserGlobalRole"> | string;
    role?: EnumGlobalRoleFilter<"UserGlobalRole"> | $Enums.GlobalRole;
    createdAt?: DateTimeFilter<"UserGlobalRole"> | Date | string;
  };

  export type UserScholarRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserScholarRoleWhereUniqueInput;
    update: XOR<
      UserScholarRoleUpdateWithoutUserInput,
      UserScholarRoleUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserScholarRoleCreateWithoutUserInput,
      UserScholarRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type UserScholarRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserScholarRoleWhereUniqueInput;
    data: XOR<
      UserScholarRoleUpdateWithoutUserInput,
      UserScholarRoleUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserScholarRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserScholarRoleScalarWhereInput;
    data: XOR<
      UserScholarRoleUpdateManyMutationInput,
      UserScholarRoleUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserScholarRoleScalarWhereInput = {
    AND?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
    OR?: UserScholarRoleScalarWhereInput[];
    NOT?: UserScholarRoleScalarWhereInput | UserScholarRoleScalarWhereInput[];
    userId?: StringFilter<"UserScholarRole"> | string;
    scholarId?: StringFilter<"UserScholarRole"> | string;
    role?: EnumScholarRoleFilter<"UserScholarRole"> | $Enums.ScholarRole;
    createdAt?: DateTimeFilter<"UserScholarRole"> | Date | string;
    createdByUserId?: StringNullableFilter<"UserScholarRole"> | string | null;
  };

  export type UserScholarRoleUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: UserScholarRoleWhereUniqueInput;
    update: XOR<
      UserScholarRoleUpdateWithoutCreatedByUserInput,
      UserScholarRoleUncheckedUpdateWithoutCreatedByUserInput
    >;
    create: XOR<
      UserScholarRoleCreateWithoutCreatedByUserInput,
      UserScholarRoleUncheckedCreateWithoutCreatedByUserInput
    >;
  };

  export type UserScholarRoleUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: UserScholarRoleWhereUniqueInput;
    data: XOR<
      UserScholarRoleUpdateWithoutCreatedByUserInput,
      UserScholarRoleUncheckedUpdateWithoutCreatedByUserInput
    >;
  };

  export type UserScholarRoleUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: UserScholarRoleScalarWhereInput;
    data: XOR<
      UserScholarRoleUpdateManyMutationInput,
      UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserInput
    >;
  };

  export type UserLectureProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLectureProgressWhereUniqueInput;
    update: XOR<
      UserLectureProgressUpdateWithoutUserInput,
      UserLectureProgressUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserLectureProgressCreateWithoutUserInput,
      UserLectureProgressUncheckedCreateWithoutUserInput
    >;
  };

  export type UserLectureProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLectureProgressWhereUniqueInput;
    data: XOR<
      UserLectureProgressUpdateWithoutUserInput,
      UserLectureProgressUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserLectureProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserLectureProgressScalarWhereInput;
    data: XOR<
      UserLectureProgressUpdateManyMutationInput,
      UserLectureProgressUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserLectureProgressScalarWhereInput = {
    AND?: UserLectureProgressScalarWhereInput | UserLectureProgressScalarWhereInput[];
    OR?: UserLectureProgressScalarWhereInput[];
    NOT?: UserLectureProgressScalarWhereInput | UserLectureProgressScalarWhereInput[];
    userId?: StringFilter<"UserLectureProgress"> | string;
    lectureId?: StringFilter<"UserLectureProgress"> | string;
    positionSeconds?: IntFilter<"UserLectureProgress"> | number;
    isCompleted?: BoolFilter<"UserLectureProgress"> | boolean;
    updatedAt?: DateTimeFilter<"UserLectureProgress"> | Date | string;
  };

  export type FavoriteLectureUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteLectureWhereUniqueInput;
    update: XOR<
      FavoriteLectureUpdateWithoutUserInput,
      FavoriteLectureUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      FavoriteLectureCreateWithoutUserInput,
      FavoriteLectureUncheckedCreateWithoutUserInput
    >;
  };

  export type FavoriteLectureUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteLectureWhereUniqueInput;
    data: XOR<
      FavoriteLectureUpdateWithoutUserInput,
      FavoriteLectureUncheckedUpdateWithoutUserInput
    >;
  };

  export type FavoriteLectureUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteLectureScalarWhereInput;
    data: XOR<
      FavoriteLectureUpdateManyMutationInput,
      FavoriteLectureUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type FavoriteLectureScalarWhereInput = {
    AND?: FavoriteLectureScalarWhereInput | FavoriteLectureScalarWhereInput[];
    OR?: FavoriteLectureScalarWhereInput[];
    NOT?: FavoriteLectureScalarWhereInput | FavoriteLectureScalarWhereInput[];
    userId?: StringFilter<"FavoriteLecture"> | string;
    lectureId?: StringFilter<"FavoriteLecture"> | string;
    createdAt?: DateTimeFilter<"FavoriteLecture"> | Date | string;
  };

  export type UserCreateWithoutGlobalRolesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    scholarRoles?: UserScholarRoleCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutGlobalRolesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    scholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutGlobalRolesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutGlobalRolesInput, UserUncheckedCreateWithoutGlobalRolesInput>;
  };

  export type UserUpsertWithoutGlobalRolesInput = {
    update: XOR<UserUpdateWithoutGlobalRolesInput, UserUncheckedUpdateWithoutGlobalRolesInput>;
    create: XOR<UserCreateWithoutGlobalRolesInput, UserUncheckedCreateWithoutGlobalRolesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutGlobalRolesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutGlobalRolesInput, UserUncheckedUpdateWithoutGlobalRolesInput>;
  };

  export type UserUpdateWithoutGlobalRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    scholarRoles?: UserScholarRoleUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutGlobalRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    scholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutScholarRolesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutScholarRolesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleUncheckedCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutScholarRolesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutScholarRolesInput, UserUncheckedCreateWithoutScholarRolesInput>;
  };

  export type ScholarCreateWithoutUserRolesInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutScholarsInput;
    collections?: CollectionCreateNestedManyWithoutScholarInput;
    series?: SeriesCreateNestedManyWithoutScholarInput;
    lectures?: LectureCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUncheckedCreateWithoutUserRolesInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatchId?: string | null;
    collections?: CollectionUncheckedCreateNestedManyWithoutScholarInput;
    series?: SeriesUncheckedCreateNestedManyWithoutScholarInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutScholarInput;
  };

  export type ScholarCreateOrConnectWithoutUserRolesInput = {
    where: ScholarWhereUniqueInput;
    create: XOR<ScholarCreateWithoutUserRolesInput, ScholarUncheckedCreateWithoutUserRolesInput>;
  };

  export type UserCreateWithoutCreatedScholarRolesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleCreateNestedManyWithoutUserInput;
    progress?: UserLectureProgressCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCreatedScholarRolesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleUncheckedCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutUserInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutUserInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCreatedScholarRolesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCreatedScholarRolesInput,
      UserUncheckedCreateWithoutCreatedScholarRolesInput
    >;
  };

  export type UserUpsertWithoutScholarRolesInput = {
    update: XOR<UserUpdateWithoutScholarRolesInput, UserUncheckedUpdateWithoutScholarRolesInput>;
    create: XOR<UserCreateWithoutScholarRolesInput, UserUncheckedCreateWithoutScholarRolesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutScholarRolesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutScholarRolesInput, UserUncheckedUpdateWithoutScholarRolesInput>;
  };

  export type UserUpdateWithoutScholarRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutScholarRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUncheckedUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ScholarUpsertWithoutUserRolesInput = {
    update: XOR<ScholarUpdateWithoutUserRolesInput, ScholarUncheckedUpdateWithoutUserRolesInput>;
    create: XOR<ScholarCreateWithoutUserRolesInput, ScholarUncheckedCreateWithoutUserRolesInput>;
    where?: ScholarWhereInput;
  };

  export type ScholarUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: ScholarWhereInput;
    data: XOR<ScholarUpdateWithoutUserRolesInput, ScholarUncheckedUpdateWithoutUserRolesInput>;
  };

  export type ScholarUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutScholarsNestedInput;
    collections?: CollectionUpdateManyWithoutScholarNestedInput;
    series?: SeriesUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    collections?: CollectionUncheckedUpdateManyWithoutScholarNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutScholarNestedInput;
  };

  export type UserUpsertWithoutCreatedScholarRolesInput = {
    update: XOR<
      UserUpdateWithoutCreatedScholarRolesInput,
      UserUncheckedUpdateWithoutCreatedScholarRolesInput
    >;
    create: XOR<
      UserCreateWithoutCreatedScholarRolesInput,
      UserUncheckedCreateWithoutCreatedScholarRolesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCreatedScholarRolesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCreatedScholarRolesInput,
      UserUncheckedUpdateWithoutCreatedScholarRolesInput
    >;
  };

  export type UserUpdateWithoutCreatedScholarRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUpdateManyWithoutUserNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedScholarRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUncheckedUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutUserNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutUserNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type IngestionBatchCreateWithoutScholarsInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    collections?: CollectionCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUncheckedCreateWithoutScholarsInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    collections?: CollectionUncheckedCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesUncheckedCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchCreateOrConnectWithoutScholarsInput = {
    where: IngestionBatchWhereUniqueInput;
    create: XOR<
      IngestionBatchCreateWithoutScholarsInput,
      IngestionBatchUncheckedCreateWithoutScholarsInput
    >;
  };

  export type CollectionCreateWithoutScholarInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutCollectionsInput;
    series?: SeriesCreateNestedManyWithoutCollectionInput;
    topics?: CollectionTopicCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionUncheckedCreateWithoutScholarInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput;
    topics?: CollectionTopicUncheckedCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionCreateOrConnectWithoutScholarInput = {
    where: CollectionWhereUniqueInput;
    create: XOR<CollectionCreateWithoutScholarInput, CollectionUncheckedCreateWithoutScholarInput>;
  };

  export type CollectionCreateManyScholarInputEnvelope = {
    data: CollectionCreateManyScholarInput | CollectionCreateManyScholarInput[];
    skipDuplicates?: boolean;
  };

  export type SeriesCreateWithoutScholarInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutSeriesInput;
    collection?: CollectionCreateNestedOneWithoutSeriesInput;
    lectures?: LectureCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUncheckedCreateWithoutScholarInput = {
    id?: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    lectures?: LectureUncheckedCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicUncheckedCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesCreateOrConnectWithoutScholarInput = {
    where: SeriesWhereUniqueInput;
    create: XOR<SeriesCreateWithoutScholarInput, SeriesUncheckedCreateWithoutScholarInput>;
  };

  export type SeriesCreateManyScholarInputEnvelope = {
    data: SeriesCreateManyScholarInput | SeriesCreateManyScholarInput[];
    skipDuplicates?: boolean;
  };

  export type LectureCreateWithoutScholarInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutScholarInput = {
    id?: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutScholarInput = {
    where: LectureWhereUniqueInput;
    create: XOR<LectureCreateWithoutScholarInput, LectureUncheckedCreateWithoutScholarInput>;
  };

  export type LectureCreateManyScholarInputEnvelope = {
    data: LectureCreateManyScholarInput | LectureCreateManyScholarInput[];
    skipDuplicates?: boolean;
  };

  export type UserScholarRoleCreateWithoutScholarInput = {
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutScholarRolesInput;
    createdByUser?: UserCreateNestedOneWithoutCreatedScholarRolesInput;
  };

  export type UserScholarRoleUncheckedCreateWithoutScholarInput = {
    userId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    createdByUserId?: string | null;
  };

  export type UserScholarRoleCreateOrConnectWithoutScholarInput = {
    where: UserScholarRoleWhereUniqueInput;
    create: XOR<
      UserScholarRoleCreateWithoutScholarInput,
      UserScholarRoleUncheckedCreateWithoutScholarInput
    >;
  };

  export type UserScholarRoleCreateManyScholarInputEnvelope = {
    data: UserScholarRoleCreateManyScholarInput | UserScholarRoleCreateManyScholarInput[];
    skipDuplicates?: boolean;
  };

  export type IngestionBatchUpsertWithoutScholarsInput = {
    update: XOR<
      IngestionBatchUpdateWithoutScholarsInput,
      IngestionBatchUncheckedUpdateWithoutScholarsInput
    >;
    create: XOR<
      IngestionBatchCreateWithoutScholarsInput,
      IngestionBatchUncheckedCreateWithoutScholarsInput
    >;
    where?: IngestionBatchWhereInput;
  };

  export type IngestionBatchUpdateToOneWithWhereWithoutScholarsInput = {
    where?: IngestionBatchWhereInput;
    data: XOR<
      IngestionBatchUpdateWithoutScholarsInput,
      IngestionBatchUncheckedUpdateWithoutScholarsInput
    >;
  };

  export type IngestionBatchUpdateWithoutScholarsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    collections?: CollectionUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchUncheckedUpdateWithoutScholarsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    collections?: CollectionUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type CollectionUpsertWithWhereUniqueWithoutScholarInput = {
    where: CollectionWhereUniqueInput;
    update: XOR<CollectionUpdateWithoutScholarInput, CollectionUncheckedUpdateWithoutScholarInput>;
    create: XOR<CollectionCreateWithoutScholarInput, CollectionUncheckedCreateWithoutScholarInput>;
  };

  export type CollectionUpdateWithWhereUniqueWithoutScholarInput = {
    where: CollectionWhereUniqueInput;
    data: XOR<CollectionUpdateWithoutScholarInput, CollectionUncheckedUpdateWithoutScholarInput>;
  };

  export type CollectionUpdateManyWithWhereWithoutScholarInput = {
    where: CollectionScalarWhereInput;
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutScholarInput>;
  };

  export type SeriesUpsertWithWhereUniqueWithoutScholarInput = {
    where: SeriesWhereUniqueInput;
    update: XOR<SeriesUpdateWithoutScholarInput, SeriesUncheckedUpdateWithoutScholarInput>;
    create: XOR<SeriesCreateWithoutScholarInput, SeriesUncheckedCreateWithoutScholarInput>;
  };

  export type SeriesUpdateWithWhereUniqueWithoutScholarInput = {
    where: SeriesWhereUniqueInput;
    data: XOR<SeriesUpdateWithoutScholarInput, SeriesUncheckedUpdateWithoutScholarInput>;
  };

  export type SeriesUpdateManyWithWhereWithoutScholarInput = {
    where: SeriesScalarWhereInput;
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutScholarInput>;
  };

  export type LectureUpsertWithWhereUniqueWithoutScholarInput = {
    where: LectureWhereUniqueInput;
    update: XOR<LectureUpdateWithoutScholarInput, LectureUncheckedUpdateWithoutScholarInput>;
    create: XOR<LectureCreateWithoutScholarInput, LectureUncheckedCreateWithoutScholarInput>;
  };

  export type LectureUpdateWithWhereUniqueWithoutScholarInput = {
    where: LectureWhereUniqueInput;
    data: XOR<LectureUpdateWithoutScholarInput, LectureUncheckedUpdateWithoutScholarInput>;
  };

  export type LectureUpdateManyWithWhereWithoutScholarInput = {
    where: LectureScalarWhereInput;
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutScholarInput>;
  };

  export type UserScholarRoleUpsertWithWhereUniqueWithoutScholarInput = {
    where: UserScholarRoleWhereUniqueInput;
    update: XOR<
      UserScholarRoleUpdateWithoutScholarInput,
      UserScholarRoleUncheckedUpdateWithoutScholarInput
    >;
    create: XOR<
      UserScholarRoleCreateWithoutScholarInput,
      UserScholarRoleUncheckedCreateWithoutScholarInput
    >;
  };

  export type UserScholarRoleUpdateWithWhereUniqueWithoutScholarInput = {
    where: UserScholarRoleWhereUniqueInput;
    data: XOR<
      UserScholarRoleUpdateWithoutScholarInput,
      UserScholarRoleUncheckedUpdateWithoutScholarInput
    >;
  };

  export type UserScholarRoleUpdateManyWithWhereWithoutScholarInput = {
    where: UserScholarRoleScalarWhereInput;
    data: XOR<
      UserScholarRoleUpdateManyMutationInput,
      UserScholarRoleUncheckedUpdateManyWithoutScholarInput
    >;
  };

  export type IngestionBatchCreateWithoutCollectionsInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUncheckedCreateWithoutCollectionsInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarUncheckedCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesUncheckedCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchCreateOrConnectWithoutCollectionsInput = {
    where: IngestionBatchWhereUniqueInput;
    create: XOR<
      IngestionBatchCreateWithoutCollectionsInput,
      IngestionBatchUncheckedCreateWithoutCollectionsInput
    >;
  };

  export type ScholarCreateWithoutCollectionsInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutScholarsInput;
    series?: SeriesCreateNestedManyWithoutScholarInput;
    lectures?: LectureCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUncheckedCreateWithoutCollectionsInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatchId?: string | null;
    series?: SeriesUncheckedCreateNestedManyWithoutScholarInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutScholarInput;
  };

  export type ScholarCreateOrConnectWithoutCollectionsInput = {
    where: ScholarWhereUniqueInput;
    create: XOR<
      ScholarCreateWithoutCollectionsInput,
      ScholarUncheckedCreateWithoutCollectionsInput
    >;
  };

  export type SeriesCreateWithoutCollectionInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutSeriesInput;
    scholar: ScholarCreateNestedOneWithoutSeriesInput;
    lectures?: LectureCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUncheckedCreateWithoutCollectionInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    lectures?: LectureUncheckedCreateNestedManyWithoutSeriesInput;
    topics?: SeriesTopicUncheckedCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesCreateOrConnectWithoutCollectionInput = {
    where: SeriesWhereUniqueInput;
    create: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>;
  };

  export type SeriesCreateManyCollectionInputEnvelope = {
    data: SeriesCreateManyCollectionInput | SeriesCreateManyCollectionInput[];
    skipDuplicates?: boolean;
  };

  export type CollectionTopicCreateWithoutCollectionInput = {
    createdAt?: Date | string;
    topic: TopicCreateNestedOneWithoutCollectionTopicsInput;
  };

  export type CollectionTopicUncheckedCreateWithoutCollectionInput = {
    topicId: string;
    createdAt?: Date | string;
  };

  export type CollectionTopicCreateOrConnectWithoutCollectionInput = {
    where: CollectionTopicWhereUniqueInput;
    create: XOR<
      CollectionTopicCreateWithoutCollectionInput,
      CollectionTopicUncheckedCreateWithoutCollectionInput
    >;
  };

  export type CollectionTopicCreateManyCollectionInputEnvelope = {
    data: CollectionTopicCreateManyCollectionInput | CollectionTopicCreateManyCollectionInput[];
    skipDuplicates?: boolean;
  };

  export type IngestionBatchUpsertWithoutCollectionsInput = {
    update: XOR<
      IngestionBatchUpdateWithoutCollectionsInput,
      IngestionBatchUncheckedUpdateWithoutCollectionsInput
    >;
    create: XOR<
      IngestionBatchCreateWithoutCollectionsInput,
      IngestionBatchUncheckedCreateWithoutCollectionsInput
    >;
    where?: IngestionBatchWhereInput;
  };

  export type IngestionBatchUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: IngestionBatchWhereInput;
    data: XOR<
      IngestionBatchUpdateWithoutCollectionsInput,
      IngestionBatchUncheckedUpdateWithoutCollectionsInput
    >;
  };

  export type IngestionBatchUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type ScholarUpsertWithoutCollectionsInput = {
    update: XOR<
      ScholarUpdateWithoutCollectionsInput,
      ScholarUncheckedUpdateWithoutCollectionsInput
    >;
    create: XOR<
      ScholarCreateWithoutCollectionsInput,
      ScholarUncheckedCreateWithoutCollectionsInput
    >;
    where?: ScholarWhereInput;
  };

  export type ScholarUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: ScholarWhereInput;
    data: XOR<ScholarUpdateWithoutCollectionsInput, ScholarUncheckedUpdateWithoutCollectionsInput>;
  };

  export type ScholarUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutScholarsNestedInput;
    series?: SeriesUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    series?: SeriesUncheckedUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUncheckedUpdateManyWithoutScholarNestedInput;
  };

  export type SeriesUpsertWithWhereUniqueWithoutCollectionInput = {
    where: SeriesWhereUniqueInput;
    update: XOR<SeriesUpdateWithoutCollectionInput, SeriesUncheckedUpdateWithoutCollectionInput>;
    create: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>;
  };

  export type SeriesUpdateWithWhereUniqueWithoutCollectionInput = {
    where: SeriesWhereUniqueInput;
    data: XOR<SeriesUpdateWithoutCollectionInput, SeriesUncheckedUpdateWithoutCollectionInput>;
  };

  export type SeriesUpdateManyWithWhereWithoutCollectionInput = {
    where: SeriesScalarWhereInput;
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutCollectionInput>;
  };

  export type CollectionTopicUpsertWithWhereUniqueWithoutCollectionInput = {
    where: CollectionTopicWhereUniqueInput;
    update: XOR<
      CollectionTopicUpdateWithoutCollectionInput,
      CollectionTopicUncheckedUpdateWithoutCollectionInput
    >;
    create: XOR<
      CollectionTopicCreateWithoutCollectionInput,
      CollectionTopicUncheckedCreateWithoutCollectionInput
    >;
  };

  export type CollectionTopicUpdateWithWhereUniqueWithoutCollectionInput = {
    where: CollectionTopicWhereUniqueInput;
    data: XOR<
      CollectionTopicUpdateWithoutCollectionInput,
      CollectionTopicUncheckedUpdateWithoutCollectionInput
    >;
  };

  export type CollectionTopicUpdateManyWithWhereWithoutCollectionInput = {
    where: CollectionTopicScalarWhereInput;
    data: XOR<
      CollectionTopicUpdateManyMutationInput,
      CollectionTopicUncheckedUpdateManyWithoutCollectionInput
    >;
  };

  export type CollectionTopicScalarWhereInput = {
    AND?: CollectionTopicScalarWhereInput | CollectionTopicScalarWhereInput[];
    OR?: CollectionTopicScalarWhereInput[];
    NOT?: CollectionTopicScalarWhereInput | CollectionTopicScalarWhereInput[];
    collectionId?: StringFilter<"CollectionTopic"> | string;
    topicId?: StringFilter<"CollectionTopic"> | string;
    createdAt?: DateTimeFilter<"CollectionTopic"> | Date | string;
  };

  export type IngestionBatchCreateWithoutSeriesInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUncheckedCreateWithoutSeriesInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarUncheckedCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionUncheckedCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchCreateOrConnectWithoutSeriesInput = {
    where: IngestionBatchWhereUniqueInput;
    create: XOR<
      IngestionBatchCreateWithoutSeriesInput,
      IngestionBatchUncheckedCreateWithoutSeriesInput
    >;
  };

  export type ScholarCreateWithoutSeriesInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutScholarsInput;
    collections?: CollectionCreateNestedManyWithoutScholarInput;
    lectures?: LectureCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUncheckedCreateWithoutSeriesInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatchId?: string | null;
    collections?: CollectionUncheckedCreateNestedManyWithoutScholarInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutScholarInput;
  };

  export type ScholarCreateOrConnectWithoutSeriesInput = {
    where: ScholarWhereUniqueInput;
    create: XOR<ScholarCreateWithoutSeriesInput, ScholarUncheckedCreateWithoutSeriesInput>;
  };

  export type CollectionCreateWithoutSeriesInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutCollectionsInput;
    scholar: ScholarCreateNestedOneWithoutCollectionsInput;
    topics?: CollectionTopicCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionUncheckedCreateWithoutSeriesInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    topics?: CollectionTopicUncheckedCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionCreateOrConnectWithoutSeriesInput = {
    where: CollectionWhereUniqueInput;
    create: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>;
  };

  export type LectureCreateWithoutSeriesInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutSeriesInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutSeriesInput = {
    where: LectureWhereUniqueInput;
    create: XOR<LectureCreateWithoutSeriesInput, LectureUncheckedCreateWithoutSeriesInput>;
  };

  export type LectureCreateManySeriesInputEnvelope = {
    data: LectureCreateManySeriesInput | LectureCreateManySeriesInput[];
    skipDuplicates?: boolean;
  };

  export type SeriesTopicCreateWithoutSeriesInput = {
    createdAt?: Date | string;
    topic: TopicCreateNestedOneWithoutSeriesTopicsInput;
  };

  export type SeriesTopicUncheckedCreateWithoutSeriesInput = {
    topicId: string;
    createdAt?: Date | string;
  };

  export type SeriesTopicCreateOrConnectWithoutSeriesInput = {
    where: SeriesTopicWhereUniqueInput;
    create: XOR<SeriesTopicCreateWithoutSeriesInput, SeriesTopicUncheckedCreateWithoutSeriesInput>;
  };

  export type SeriesTopicCreateManySeriesInputEnvelope = {
    data: SeriesTopicCreateManySeriesInput | SeriesTopicCreateManySeriesInput[];
    skipDuplicates?: boolean;
  };

  export type IngestionBatchUpsertWithoutSeriesInput = {
    update: XOR<
      IngestionBatchUpdateWithoutSeriesInput,
      IngestionBatchUncheckedUpdateWithoutSeriesInput
    >;
    create: XOR<
      IngestionBatchCreateWithoutSeriesInput,
      IngestionBatchUncheckedCreateWithoutSeriesInput
    >;
    where?: IngestionBatchWhereInput;
  };

  export type IngestionBatchUpdateToOneWithWhereWithoutSeriesInput = {
    where?: IngestionBatchWhereInput;
    data: XOR<
      IngestionBatchUpdateWithoutSeriesInput,
      IngestionBatchUncheckedUpdateWithoutSeriesInput
    >;
  };

  export type IngestionBatchUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type ScholarUpsertWithoutSeriesInput = {
    update: XOR<ScholarUpdateWithoutSeriesInput, ScholarUncheckedUpdateWithoutSeriesInput>;
    create: XOR<ScholarCreateWithoutSeriesInput, ScholarUncheckedCreateWithoutSeriesInput>;
    where?: ScholarWhereInput;
  };

  export type ScholarUpdateToOneWithWhereWithoutSeriesInput = {
    where?: ScholarWhereInput;
    data: XOR<ScholarUpdateWithoutSeriesInput, ScholarUncheckedUpdateWithoutSeriesInput>;
  };

  export type ScholarUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutScholarsNestedInput;
    collections?: CollectionUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    collections?: CollectionUncheckedUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUncheckedUpdateManyWithoutScholarNestedInput;
  };

  export type CollectionUpsertWithoutSeriesInput = {
    update: XOR<CollectionUpdateWithoutSeriesInput, CollectionUncheckedUpdateWithoutSeriesInput>;
    create: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>;
    where?: CollectionWhereInput;
  };

  export type CollectionUpdateToOneWithWhereWithoutSeriesInput = {
    where?: CollectionWhereInput;
    data: XOR<CollectionUpdateWithoutSeriesInput, CollectionUncheckedUpdateWithoutSeriesInput>;
  };

  export type CollectionUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutCollectionsNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutCollectionsNestedInput;
    topics?: CollectionTopicUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    topics?: CollectionTopicUncheckedUpdateManyWithoutCollectionNestedInput;
  };

  export type LectureUpsertWithWhereUniqueWithoutSeriesInput = {
    where: LectureWhereUniqueInput;
    update: XOR<LectureUpdateWithoutSeriesInput, LectureUncheckedUpdateWithoutSeriesInput>;
    create: XOR<LectureCreateWithoutSeriesInput, LectureUncheckedCreateWithoutSeriesInput>;
  };

  export type LectureUpdateWithWhereUniqueWithoutSeriesInput = {
    where: LectureWhereUniqueInput;
    data: XOR<LectureUpdateWithoutSeriesInput, LectureUncheckedUpdateWithoutSeriesInput>;
  };

  export type LectureUpdateManyWithWhereWithoutSeriesInput = {
    where: LectureScalarWhereInput;
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutSeriesInput>;
  };

  export type SeriesTopicUpsertWithWhereUniqueWithoutSeriesInput = {
    where: SeriesTopicWhereUniqueInput;
    update: XOR<SeriesTopicUpdateWithoutSeriesInput, SeriesTopicUncheckedUpdateWithoutSeriesInput>;
    create: XOR<SeriesTopicCreateWithoutSeriesInput, SeriesTopicUncheckedCreateWithoutSeriesInput>;
  };

  export type SeriesTopicUpdateWithWhereUniqueWithoutSeriesInput = {
    where: SeriesTopicWhereUniqueInput;
    data: XOR<SeriesTopicUpdateWithoutSeriesInput, SeriesTopicUncheckedUpdateWithoutSeriesInput>;
  };

  export type SeriesTopicUpdateManyWithWhereWithoutSeriesInput = {
    where: SeriesTopicScalarWhereInput;
    data: XOR<SeriesTopicUpdateManyMutationInput, SeriesTopicUncheckedUpdateManyWithoutSeriesInput>;
  };

  export type SeriesTopicScalarWhereInput = {
    AND?: SeriesTopicScalarWhereInput | SeriesTopicScalarWhereInput[];
    OR?: SeriesTopicScalarWhereInput[];
    NOT?: SeriesTopicScalarWhereInput | SeriesTopicScalarWhereInput[];
    seriesId?: StringFilter<"SeriesTopic"> | string;
    topicId?: StringFilter<"SeriesTopic"> | string;
    createdAt?: DateTimeFilter<"SeriesTopic"> | Date | string;
  };

  export type IngestionBatchCreateWithoutLecturesInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUncheckedCreateWithoutLecturesInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarUncheckedCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionUncheckedCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesUncheckedCreateNestedManyWithoutIngestionBatchInput;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchCreateOrConnectWithoutLecturesInput = {
    where: IngestionBatchWhereUniqueInput;
    create: XOR<
      IngestionBatchCreateWithoutLecturesInput,
      IngestionBatchUncheckedCreateWithoutLecturesInput
    >;
  };

  export type ScholarCreateWithoutLecturesInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutScholarsInput;
    collections?: CollectionCreateNestedManyWithoutScholarInput;
    series?: SeriesCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleCreateNestedManyWithoutScholarInput;
  };

  export type ScholarUncheckedCreateWithoutLecturesInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    ingestionBatchId?: string | null;
    collections?: CollectionUncheckedCreateNestedManyWithoutScholarInput;
    series?: SeriesUncheckedCreateNestedManyWithoutScholarInput;
    userRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutScholarInput;
  };

  export type ScholarCreateOrConnectWithoutLecturesInput = {
    where: ScholarWhereUniqueInput;
    create: XOR<ScholarCreateWithoutLecturesInput, ScholarUncheckedCreateWithoutLecturesInput>;
  };

  export type SeriesCreateWithoutLecturesInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutSeriesInput;
    scholar: ScholarCreateNestedOneWithoutSeriesInput;
    collection?: CollectionCreateNestedOneWithoutSeriesInput;
    topics?: SeriesTopicCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUncheckedCreateWithoutLecturesInput = {
    id?: string;
    scholarId: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    topics?: SeriesTopicUncheckedCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesCreateOrConnectWithoutLecturesInput = {
    where: SeriesWhereUniqueInput;
    create: XOR<SeriesCreateWithoutLecturesInput, SeriesUncheckedCreateWithoutLecturesInput>;
  };

  export type AudioAssetCreateWithoutLectureInput = {
    id?: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutAudioAssetsInput;
  };

  export type AudioAssetUncheckedCreateWithoutLectureInput = {
    id?: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    ingestionBatchId?: string | null;
  };

  export type AudioAssetCreateOrConnectWithoutLectureInput = {
    where: AudioAssetWhereUniqueInput;
    create: XOR<AudioAssetCreateWithoutLectureInput, AudioAssetUncheckedCreateWithoutLectureInput>;
  };

  export type AudioAssetCreateManyLectureInputEnvelope = {
    data: AudioAssetCreateManyLectureInput | AudioAssetCreateManyLectureInput[];
    skipDuplicates?: boolean;
  };

  export type LectureTopicCreateWithoutLectureInput = {
    createdAt?: Date | string;
    topic: TopicCreateNestedOneWithoutLectureTopicsInput;
  };

  export type LectureTopicUncheckedCreateWithoutLectureInput = {
    topicId: string;
    createdAt?: Date | string;
  };

  export type LectureTopicCreateOrConnectWithoutLectureInput = {
    where: LectureTopicWhereUniqueInput;
    create: XOR<
      LectureTopicCreateWithoutLectureInput,
      LectureTopicUncheckedCreateWithoutLectureInput
    >;
  };

  export type LectureTopicCreateManyLectureInputEnvelope = {
    data: LectureTopicCreateManyLectureInput | LectureTopicCreateManyLectureInput[];
    skipDuplicates?: boolean;
  };

  export type UserLectureProgressCreateWithoutLectureInput = {
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutProgressInput;
  };

  export type UserLectureProgressUncheckedCreateWithoutLectureInput = {
    userId: string;
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
  };

  export type UserLectureProgressCreateOrConnectWithoutLectureInput = {
    where: UserLectureProgressWhereUniqueInput;
    create: XOR<
      UserLectureProgressCreateWithoutLectureInput,
      UserLectureProgressUncheckedCreateWithoutLectureInput
    >;
  };

  export type UserLectureProgressCreateManyLectureInputEnvelope = {
    data: UserLectureProgressCreateManyLectureInput | UserLectureProgressCreateManyLectureInput[];
    skipDuplicates?: boolean;
  };

  export type FavoriteLectureCreateWithoutLectureInput = {
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutFavoritesInput;
  };

  export type FavoriteLectureUncheckedCreateWithoutLectureInput = {
    userId: string;
    createdAt?: Date | string;
  };

  export type FavoriteLectureCreateOrConnectWithoutLectureInput = {
    where: FavoriteLectureWhereUniqueInput;
    create: XOR<
      FavoriteLectureCreateWithoutLectureInput,
      FavoriteLectureUncheckedCreateWithoutLectureInput
    >;
  };

  export type FavoriteLectureCreateManyLectureInputEnvelope = {
    data: FavoriteLectureCreateManyLectureInput | FavoriteLectureCreateManyLectureInput[];
    skipDuplicates?: boolean;
  };

  export type IngestionBatchUpsertWithoutLecturesInput = {
    update: XOR<
      IngestionBatchUpdateWithoutLecturesInput,
      IngestionBatchUncheckedUpdateWithoutLecturesInput
    >;
    create: XOR<
      IngestionBatchCreateWithoutLecturesInput,
      IngestionBatchUncheckedCreateWithoutLecturesInput
    >;
    where?: IngestionBatchWhereInput;
  };

  export type IngestionBatchUpdateToOneWithWhereWithoutLecturesInput = {
    where?: IngestionBatchWhereInput;
    data: XOR<
      IngestionBatchUpdateWithoutLecturesInput,
      IngestionBatchUncheckedUpdateWithoutLecturesInput
    >;
  };

  export type IngestionBatchUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type ScholarUpsertWithoutLecturesInput = {
    update: XOR<ScholarUpdateWithoutLecturesInput, ScholarUncheckedUpdateWithoutLecturesInput>;
    create: XOR<ScholarCreateWithoutLecturesInput, ScholarUncheckedCreateWithoutLecturesInput>;
    where?: ScholarWhereInput;
  };

  export type ScholarUpdateToOneWithWhereWithoutLecturesInput = {
    where?: ScholarWhereInput;
    data: XOR<ScholarUpdateWithoutLecturesInput, ScholarUncheckedUpdateWithoutLecturesInput>;
  };

  export type ScholarUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutScholarsNestedInput;
    collections?: CollectionUpdateManyWithoutScholarNestedInput;
    series?: SeriesUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    collections?: CollectionUncheckedUpdateManyWithoutScholarNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUncheckedUpdateManyWithoutScholarNestedInput;
  };

  export type SeriesUpsertWithoutLecturesInput = {
    update: XOR<SeriesUpdateWithoutLecturesInput, SeriesUncheckedUpdateWithoutLecturesInput>;
    create: XOR<SeriesCreateWithoutLecturesInput, SeriesUncheckedCreateWithoutLecturesInput>;
    where?: SeriesWhereInput;
  };

  export type SeriesUpdateToOneWithWhereWithoutLecturesInput = {
    where?: SeriesWhereInput;
    data: XOR<SeriesUpdateWithoutLecturesInput, SeriesUncheckedUpdateWithoutLecturesInput>;
  };

  export type SeriesUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutSeriesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutSeriesNestedInput;
    collection?: CollectionUpdateOneWithoutSeriesNestedInput;
    topics?: SeriesTopicUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    topics?: SeriesTopicUncheckedUpdateManyWithoutSeriesNestedInput;
  };

  export type AudioAssetUpsertWithWhereUniqueWithoutLectureInput = {
    where: AudioAssetWhereUniqueInput;
    update: XOR<AudioAssetUpdateWithoutLectureInput, AudioAssetUncheckedUpdateWithoutLectureInput>;
    create: XOR<AudioAssetCreateWithoutLectureInput, AudioAssetUncheckedCreateWithoutLectureInput>;
  };

  export type AudioAssetUpdateWithWhereUniqueWithoutLectureInput = {
    where: AudioAssetWhereUniqueInput;
    data: XOR<AudioAssetUpdateWithoutLectureInput, AudioAssetUncheckedUpdateWithoutLectureInput>;
  };

  export type AudioAssetUpdateManyWithWhereWithoutLectureInput = {
    where: AudioAssetScalarWhereInput;
    data: XOR<AudioAssetUpdateManyMutationInput, AudioAssetUncheckedUpdateManyWithoutLectureInput>;
  };

  export type LectureTopicUpsertWithWhereUniqueWithoutLectureInput = {
    where: LectureTopicWhereUniqueInput;
    update: XOR<
      LectureTopicUpdateWithoutLectureInput,
      LectureTopicUncheckedUpdateWithoutLectureInput
    >;
    create: XOR<
      LectureTopicCreateWithoutLectureInput,
      LectureTopicUncheckedCreateWithoutLectureInput
    >;
  };

  export type LectureTopicUpdateWithWhereUniqueWithoutLectureInput = {
    where: LectureTopicWhereUniqueInput;
    data: XOR<
      LectureTopicUpdateWithoutLectureInput,
      LectureTopicUncheckedUpdateWithoutLectureInput
    >;
  };

  export type LectureTopicUpdateManyWithWhereWithoutLectureInput = {
    where: LectureTopicScalarWhereInput;
    data: XOR<
      LectureTopicUpdateManyMutationInput,
      LectureTopicUncheckedUpdateManyWithoutLectureInput
    >;
  };

  export type LectureTopicScalarWhereInput = {
    AND?: LectureTopicScalarWhereInput | LectureTopicScalarWhereInput[];
    OR?: LectureTopicScalarWhereInput[];
    NOT?: LectureTopicScalarWhereInput | LectureTopicScalarWhereInput[];
    lectureId?: StringFilter<"LectureTopic"> | string;
    topicId?: StringFilter<"LectureTopic"> | string;
    createdAt?: DateTimeFilter<"LectureTopic"> | Date | string;
  };

  export type UserLectureProgressUpsertWithWhereUniqueWithoutLectureInput = {
    where: UserLectureProgressWhereUniqueInput;
    update: XOR<
      UserLectureProgressUpdateWithoutLectureInput,
      UserLectureProgressUncheckedUpdateWithoutLectureInput
    >;
    create: XOR<
      UserLectureProgressCreateWithoutLectureInput,
      UserLectureProgressUncheckedCreateWithoutLectureInput
    >;
  };

  export type UserLectureProgressUpdateWithWhereUniqueWithoutLectureInput = {
    where: UserLectureProgressWhereUniqueInput;
    data: XOR<
      UserLectureProgressUpdateWithoutLectureInput,
      UserLectureProgressUncheckedUpdateWithoutLectureInput
    >;
  };

  export type UserLectureProgressUpdateManyWithWhereWithoutLectureInput = {
    where: UserLectureProgressScalarWhereInput;
    data: XOR<
      UserLectureProgressUpdateManyMutationInput,
      UserLectureProgressUncheckedUpdateManyWithoutLectureInput
    >;
  };

  export type FavoriteLectureUpsertWithWhereUniqueWithoutLectureInput = {
    where: FavoriteLectureWhereUniqueInput;
    update: XOR<
      FavoriteLectureUpdateWithoutLectureInput,
      FavoriteLectureUncheckedUpdateWithoutLectureInput
    >;
    create: XOR<
      FavoriteLectureCreateWithoutLectureInput,
      FavoriteLectureUncheckedCreateWithoutLectureInput
    >;
  };

  export type FavoriteLectureUpdateWithWhereUniqueWithoutLectureInput = {
    where: FavoriteLectureWhereUniqueInput;
    data: XOR<
      FavoriteLectureUpdateWithoutLectureInput,
      FavoriteLectureUncheckedUpdateWithoutLectureInput
    >;
  };

  export type FavoriteLectureUpdateManyWithWhereWithoutLectureInput = {
    where: FavoriteLectureScalarWhereInput;
    data: XOR<
      FavoriteLectureUpdateManyMutationInput,
      FavoriteLectureUncheckedUpdateManyWithoutLectureInput
    >;
  };

  export type IngestionBatchCreateWithoutAudioAssetsInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchUncheckedCreateWithoutAudioAssetsInput = {
    id?: string;
    tag: string;
    environment: string;
    createdAt?: Date | string;
    scholars?: ScholarUncheckedCreateNestedManyWithoutIngestionBatchInput;
    collections?: CollectionUncheckedCreateNestedManyWithoutIngestionBatchInput;
    series?: SeriesUncheckedCreateNestedManyWithoutIngestionBatchInput;
    lectures?: LectureUncheckedCreateNestedManyWithoutIngestionBatchInput;
  };

  export type IngestionBatchCreateOrConnectWithoutAudioAssetsInput = {
    where: IngestionBatchWhereUniqueInput;
    create: XOR<
      IngestionBatchCreateWithoutAudioAssetsInput,
      IngestionBatchUncheckedCreateWithoutAudioAssetsInput
    >;
  };

  export type LectureCreateWithoutAudioAssetsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutAudioAssetsInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutAudioAssetsInput = {
    where: LectureWhereUniqueInput;
    create: XOR<
      LectureCreateWithoutAudioAssetsInput,
      LectureUncheckedCreateWithoutAudioAssetsInput
    >;
  };

  export type IngestionBatchUpsertWithoutAudioAssetsInput = {
    update: XOR<
      IngestionBatchUpdateWithoutAudioAssetsInput,
      IngestionBatchUncheckedUpdateWithoutAudioAssetsInput
    >;
    create: XOR<
      IngestionBatchCreateWithoutAudioAssetsInput,
      IngestionBatchUncheckedCreateWithoutAudioAssetsInput
    >;
    where?: IngestionBatchWhereInput;
  };

  export type IngestionBatchUpdateToOneWithWhereWithoutAudioAssetsInput = {
    where?: IngestionBatchWhereInput;
    data: XOR<
      IngestionBatchUpdateWithoutAudioAssetsInput,
      IngestionBatchUncheckedUpdateWithoutAudioAssetsInput
    >;
  };

  export type IngestionBatchUpdateWithoutAudioAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type IngestionBatchUncheckedUpdateWithoutAudioAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tag?: StringFieldUpdateOperationsInput | string;
    environment?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholars?: ScholarUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    collections?: CollectionUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutIngestionBatchNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutIngestionBatchNestedInput;
  };

  export type LectureUpsertWithoutAudioAssetsInput = {
    update: XOR<
      LectureUpdateWithoutAudioAssetsInput,
      LectureUncheckedUpdateWithoutAudioAssetsInput
    >;
    create: XOR<
      LectureCreateWithoutAudioAssetsInput,
      LectureUncheckedCreateWithoutAudioAssetsInput
    >;
    where?: LectureWhereInput;
  };

  export type LectureUpdateToOneWithWhereWithoutAudioAssetsInput = {
    where?: LectureWhereInput;
    data: XOR<LectureUpdateWithoutAudioAssetsInput, LectureUncheckedUpdateWithoutAudioAssetsInput>;
  };

  export type LectureUpdateWithoutAudioAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutAudioAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type TopicCreateWithoutChildrenInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    parent?: TopicCreateNestedOneWithoutChildrenInput;
    lectureTopics?: LectureTopicCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutChildrenInput = {
    id?: string;
    slug: string;
    name: string;
    parentId?: string | null;
    createdAt?: Date | string;
    lectureTopics?: LectureTopicUncheckedCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicUncheckedCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutChildrenInput = {
    where: TopicWhereUniqueInput;
    create: XOR<TopicCreateWithoutChildrenInput, TopicUncheckedCreateWithoutChildrenInput>;
  };

  export type TopicCreateWithoutParentInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    children?: TopicCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutParentInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    children?: TopicUncheckedCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicUncheckedCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicUncheckedCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutParentInput = {
    where: TopicWhereUniqueInput;
    create: XOR<TopicCreateWithoutParentInput, TopicUncheckedCreateWithoutParentInput>;
  };

  export type TopicCreateManyParentInputEnvelope = {
    data: TopicCreateManyParentInput | TopicCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type LectureTopicCreateWithoutTopicInput = {
    createdAt?: Date | string;
    lecture: LectureCreateNestedOneWithoutTopicsInput;
  };

  export type LectureTopicUncheckedCreateWithoutTopicInput = {
    lectureId: string;
    createdAt?: Date | string;
  };

  export type LectureTopicCreateOrConnectWithoutTopicInput = {
    where: LectureTopicWhereUniqueInput;
    create: XOR<LectureTopicCreateWithoutTopicInput, LectureTopicUncheckedCreateWithoutTopicInput>;
  };

  export type LectureTopicCreateManyTopicInputEnvelope = {
    data: LectureTopicCreateManyTopicInput | LectureTopicCreateManyTopicInput[];
    skipDuplicates?: boolean;
  };

  export type SeriesTopicCreateWithoutTopicInput = {
    createdAt?: Date | string;
    series: SeriesCreateNestedOneWithoutTopicsInput;
  };

  export type SeriesTopicUncheckedCreateWithoutTopicInput = {
    seriesId: string;
    createdAt?: Date | string;
  };

  export type SeriesTopicCreateOrConnectWithoutTopicInput = {
    where: SeriesTopicWhereUniqueInput;
    create: XOR<SeriesTopicCreateWithoutTopicInput, SeriesTopicUncheckedCreateWithoutTopicInput>;
  };

  export type SeriesTopicCreateManyTopicInputEnvelope = {
    data: SeriesTopicCreateManyTopicInput | SeriesTopicCreateManyTopicInput[];
    skipDuplicates?: boolean;
  };

  export type CollectionTopicCreateWithoutTopicInput = {
    createdAt?: Date | string;
    collection: CollectionCreateNestedOneWithoutTopicsInput;
  };

  export type CollectionTopicUncheckedCreateWithoutTopicInput = {
    collectionId: string;
    createdAt?: Date | string;
  };

  export type CollectionTopicCreateOrConnectWithoutTopicInput = {
    where: CollectionTopicWhereUniqueInput;
    create: XOR<
      CollectionTopicCreateWithoutTopicInput,
      CollectionTopicUncheckedCreateWithoutTopicInput
    >;
  };

  export type CollectionTopicCreateManyTopicInputEnvelope = {
    data: CollectionTopicCreateManyTopicInput | CollectionTopicCreateManyTopicInput[];
    skipDuplicates?: boolean;
  };

  export type TopicUpsertWithoutChildrenInput = {
    update: XOR<TopicUpdateWithoutChildrenInput, TopicUncheckedUpdateWithoutChildrenInput>;
    create: XOR<TopicCreateWithoutChildrenInput, TopicUncheckedCreateWithoutChildrenInput>;
    where?: TopicWhereInput;
  };

  export type TopicUpdateToOneWithWhereWithoutChildrenInput = {
    where?: TopicWhereInput;
    data: XOR<TopicUpdateWithoutChildrenInput, TopicUncheckedUpdateWithoutChildrenInput>;
  };

  export type TopicUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: TopicUpdateOneWithoutChildrenNestedInput;
    lectureTopics?: LectureTopicUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lectureTopics?: LectureTopicUncheckedUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUncheckedUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUpsertWithWhereUniqueWithoutParentInput = {
    where: TopicWhereUniqueInput;
    update: XOR<TopicUpdateWithoutParentInput, TopicUncheckedUpdateWithoutParentInput>;
    create: XOR<TopicCreateWithoutParentInput, TopicUncheckedCreateWithoutParentInput>;
  };

  export type TopicUpdateWithWhereUniqueWithoutParentInput = {
    where: TopicWhereUniqueInput;
    data: XOR<TopicUpdateWithoutParentInput, TopicUncheckedUpdateWithoutParentInput>;
  };

  export type TopicUpdateManyWithWhereWithoutParentInput = {
    where: TopicScalarWhereInput;
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutParentInput>;
  };

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[];
    OR?: TopicScalarWhereInput[];
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[];
    id?: StringFilter<"Topic"> | string;
    slug?: StringFilter<"Topic"> | string;
    name?: StringFilter<"Topic"> | string;
    parentId?: StringNullableFilter<"Topic"> | string | null;
    createdAt?: DateTimeFilter<"Topic"> | Date | string;
  };

  export type LectureTopicUpsertWithWhereUniqueWithoutTopicInput = {
    where: LectureTopicWhereUniqueInput;
    update: XOR<LectureTopicUpdateWithoutTopicInput, LectureTopicUncheckedUpdateWithoutTopicInput>;
    create: XOR<LectureTopicCreateWithoutTopicInput, LectureTopicUncheckedCreateWithoutTopicInput>;
  };

  export type LectureTopicUpdateWithWhereUniqueWithoutTopicInput = {
    where: LectureTopicWhereUniqueInput;
    data: XOR<LectureTopicUpdateWithoutTopicInput, LectureTopicUncheckedUpdateWithoutTopicInput>;
  };

  export type LectureTopicUpdateManyWithWhereWithoutTopicInput = {
    where: LectureTopicScalarWhereInput;
    data: XOR<
      LectureTopicUpdateManyMutationInput,
      LectureTopicUncheckedUpdateManyWithoutTopicInput
    >;
  };

  export type SeriesTopicUpsertWithWhereUniqueWithoutTopicInput = {
    where: SeriesTopicWhereUniqueInput;
    update: XOR<SeriesTopicUpdateWithoutTopicInput, SeriesTopicUncheckedUpdateWithoutTopicInput>;
    create: XOR<SeriesTopicCreateWithoutTopicInput, SeriesTopicUncheckedCreateWithoutTopicInput>;
  };

  export type SeriesTopicUpdateWithWhereUniqueWithoutTopicInput = {
    where: SeriesTopicWhereUniqueInput;
    data: XOR<SeriesTopicUpdateWithoutTopicInput, SeriesTopicUncheckedUpdateWithoutTopicInput>;
  };

  export type SeriesTopicUpdateManyWithWhereWithoutTopicInput = {
    where: SeriesTopicScalarWhereInput;
    data: XOR<SeriesTopicUpdateManyMutationInput, SeriesTopicUncheckedUpdateManyWithoutTopicInput>;
  };

  export type CollectionTopicUpsertWithWhereUniqueWithoutTopicInput = {
    where: CollectionTopicWhereUniqueInput;
    update: XOR<
      CollectionTopicUpdateWithoutTopicInput,
      CollectionTopicUncheckedUpdateWithoutTopicInput
    >;
    create: XOR<
      CollectionTopicCreateWithoutTopicInput,
      CollectionTopicUncheckedCreateWithoutTopicInput
    >;
  };

  export type CollectionTopicUpdateWithWhereUniqueWithoutTopicInput = {
    where: CollectionTopicWhereUniqueInput;
    data: XOR<
      CollectionTopicUpdateWithoutTopicInput,
      CollectionTopicUncheckedUpdateWithoutTopicInput
    >;
  };

  export type CollectionTopicUpdateManyWithWhereWithoutTopicInput = {
    where: CollectionTopicScalarWhereInput;
    data: XOR<
      CollectionTopicUpdateManyMutationInput,
      CollectionTopicUncheckedUpdateManyWithoutTopicInput
    >;
  };

  export type LectureCreateWithoutTopicsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutTopicsInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutTopicsInput = {
    where: LectureWhereUniqueInput;
    create: XOR<LectureCreateWithoutTopicsInput, LectureUncheckedCreateWithoutTopicsInput>;
  };

  export type TopicCreateWithoutLectureTopicsInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    parent?: TopicCreateNestedOneWithoutChildrenInput;
    children?: TopicCreateNestedManyWithoutParentInput;
    seriesTopics?: SeriesTopicCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutLectureTopicsInput = {
    id?: string;
    slug: string;
    name: string;
    parentId?: string | null;
    createdAt?: Date | string;
    children?: TopicUncheckedCreateNestedManyWithoutParentInput;
    seriesTopics?: SeriesTopicUncheckedCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutLectureTopicsInput = {
    where: TopicWhereUniqueInput;
    create: XOR<
      TopicCreateWithoutLectureTopicsInput,
      TopicUncheckedCreateWithoutLectureTopicsInput
    >;
  };

  export type LectureUpsertWithoutTopicsInput = {
    update: XOR<LectureUpdateWithoutTopicsInput, LectureUncheckedUpdateWithoutTopicsInput>;
    create: XOR<LectureCreateWithoutTopicsInput, LectureUncheckedCreateWithoutTopicsInput>;
    where?: LectureWhereInput;
  };

  export type LectureUpdateToOneWithWhereWithoutTopicsInput = {
    where?: LectureWhereInput;
    data: XOR<LectureUpdateWithoutTopicsInput, LectureUncheckedUpdateWithoutTopicsInput>;
  };

  export type LectureUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type TopicUpsertWithoutLectureTopicsInput = {
    update: XOR<
      TopicUpdateWithoutLectureTopicsInput,
      TopicUncheckedUpdateWithoutLectureTopicsInput
    >;
    create: XOR<
      TopicCreateWithoutLectureTopicsInput,
      TopicUncheckedCreateWithoutLectureTopicsInput
    >;
    where?: TopicWhereInput;
  };

  export type TopicUpdateToOneWithWhereWithoutLectureTopicsInput = {
    where?: TopicWhereInput;
    data: XOR<TopicUpdateWithoutLectureTopicsInput, TopicUncheckedUpdateWithoutLectureTopicsInput>;
  };

  export type TopicUpdateWithoutLectureTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: TopicUpdateOneWithoutChildrenNestedInput;
    children?: TopicUpdateManyWithoutParentNestedInput;
    seriesTopics?: SeriesTopicUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutLectureTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: TopicUncheckedUpdateManyWithoutParentNestedInput;
    seriesTopics?: SeriesTopicUncheckedUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type SeriesCreateWithoutTopicsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutSeriesInput;
    scholar: ScholarCreateNestedOneWithoutSeriesInput;
    collection?: CollectionCreateNestedOneWithoutSeriesInput;
    lectures?: LectureCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesUncheckedCreateWithoutTopicsInput = {
    id?: string;
    scholarId: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    lectures?: LectureUncheckedCreateNestedManyWithoutSeriesInput;
  };

  export type SeriesCreateOrConnectWithoutTopicsInput = {
    where: SeriesWhereUniqueInput;
    create: XOR<SeriesCreateWithoutTopicsInput, SeriesUncheckedCreateWithoutTopicsInput>;
  };

  export type TopicCreateWithoutSeriesTopicsInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    parent?: TopicCreateNestedOneWithoutChildrenInput;
    children?: TopicCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutSeriesTopicsInput = {
    id?: string;
    slug: string;
    name: string;
    parentId?: string | null;
    createdAt?: Date | string;
    children?: TopicUncheckedCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicUncheckedCreateNestedManyWithoutTopicInput;
    collectionTopics?: CollectionTopicUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutSeriesTopicsInput = {
    where: TopicWhereUniqueInput;
    create: XOR<TopicCreateWithoutSeriesTopicsInput, TopicUncheckedCreateWithoutSeriesTopicsInput>;
  };

  export type SeriesUpsertWithoutTopicsInput = {
    update: XOR<SeriesUpdateWithoutTopicsInput, SeriesUncheckedUpdateWithoutTopicsInput>;
    create: XOR<SeriesCreateWithoutTopicsInput, SeriesUncheckedCreateWithoutTopicsInput>;
    where?: SeriesWhereInput;
  };

  export type SeriesUpdateToOneWithWhereWithoutTopicsInput = {
    where?: SeriesWhereInput;
    data: XOR<SeriesUpdateWithoutTopicsInput, SeriesUncheckedUpdateWithoutTopicsInput>;
  };

  export type SeriesUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutSeriesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutSeriesNestedInput;
    collection?: CollectionUpdateOneWithoutSeriesNestedInput;
    lectures?: LectureUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    lectures?: LectureUncheckedUpdateManyWithoutSeriesNestedInput;
  };

  export type TopicUpsertWithoutSeriesTopicsInput = {
    update: XOR<TopicUpdateWithoutSeriesTopicsInput, TopicUncheckedUpdateWithoutSeriesTopicsInput>;
    create: XOR<TopicCreateWithoutSeriesTopicsInput, TopicUncheckedCreateWithoutSeriesTopicsInput>;
    where?: TopicWhereInput;
  };

  export type TopicUpdateToOneWithWhereWithoutSeriesTopicsInput = {
    where?: TopicWhereInput;
    data: XOR<TopicUpdateWithoutSeriesTopicsInput, TopicUncheckedUpdateWithoutSeriesTopicsInput>;
  };

  export type TopicUpdateWithoutSeriesTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: TopicUpdateOneWithoutChildrenNestedInput;
    children?: TopicUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutSeriesTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: TopicUncheckedUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUncheckedUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type CollectionCreateWithoutTopicsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutCollectionsInput;
    scholar: ScholarCreateNestedOneWithoutCollectionsInput;
    series?: SeriesCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionUncheckedCreateWithoutTopicsInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput;
  };

  export type CollectionCreateOrConnectWithoutTopicsInput = {
    where: CollectionWhereUniqueInput;
    create: XOR<CollectionCreateWithoutTopicsInput, CollectionUncheckedCreateWithoutTopicsInput>;
  };

  export type TopicCreateWithoutCollectionTopicsInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
    parent?: TopicCreateNestedOneWithoutChildrenInput;
    children?: TopicCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutCollectionTopicsInput = {
    id?: string;
    slug: string;
    name: string;
    parentId?: string | null;
    createdAt?: Date | string;
    children?: TopicUncheckedCreateNestedManyWithoutParentInput;
    lectureTopics?: LectureTopicUncheckedCreateNestedManyWithoutTopicInput;
    seriesTopics?: SeriesTopicUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutCollectionTopicsInput = {
    where: TopicWhereUniqueInput;
    create: XOR<
      TopicCreateWithoutCollectionTopicsInput,
      TopicUncheckedCreateWithoutCollectionTopicsInput
    >;
  };

  export type CollectionUpsertWithoutTopicsInput = {
    update: XOR<CollectionUpdateWithoutTopicsInput, CollectionUncheckedUpdateWithoutTopicsInput>;
    create: XOR<CollectionCreateWithoutTopicsInput, CollectionUncheckedCreateWithoutTopicsInput>;
    where?: CollectionWhereInput;
  };

  export type CollectionUpdateToOneWithWhereWithoutTopicsInput = {
    where?: CollectionWhereInput;
    data: XOR<CollectionUpdateWithoutTopicsInput, CollectionUncheckedUpdateWithoutTopicsInput>;
  };

  export type CollectionUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutCollectionsNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutCollectionsNestedInput;
    series?: SeriesUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput;
  };

  export type TopicUpsertWithoutCollectionTopicsInput = {
    update: XOR<
      TopicUpdateWithoutCollectionTopicsInput,
      TopicUncheckedUpdateWithoutCollectionTopicsInput
    >;
    create: XOR<
      TopicCreateWithoutCollectionTopicsInput,
      TopicUncheckedCreateWithoutCollectionTopicsInput
    >;
    where?: TopicWhereInput;
  };

  export type TopicUpdateToOneWithWhereWithoutCollectionTopicsInput = {
    where?: TopicWhereInput;
    data: XOR<
      TopicUpdateWithoutCollectionTopicsInput,
      TopicUncheckedUpdateWithoutCollectionTopicsInput
    >;
  };

  export type TopicUpdateWithoutCollectionTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: TopicUpdateOneWithoutChildrenNestedInput;
    children?: TopicUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutCollectionTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: TopicUncheckedUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUncheckedUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type UserCreateWithoutProgressInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleCreateNestedManyWithoutCreatedByUserInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutProgressInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleUncheckedCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutCreatedByUserInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutProgressInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>;
  };

  export type LectureCreateWithoutProgressInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutProgressInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    favorites?: FavoriteLectureUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutProgressInput = {
    where: LectureWhereUniqueInput;
    create: XOR<LectureCreateWithoutProgressInput, LectureUncheckedCreateWithoutProgressInput>;
  };

  export type UserUpsertWithoutProgressInput = {
    update: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>;
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>;
  };

  export type UserUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUpdateManyWithoutCreatedByUserNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUncheckedUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type LectureUpsertWithoutProgressInput = {
    update: XOR<LectureUpdateWithoutProgressInput, LectureUncheckedUpdateWithoutProgressInput>;
    create: XOR<LectureCreateWithoutProgressInput, LectureUncheckedCreateWithoutProgressInput>;
    where?: LectureWhereInput;
  };

  export type LectureUpdateToOneWithWhereWithoutProgressInput = {
    where?: LectureWhereInput;
    data: XOR<LectureUpdateWithoutProgressInput, LectureUncheckedUpdateWithoutProgressInput>;
  };

  export type LectureUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type UserCreateWithoutFavoritesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string;
    email?: string | null;
    emailNormalized?: string | null;
    emailVerifiedAt?: Date | string | null;
    name?: string | null;
    preferredLanguage?: string | null;
    passwordHash?: string | null;
    passwordUpdatedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deactivatedAt?: Date | string | null;
    erasureRequestedAt?: Date | string | null;
    erasedAt?: Date | string | null;
    isBanned?: boolean;
    globalRoles?: UserGlobalRoleUncheckedCreateNestedManyWithoutUserInput;
    scholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutUserInput;
    createdScholarRoles?: UserScholarRoleUncheckedCreateNestedManyWithoutCreatedByUserInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>;
  };

  export type LectureCreateWithoutFavoritesInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatch?: IngestionBatchCreateNestedOneWithoutLecturesInput;
    scholar: ScholarCreateNestedOneWithoutLecturesInput;
    series?: SeriesCreateNestedOneWithoutLecturesInput;
    audioAssets?: AudioAssetCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressCreateNestedManyWithoutLectureInput;
  };

  export type LectureUncheckedCreateWithoutFavoritesInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
    audioAssets?: AudioAssetUncheckedCreateNestedManyWithoutLectureInput;
    topics?: LectureTopicUncheckedCreateNestedManyWithoutLectureInput;
    progress?: UserLectureProgressUncheckedCreateNestedManyWithoutLectureInput;
  };

  export type LectureCreateOrConnectWithoutFavoritesInput = {
    where: LectureWhereUniqueInput;
    create: XOR<LectureCreateWithoutFavoritesInput, LectureUncheckedCreateWithoutFavoritesInput>;
  };

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>;
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>;
  };

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasureRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    erasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    globalRoles?: UserGlobalRoleUncheckedUpdateManyWithoutUserNestedInput;
    scholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutUserNestedInput;
    createdScholarRoles?: UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type LectureUpsertWithoutFavoritesInput = {
    update: XOR<LectureUpdateWithoutFavoritesInput, LectureUncheckedUpdateWithoutFavoritesInput>;
    create: XOR<LectureCreateWithoutFavoritesInput, LectureUncheckedCreateWithoutFavoritesInput>;
    where?: LectureWhereInput;
  };

  export type LectureUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: LectureWhereInput;
    data: XOR<LectureUpdateWithoutFavoritesInput, LectureUncheckedUpdateWithoutFavoritesInput>;
  };

  export type LectureUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type ScholarCreateManyIngestionBatchInput = {
    id?: string;
    slug: string;
    name: string;
    bio?: string | null;
    country?: string | null;
    mainLanguage?: string | null;
    imageUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
  };

  export type CollectionCreateManyIngestionBatchInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
  };

  export type SeriesCreateManyIngestionBatchInput = {
    id?: string;
    scholarId: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
  };

  export type LectureCreateManyIngestionBatchInput = {
    id?: string;
    scholarId: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
  };

  export type AudioAssetCreateManyIngestionBatchInput = {
    id?: string;
    lectureId: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
  };

  export type ScholarUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    collections?: CollectionUpdateManyWithoutScholarNestedInput;
    series?: SeriesUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    collections?: CollectionUncheckedUpdateManyWithoutScholarNestedInput;
    series?: SeriesUncheckedUpdateManyWithoutScholarNestedInput;
    lectures?: LectureUncheckedUpdateManyWithoutScholarNestedInput;
    userRoles?: UserScholarRoleUncheckedUpdateManyWithoutScholarNestedInput;
  };

  export type ScholarUncheckedUpdateManyWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    mainLanguage?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type CollectionUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scholar?: ScholarUpdateOneRequiredWithoutCollectionsNestedInput;
    series?: SeriesUpdateManyWithoutCollectionNestedInput;
    topics?: CollectionTopicUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput;
    topics?: CollectionTopicUncheckedUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateManyWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type SeriesUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scholar?: ScholarUpdateOneRequiredWithoutSeriesNestedInput;
    collection?: CollectionUpdateOneWithoutSeriesNestedInput;
    lectures?: LectureUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lectures?: LectureUncheckedUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUncheckedUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateManyWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type LectureUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateManyWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type AudioAssetUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lecture?: LectureUpdateOneRequiredWithoutAudioAssetsNestedInput;
  };

  export type AudioAssetUncheckedUpdateWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AudioAssetUncheckedUpdateManyWithoutIngestionBatchInput = {
    id?: StringFieldUpdateOperationsInput | string;
    lectureId?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserGlobalRoleCreateManyUserInput = {
    role: $Enums.GlobalRole;
    createdAt?: Date | string;
  };

  export type UserScholarRoleCreateManyUserInput = {
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    createdByUserId?: string | null;
  };

  export type UserScholarRoleCreateManyCreatedByUserInput = {
    userId: string;
    scholarId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
  };

  export type UserLectureProgressCreateManyUserInput = {
    lectureId: string;
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
  };

  export type FavoriteLectureCreateManyUserInput = {
    lectureId: string;
    createdAt?: Date | string;
  };

  export type UserGlobalRoleUpdateWithoutUserInput = {
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserGlobalRoleUncheckedUpdateWithoutUserInput = {
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserGlobalRoleUncheckedUpdateManyWithoutUserInput = {
    role?: EnumGlobalRoleFieldUpdateOperationsInput | $Enums.GlobalRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserScholarRoleUpdateWithoutUserInput = {
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scholar?: ScholarUpdateOneRequiredWithoutUserRolesNestedInput;
    createdByUser?: UserUpdateOneWithoutCreatedScholarRolesNestedInput;
  };

  export type UserScholarRoleUncheckedUpdateWithoutUserInput = {
    scholarId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserScholarRoleUncheckedUpdateManyWithoutUserInput = {
    scholarId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserScholarRoleUpdateWithoutCreatedByUserInput = {
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutScholarRolesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type UserScholarRoleUncheckedUpdateWithoutCreatedByUserInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserScholarRoleUncheckedUpdateManyWithoutCreatedByUserInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressUpdateWithoutUserInput = {
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lecture?: LectureUpdateOneRequiredWithoutProgressNestedInput;
  };

  export type UserLectureProgressUncheckedUpdateWithoutUserInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressUncheckedUpdateManyWithoutUserInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lecture?: LectureUpdateOneRequiredWithoutFavoritesNestedInput;
  };

  export type FavoriteLectureUncheckedUpdateWithoutUserInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureUncheckedUpdateManyWithoutUserInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionCreateManyScholarInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type SeriesCreateManyScholarInput = {
    id?: string;
    collectionId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type LectureCreateManyScholarInput = {
    id?: string;
    seriesId?: string | null;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type UserScholarRoleCreateManyScholarInput = {
    userId: string;
    role: $Enums.ScholarRole;
    createdAt?: Date | string;
    createdByUserId?: string | null;
  };

  export type CollectionUpdateWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutCollectionsNestedInput;
    series?: SeriesUpdateManyWithoutCollectionNestedInput;
    topics?: CollectionTopicUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput;
    topics?: CollectionTopicUncheckedUpdateManyWithoutCollectionNestedInput;
  };

  export type CollectionUncheckedUpdateManyWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SeriesUpdateWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutSeriesNestedInput;
    collection?: CollectionUpdateOneWithoutSeriesNestedInput;
    lectures?: LectureUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    lectures?: LectureUncheckedUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUncheckedUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateManyWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LectureUpdateWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    series?: SeriesUpdateOneWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateManyWithoutScholarInput = {
    id?: StringFieldUpdateOperationsInput | string;
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserScholarRoleUpdateWithoutScholarInput = {
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutScholarRolesNestedInput;
    createdByUser?: UserUpdateOneWithoutCreatedScholarRolesNestedInput;
  };

  export type UserScholarRoleUncheckedUpdateWithoutScholarInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserScholarRoleUncheckedUpdateManyWithoutScholarInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumScholarRoleFieldUpdateOperationsInput | $Enums.ScholarRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SeriesCreateManyCollectionInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    coverImageUrl?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    orderIndex?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type CollectionTopicCreateManyCollectionInput = {
    topicId: string;
    createdAt?: Date | string;
  };

  export type SeriesUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutSeriesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutSeriesNestedInput;
    lectures?: LectureUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    lectures?: LectureUncheckedUpdateManyWithoutSeriesNestedInput;
    topics?: SeriesTopicUncheckedUpdateManyWithoutSeriesNestedInput;
  };

  export type SeriesUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CollectionTopicUpdateWithoutCollectionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    topic?: TopicUpdateOneRequiredWithoutCollectionTopicsNestedInput;
  };

  export type CollectionTopicUncheckedUpdateWithoutCollectionInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionTopicUncheckedUpdateManyWithoutCollectionInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureCreateManySeriesInput = {
    id?: string;
    scholarId: string;
    slug: string;
    title: string;
    description?: string | null;
    language?: string | null;
    status?: $Enums.Status;
    publishedAt?: Date | string | null;
    orderIndex?: number | null;
    durationSeconds?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    deleteAfterAt?: Date | string | null;
    ingestionBatchId?: string | null;
  };

  export type SeriesTopicCreateManySeriesInput = {
    topicId: string;
    createdAt?: Date | string;
  };

  export type LectureUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatch?: IngestionBatchUpdateOneWithoutLecturesNestedInput;
    scholar?: ScholarUpdateOneRequiredWithoutLecturesNestedInput;
    audioAssets?: AudioAssetUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
    audioAssets?: AudioAssetUncheckedUpdateManyWithoutLectureNestedInput;
    topics?: LectureTopicUncheckedUpdateManyWithoutLectureNestedInput;
    progress?: UserLectureProgressUncheckedUpdateManyWithoutLectureNestedInput;
    favorites?: FavoriteLectureUncheckedUpdateManyWithoutLectureNestedInput;
  };

  export type LectureUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scholarId?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    orderIndex?: NullableIntFieldUpdateOperationsInput | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deleteAfterAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SeriesTopicUpdateWithoutSeriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    topic?: TopicUpdateOneRequiredWithoutSeriesTopicsNestedInput;
  };

  export type SeriesTopicUncheckedUpdateWithoutSeriesInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SeriesTopicUncheckedUpdateManyWithoutSeriesInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AudioAssetCreateManyLectureInput = {
    id?: string;
    url: string;
    format?: string | null;
    bitrateKbps?: number | null;
    sizeBytes?: bigint | number | null;
    durationSeconds?: number | null;
    source?: string | null;
    isPrimary?: boolean;
    createdAt?: Date | string;
    ingestionBatchId?: string | null;
  };

  export type LectureTopicCreateManyLectureInput = {
    topicId: string;
    createdAt?: Date | string;
  };

  export type UserLectureProgressCreateManyLectureInput = {
    userId: string;
    positionSeconds?: number;
    isCompleted?: boolean;
    updatedAt?: Date | string;
  };

  export type FavoriteLectureCreateManyLectureInput = {
    userId: string;
    createdAt?: Date | string;
  };

  export type AudioAssetUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ingestionBatch?: IngestionBatchUpdateOneWithoutAudioAssetsNestedInput;
  };

  export type AudioAssetUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AudioAssetUncheckedUpdateManyWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    format?: NullableStringFieldUpdateOperationsInput | string | null;
    bitrateKbps?: NullableIntFieldUpdateOperationsInput | number | null;
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null;
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null;
    source?: NullableStringFieldUpdateOperationsInput | string | null;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ingestionBatchId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LectureTopicUpdateWithoutLectureInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    topic?: TopicUpdateOneRequiredWithoutLectureTopicsNestedInput;
  };

  export type LectureTopicUncheckedUpdateWithoutLectureInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureTopicUncheckedUpdateManyWithoutLectureInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressUpdateWithoutLectureInput = {
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutProgressNestedInput;
  };

  export type UserLectureProgressUncheckedUpdateWithoutLectureInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLectureProgressUncheckedUpdateManyWithoutLectureInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    positionSeconds?: IntFieldUpdateOperationsInput | number;
    isCompleted?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureUpdateWithoutLectureInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput;
  };

  export type FavoriteLectureUncheckedUpdateWithoutLectureInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FavoriteLectureUncheckedUpdateManyWithoutLectureInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TopicCreateManyParentInput = {
    id?: string;
    slug: string;
    name: string;
    createdAt?: Date | string;
  };

  export type LectureTopicCreateManyTopicInput = {
    lectureId: string;
    createdAt?: Date | string;
  };

  export type SeriesTopicCreateManyTopicInput = {
    seriesId: string;
    createdAt?: Date | string;
  };

  export type CollectionTopicCreateManyTopicInput = {
    collectionId: string;
    createdAt?: Date | string;
  };

  export type TopicUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: TopicUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: TopicUncheckedUpdateManyWithoutParentNestedInput;
    lectureTopics?: LectureTopicUncheckedUpdateManyWithoutTopicNestedInput;
    seriesTopics?: SeriesTopicUncheckedUpdateManyWithoutTopicNestedInput;
    collectionTopics?: CollectionTopicUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureTopicUpdateWithoutTopicInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lecture?: LectureUpdateOneRequiredWithoutTopicsNestedInput;
  };

  export type LectureTopicUncheckedUpdateWithoutTopicInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LectureTopicUncheckedUpdateManyWithoutTopicInput = {
    lectureId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SeriesTopicUpdateWithoutTopicInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    series?: SeriesUpdateOneRequiredWithoutTopicsNestedInput;
  };

  export type SeriesTopicUncheckedUpdateWithoutTopicInput = {
    seriesId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SeriesTopicUncheckedUpdateManyWithoutTopicInput = {
    seriesId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionTopicUpdateWithoutTopicInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    collection?: CollectionUpdateOneRequiredWithoutTopicsNestedInput;
  };

  export type CollectionTopicUncheckedUpdateWithoutTopicInput = {
    collectionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CollectionTopicUncheckedUpdateManyWithoutTopicInput = {
    collectionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
